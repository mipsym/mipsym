<!DOCTYPE html><html lang=en><head><meta charset=UTF-8><meta name=description content="MIPSym is an academic tool used to teach assembly language programming."><meta name=keywords content="MIPS MIPSym simulation assembler R2000 R3000"><title>MIPSym Documentation</title><link rel=icon href=resources/img/favicon.ico><meta name=viewport content="width=device-width, initial-scale=1"><script>(function(i,s,o,g,r,a,m){{i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){{(i[r].q=i[r].q||[]).push(arguments)}},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)}})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-84648174-1', 'auto');ga('send', 'pageview');</script><link rel=stylesheet href=resources/include/styles/mipsym-bootstrap.css type=text/css><script src=https://code.jquery.com/jquery-3.4.1.slim.min.js integrity=sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n crossorigin=anonymous defer></script><script src=https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js integrity=sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6 crossorigin=anonymous defer></script><script> $(document).ready(function(){$("#toggle-toc-btn").click(function(){if($(this).hasClass("opened")){$("div.sidebar-col").removeClass("col-lg-3").addClass("col-lg-1");$("div.contents-col").removeClass("col-lg-9").addClass("col-lg-11");$("div.sidebar-col nav *").hide();$(this).removeClass("opened").addClass("closed").show().children().show();}else{$("div.sidebar-col").removeClass("col-lg-1").addClass("col-lg-3");$("div.contents-col").removeClass("col-lg-11").addClass("col-lg-9");$("div.sidebar-col nav *").show();$(".sidebar-col .dp3").css("display","");$(this).removeClass("closed").addClass("opened").show();}});}); </script></head><body><div class=container-fluid><div class=row><div class="col-lg-3 d-none d-lg-block sidebar-col navbar-dark bg-dark"><nav id=navbar-contents class="navbar navbar-dark"><a class=navbar-brand href=#>MIPSym Documentation</a><button id=toggle-toc-btn type=button aria-label="Toggle Table of Contents" class="navbar-toggler opened" style="text-align: right"><span class=navbar-toggler-icon></span></button><nav class="nav nav-pills dark-pill flex-column"><a class="nav-link dp1" href=#mipsym_documentation>MIPSym User's Guide</a><nav class="nav nav-pills dark-pill flex-column"><a class="nav-link dp2" href=#mipsym>Using the MIPSym Simulator</a><nav class="nav nav-pills dark-pill flex-column"><a class="nav-link dp3" href=#mipsym_files>Files</a><a class="nav-link dp3" href=#mipsym_find>Find and Replace</a><a class="nav-link dp3" href=#mipsym_shortcuts>Code editor shortcut keys</a><a class="nav-link dp3" href=#mipsym_panels>Panels</a><a class="nav-link dp3" href=#mipsym_build>Building Code</a><a class="nav-link dp3" href=#mipsym_run>Running Code</a><a class="nav-link dp3" href=#mipsym_breakpoints>Breakpoints</a><a class="nav-link dp3" href=#mipsym_privacy>Privacy</a></nav><a class="nav-link dp2" href=#mipsymcli>Using the MIPSymCLI Simulator</a><nav class="nav nav-pills dark-pill flex-column"><a class="nav-link dp3" href=#mipsymcli_win>Windows</a><nav class="nav nav-pills dark-pill flex-column"><a class="nav-link dp4" href=#mipsymcli_win_assembly>Assembling Programs</a><a class="nav-link dp4" href=#mipsymcli_win_run>Running Programs</a></nav><a class="nav-link dp3" href=#mipsymcli_linux>Linux</a><a class="nav-link dp3" href=#mipsymcli_mac>Mac</a><a class="nav-link dp3" href=#mipsymcli_debug>Debugging Programs in MIPSymCLI</a><nav class="nav nav-pills dark-pill flex-column"><a class="nav-link dp4" href=#mipsymcli_win_memory>The Memory Viewer/Editor</a></nav></nav><a class="nav-link dp2" href=#differences>Differences between MIPSym's assembler and other MIPS assemblers (SPIM, GCC etc)</a><nav class="nav nav-pills dark-pill flex-column"><a class="nav-link dp3" href=#delay>Delay slot</a><a class="nav-link dp3" href=#fields>Fields</a><a class="nav-link dp3" href=#expressions>Expressions</a><a class="nav-link dp3" href=#aliasing>Aliasing and Constant Values</a><a class="nav-link dp3" href=#repeats>Repeating Data</a><a class="nav-link dp3" href=#char_literals>Character literals</a><a class="nav-link dp3" href=#keywords>Keywords/Reserved Words</a><a class="nav-link dp3" href=#other>Syscalls, Register Names, Pseudocodes, and Macros</a></nav></nav><a class="nav-link dp1" href=#reference>Quick Reference Guide</a><nav class="nav nav-pills dark-pill flex-column"><a class="nav-link dp2" href=#pseudos>Pseudocodes (aka assembler directives)</a><a class="nav-link dp2" href=#syscalls>Syscalls</a><nav class="nav nav-pills dark-pill flex-column"><a class="nav-link dp3" href=#spim_syscalls>SPIM-Compatible Syscalls</a><a class="nav-link dp3" href=#mipsym_syscalls>MIPSym-Specific Syscalls</a></nav><a class="nav-link dp2" href=#registers>Register Names</a><nav class="nav nav-pills dark-pill flex-column"><a class="nav-link dp3" href=#int_registers>Integer Registers</a><a class="nav-link dp3" href=#flt_registers>Floating Point Registers</a><a class="nav-link dp3" href=#cp0_registers>Coprocessor 0 Control Registers</a><a class="nav-link dp3" href=#cp1_registers>Coprocessor 1 Control Registers</a></nav><a class="nav-link dp2" href=#opcodes>Opcodes and Macros</a><nav class="nav nav-pills dark-pill flex-column"><a class="nav-link dp3" href=#table_explanation>How to read these tables</a><a class="nav-link dp3" href=#int_opcodes>Integer Instruction Set</a><a class="nav-link dp3" href=#fp_opcodes>Floating-Point Instruction Set</a><a class="nav-link dp3" href=#fp_math_opcodes>Floating-Point Math Opcodes, MIPSym-Specific</a><a class="nav-link dp3" href=#macros>Macros</a><a class="nav-link dp3" href=#full_list_opcodes_macros>Full Listing of All Opcodes and Macros</a></nav></nav></nav></nav></div><!-- sidebar --><div class="col-lg-9 col-md-12 contents-col" data-spy=scroll data-target=#navbar-contents data-offset=50><nav class="navbar navbar-expand-md navbar-dark bg-dark"><a class=navbar-brand href=#>MIPSym.com</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#pageNavbar aria-controls=pageNavbar aria-expanded=false aria-label="Toggle page navigation"><span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=pageNavbar><ul class="nav navbar-nav mr-auto"><li id=DownloadsNavBar class=nav-item><a class=nav-link href=index.html>Downloads</a></li><li id=DocumentationNavBar class="nav-item active"><a class=nav-link href=#>Documentation</a></li><li id=ChangeLogNavBar class=nav-item><a class=nav-link href=ChangeLog.html>Change Log</a></li><li id=CrossCompileNavBar class=nav-item><a class=nav-link href=CrossCompile.html>Cross Compile</a></li><li id=AboutNavBar class=nav-item><a class=nav-link href=About.html>About</a></li></ul></div></nav> <div class=content><h1 id=mipsym_documentation>MIPSym User's Guide</h1><hr><p><br><br></p><h2 id=mipsym>Using the MIPSym Simulator</h2><hr><p><br><br></p><h3 id=mipsym_files>Files</h3><p>MIPSym is designed to open text files with a <code>.asm</code> or <code>.s</code> extension.</p><p>MIPSym can also open MIPSym-assembler generated object files with a <code>.obj</code> extension, using the <strong>'File &gt; Load .obj'</strong> command. This is a MIPSym-specific text file format, designed to be human-readable in a text editor; no hex editors required.</p><p>Please note that the <strong>'Load .obj'</strong> command assumes that you have a <code>.asm</code> file with the same filename in the same directory; it will load this file in the code editor.</p><p>As soon as you begin making changes to a source file that you have saved, MIPSym begins making timed backup saves of your code. You can set the amount of time between automatic backups, in seconds, with <strong>'Settings &gt; Set Automatic Backup Interval'</strong>. By default, the interval is 5 minutes, but you can set it as low as 1 second. You can turn the feature off by setting it to 0 seconds. Auto-saves are typically saved as the original filename with a tilde and a unique number after it. These files are usually cleaned up when MIPSym exits normally.</p><p>MIPSym does not crash often, but if it does, it will make an attempt to open the last file it auto-saved the next time you run it.</p><hr><p><br><br></p><h3 id=mipsym_find>Find and Replace</h3><p>You can access Find and Replace feature with <kbd><kbd>Ctrl</kbd>-<kbd>F</kbd></kbd>. This feature is meant to work much the same as it does in other text editors.</p><p>Regular expression matching: MIPSym allows you to find and replace using Qt's regular expression engine, QRegExp. You can find documentation on QRegExp at <a href=http://doc.qt.io/qt-5/qregexp.html#details>doc.qt.io</a>.</p><p>Regular expression capture groups: Regular expression engines allow you to reference capture groups in your replacement strings, often using <code>$1</code>, <code>$2</code>, <code>$3</code> and so on. Using QRegExp's string replacement tools, you will need to use <code>\1</code>, <code>\2</code>, <code>\3</code> and so on.</p><p>For example, if you had text that looked like this:</p><div class=codehilite><pre><span></span><code><span class=err>    Apples: add     $t0,$t1,$t2</span>
</code></pre></div><p>... and you had a search string that looked like this:</p><div class=codehilite><pre><span></span><code><span class=err>    (\w+):\s+add\s+(\$\w+),(\$\w+),(\$\w+)</span>
</code></pre></div><p>... and you had a replacement string that looked like this:</p><div class=codehilite><pre><span></span><code><span class=err>    # At label \1, we add \4 to \3 and store the result in \2.</span>
</code></pre></div><p>... you could find that string, hit <strong>'Replace'</strong>, and end up with this string:</p><div class=codehilite><pre><span></span><code><span class=err>    # At label Apples, we add $t2 to $t1 and store the result in $t0.</span>
</code></pre></div><hr><p><br><br></p><h3 id=mipsym_shortcuts>Code editor shortcut keys</h3><p>Most of the shortcut keys you might need are written in the menus, right next to the actions they trigger. For instance, under the <strong>'File'</strong> menu, the <strong>'Save'</strong> action has the text <kbd><kbd>Ctrl</kbd>-<kbd>S</kbd></kbd> next to it, or <kbd><kbd>&#8984;</kbd>-<kbd>S</kbd></kbd> on Mac.</p><p>There are a few keyboard shortcuts that are not on the menu; these are listed here:</p><div class=table-responsive><table class=table><tr><th>Shortcut Keys</th><th>Mac Equivalent</th><th>Action</th></tr><tr><td><kbd><kbd>Ctrl</kbd>-<kbd>/</kbd></kbd></td><td><kbd><kbd>&#8984;</kbd>-<kbd>/</kbd></kbd></td><td> Toggle-comment the line that the cursor is on.<br> If multiple lines are selected, every line selected will toggle-comment. </td></tr><tr><td><kbd>Tab</kbd></td><td><kbd>Tab</kbd></td><td> If any text is selected, the entire line (or block of lines) is indented with Tab characters. </td></tr><tr><td><kbd><kbd>Shift</kbd>-<kbd>Tab</kbd></kbd></td><td><kbd><kbd>Shift</kbd>-<kbd>Tab</kbd></kbd></td><td> If any text is selected, the entire line (or block of lines) is unindented. </td></tr><tr><td><kbd><kbd>Ctrl</kbd>-<kbd>MouseWheel+/-</kbd></kbd></td><td><kbd><kbd>&#8984;</kbd>-<kbd>MouseWheel+/-</kbd></kbd></td><td> Increase/decrease the size of the text in the IDE or the console. </td></tr></table></div><hr><p><br><br></p><h3 id=mipsym_panels>Panels</h3><p>The main window of the MIPSym IDE is divided into four panels:</p><ul><li>The Source Code Panel</li><li>The Register Panel</li><li>The Message Log Panel</li><li>The Memory Panel</li></ul><p>By default, only the Source Code panel is visible when you start up MIPSym. You can change this behavior under <strong>'Settings &gt; On Startup Show'</strong>.</p><p>By default, the Message Log panel will show itself whenever it receives a new message. You can prevent this behavior with <strong>'Settings &gt; Auto Show Messages on Arrival'</strong>. The Message Log is used to provide feedback any time MIPSym has something useful to tell you, but doesn't want to use an obtrusive dialog box to do so. It is usually best to leave this setting turned on, unless you are really worried about screen space. If you turn it off, the Message Log will still record messages, and you can access them at any time.</p><p>The Register and Memory panels can be accessed at any time, either by using the <strong>'View'</strong> menu, or by pulling on the vertical panel sliders at the right edge of the window. The panel sliders look like thick black lines, and your mouse cursor will change shape as you hover over them. If the Message Log is hidden, you can also access the Message Log using the horizontal panel slider at the bottom of the window.</p><hr><p><br><br></p><h3 id=mipsym_build>Building Code</h3><p>To build a program, click <strong>'Run &gt; Build <kbd>F8</kbd>'</strong>. The assembler should run, and the assembly results should show up in the Listing tab of the source code panel.</p><p>Your copy of MIPSym may contain alternate assemblers in a directory marked <code>asm</code>; if you wish to use one of them instead of the default assembler, you can do so with <strong>'Settings &gt; Set Assembler Path'</strong>. </p><p>Every time the assembler runs, the Message Log will display a note that contains the path to the assembler used and the version number. Considerable effort has been put into fuzz-testing assembler version 3.1; the developers believe that it is very unlikely that this assembler will crash. If the assembler does crash, the Message Log will contain a note with the assembler's return value, and possibly an explanation of what happened. If you are able to get assembler version 3.1 to crash, please alert the developers!</p><hr><p><br><br></p><h3 id=mipsym_run>Running Code</h3><p>You can step through your program one instruction at a time using the <strong>'Run &gt; Step <kbd>F10</kbd>'</strong> command.</p><p>You can run the program with <strong>'Run &gt; Run<kbd>F9</kbd>'</strong>; this will run your program until you hit a breakpoint, if any are set, or the program ends, or an exception occurs. This command will also save and build your program if you have unsaved changes.</p><p>You can pause the program at any time with <strong>'Run &gt; Step <kbd>F10</kbd>'</strong>. This will be useful if your program uses spin locks or long/infinite loops; your PC will otherwise waste lots of CPU cycles and battery to emulate these.</p><p>You will not be able to run your program if you did not define a <code>.text</code> or <code>.code</code> section, or did not specify a global <code>main:</code> label, even if it assembled correctly.</p><p>If you run a program, and it finishes, either via exception, <code>syscall $exit</code>, or by running off the end of the <code>.code</code> section, the simulator's PC and registers will all be in the same state so that you can examine them. If you want to re-run your program, hit <strong>'Run &gt; Reset <kbd><kbd>Shift</kbd>-<kbd>F8</kbd></kbd>'</strong> first, otherwise your program may begin in the wrong state.</p><hr><p><br><br></p><h3 id=mipsym_breakpoints>Breakpoints</h3><p>To set breakpoints, go to the listing section, highlight a memory address in the <code>.code</code>/<code>.text</code> section, and click <strong>'Breakpoint &gt; Add <kbd><kbd>Ctrl</kbd>-<kbd>B</kbd></kbd>'</strong>. This will pause your program at that address the next time you run it.</p><p>You can also add and remove breakpoints without highlighting memory addresses; you will see a dialog box that allows you to set the addresses manually.</p><hr><p><br><br></p><h3 id=mipsym_privacy>Privacy</h3><p>By default, MIPSym looks for updates at MIPSym.com every time it starts up. The Windows installation is capable of updating itself when MIPSym starts up, if you consent to the download (typically 11 MB). The Linux version should be capable of this soon as well.</p><p>However, the MIPSym team values your privacy and desire not to be tracked. You can turn off this feature in one of two ways:</p><ol><li>The <strong>'Settings &gt; Check for new version on launch'</strong> menu item. This item is checked by default, but you can un-check it the first time it runs, and MIPSym will stop contacting MIPSym.com in the future. This means that the first time MIPSym runs, it will contact MIPSym.com. If your preferences file is corrupted or deleted for some reason, it will also contact MIPSym.com until you uncheck this box.</li><li>The <code>-p</code> or <code>--private</code> command line option. If you launch MIPSym from the command line, or use a shortcut, you can add this option to your launch command, and MIPSym will never access MIPSym.com for any reason.</li></ol><hr><p><br><br></p><h2 id=mipsymcli>Using the MIPSymCLI Simulator</h2><hr><p><br><br></p><h3 id=mipsymcli_win>Windows</h3><p>After installation, there will be two shortcuts in your Start Menu, under a folder labelled MIPSym2. The MIPSym shortcut will run the GUI version of MIPSym; the MIPSymCLI shortcut will launch a Windows terminal with an environment set up to make it easier to run MIPSym from the command line.</p><p>This Windows terminal will start you out in your "home" directory. This is meant to encourage you not to try to modify files in the <code>C:\Program Files (x86)</code> directory. If you prefer to start in some other directory, please modify <code>C:\Program Files (x86)\MIPSym2\MipsymCliEnv.bat</code> accordingly.</p><p>If MIPSym is installed in the default location, there will be some example MIPS assembly files at <code>C:\Program Files (x86)\MIPSym2\example_code</code>. You may wish to copy these files to your home directory, using the <code>xcopy</code> command:</p><div class=codehilite><pre><span></span><code><span class=err>xcopy &quot;C:\Program Files (x86)\MIPSym2\example_code&quot; MIPS_workspace\</span>
</code></pre></div><p>The <code>xcopy</code> command will copy the whole directory into your home directory, in a new directory called <code>MIPS_workspace</code>.</p><p>You can move into the <code>MIPS_workspace</code> directory with the <code>cd</code> command:</p><div class=codehilite><pre><span></span><code><span class=err>cd MIPS_workspace</span>
</code></pre></div><p>Use the <code>dir</code> command to print a list of all the files in the current directory.</p><h4 id=mipsymcli_win_assembly>Assembling Programs</h4><p>Within this terminal, you can assemble a MIPS program in the current directory called <code>hello_world.asm</code> by entering:</p><div class=codehilite><pre><span></span><code><span class=c>%ASM% hello_world.asm</span>
</code></pre></div><p>If the assembler runs properly, it should produce an object file, in the same directory as the assembly file, with the <code>.obj</code> extension in place of the <code>.asm</code> extension. </p><p>You can check the assembler's return code with this command:</p><div class=codehilite><pre><span></span><code><span class=err>echo %errorlevel%</span>
</code></pre></div><p>The assembler referenced by <code>%ASM%</code> returns 0 when assembly succeeded and 1 when assembly failed. Any other return code means the assembler crashed.</p><p>Considerable effort has been put into fuzz-testing the assembler at <code>%ASM%</code>; the developers believe that it is very unlikely that this assembler will crash. If you are able to get this assembler (version 3.1, not 3.0) to crash, please alert the developers!</p><p>The assembler should have produced a few files when it assembled <code>hello_world.asm</code>:</p><ol><li>A log file, <code>hello_world.log</code>. This file stores some basic data about what assembler was used to assemble the program and what arguments were passed to the assembler. After you run the program in MIPSymCLI, some runtime statistics will be appended to this file.</li><li>An object file, <code>hello_world.obj</code>. This file represents the machine code that corresponds to the program you assembled. It isn't an actual machine code binary; it is instead stored as ASCII text so that you can read it easily.</li><li>A listing file, <code>hello_world.lst</code>. This file shows a direct mapping between the lines of assembly code in the <code>hello_world.asm</code> and the machine code written to <code>hello_world.obj</code>. It is meant to help you figure out what the assembler produced, and why.</li></ol><p>You can print any of these files to the terminal, using the <code>type</code> command:</p><div class=codehilite><pre><span></span><code><span class=err>type hello_world.lst</span>
</code></pre></div><p>If you prefer, you can also open the files in Notepad.exe:</p><div class=codehilite><pre><span></span><code><span class=err>notepad hello_world.lst</span>
</code></pre></div><p>There are two assemblers available in <code>C:\Program Files (x86)\MIPSym2\asm</code>. One is available via the <code>%ASM%</code> environment variable; this is the recommended assembler. </p><p>You may decide that you prefer to use the older version of the assembler, <code>C:\Program Files (x86)\MIPSym2\asm\assembler_builder.exe</code>. If you want to use this one, please note that you will need to use the <code>-W</code> flag, and that every assembly source file must be preceded by a <code>\</code>, otherwise the assembler will crash. For example, if you want to assemble <code>hello_world.asm</code> in the working directory, you would need to use this command:</p><div class=codehilite><pre><span></span><code><span class=err>&quot;C:\Program Files (x86)\MIPSym2\asm\assembler_builder.exe&quot; -W .\hello_world.asm</span>
</code></pre></div><p>Also, you should know that <code>assembler_builder.exe</code> produces a <code>hello_world.sig</code> file that contains no more than a few bytes. This file is used as a secondary form of communication with the GUI version of MIPSym, and it won't be very interesting to you. It is safe to delete this file. The newer <code>assembler.exe</code> produces <code>.sig</code> files as well, but the <code>%ASM%</code> variable includes a command line flag to suppress these files so that you will not see them.</p><h4 id=mipsymcli_win_run>Running Programs</h4><p>Within this terminal, you can run a MIPS program in the current directory called <code>hello_world.obj</code> by typing:</p><div class=codehilite><pre><span></span><code><span class=err>MIPSymCLI hello_world.obj</span>
</code></pre></div><p>A complete list of the command line flags that MIPSymCLI supports is available by typing:</p><div class=codehilite><pre><span></span><code><span class=err>MIPSymCLI -h</span>
</code></pre></div><p>If you need to quit running a program, but you don't want exit the terminal, just press <kbd><kbd>Ctrl</kbd>-<kbd>C</kbd></kbd> to return to the command prompt.</p><hr><p><br><br></p><h3 id=mipsymcli_linux>Linux</h3><p>The "MIPSym_x.xx.xxxx.tar.gz" archive includes the file "MIPSymCLI-x86_64.AppImage". This is an AppImage that you may relocate to any directory you wish. You will also find an assembler called "MIPSymAssembler" in the "asm" directory; please keep it in the same directory as "Mips1.adf". You may find it simplest to do something like this:</p><div class=codehilite><pre><span></span><code>$ tar -xvzf MIPSym_x.xx.xxxx.tar.gz -C ~
</code></pre></div><p>This will extract the archive into your home directory, in a new directory called MIPSym_x.xx.xxxx.</p><p>If you expect to use MIPSymCLI for any length of time, you will probably want to add some aliases to your dotfiles to make MIPSymCLI easier to use. The developers recommend that you add these lines to your <code>~/.bashrc</code> file (or <code>~/.zshrc</code>, or <code>~/.config/fish</code> file, depending on your preferred shell):</p><div class=codehilite><pre><span></span><code><span class=err>alias assembler=&#39;/home/$USER/MIPSym_x.xx.xxxx/asm/MIPSymAssembler -s&#39;</span>
<span class=err>alias MIPSymCLI=&#39;/home/$USER/MIPSym_x.xx.xxxx/MIPSymCLI-x86_64.AppImage&#39;</span>
</code></pre></div><p>The next time you open a terminal, you will be able to type <code>assembler</code> to run MIPSymAssembler with the <code>-s</code> flag, or <code>MIPSymCLI</code> to run the command-line version of MIPSym. For instance, if you had the file <code>hello_world.asm</code> in the working directory, you could run it like this:</p><div class=codehilite><pre><span></span><code>$ assembler hello_world.asm <span class=o>&amp;&amp;</span> MIPSymCLI hello_world.obj
</code></pre></div><p>If there are any errors in <code>hello_world.asm</code>, <code>assembler</code> emits a nonzero return code that prevents <code>MIPSymCLI</code> from running.</p><p>To make this process automatic, you may wish to interact with MIPSymCLI using a file watcher like <a href=https://github.com/inotify-tools/inotify-tools/wiki><code>inotify-wait</code></a>. This tool can be used to cause the <code>assembler</code> and <code>MIPSymCLI</code> emulator to run again any time you save changes to the <code>hello_world.asm</code> source.</p><hr><p><br><br></p><h3 id=mipsymcli_mac>Mac</h3><p>The <code>MIPSym.app</code> file in your <code>/Applications</code> directory is actually a directory that includes many files, including an assembler and the <code>MIPSymCLI</code> application. You can access these programs from your terminal by adding the following lines to your <code>~/.bashrc</code> file (or <code>~/.zshrc</code>, or <code>~/.config/fish</code> file, depending on your preferred shell):</p><div class=codehilite><pre><span></span><code><span class=err>alias assembler=&#39;/Applications/MIPSym.app/Contents/MacOS/asm/assembler -s&#39;</span>
<span class=err>alias MIPSymCLI=&#39;/Applications/MIPSym.app/Contents/MacOS/MIPSymCLI&#39;</span>
</code></pre></div><p>When you launch a new terminal session, you will be able to use the commands <code>assembler</code> and <code>MIPSymCLI</code> from any location, as long as <code>MIPSym.app</code> is in your <code>/Applications</code> directory. For instance, if you had the file <code>hello_world.asm</code> in the working directory, you could run it like this:</p><div class=codehilite><pre><span></span><code>$ assembler hello_world.asm <span class=o>&amp;&amp;</span> MIPSymCLI hello_world.obj
</code></pre></div><p>If there are any errors in <code>hello_world.asm</code>, <code>assembler</code> emits a nonzero return code that prevents <code>MIPSymCLI</code> from running.</p><hr><p><br><br></p><h3 id=mipsymcli_debug>Debugging Programs in MIPSymCLI</h3><p>You can put MIPSymCLI in interactive debug mode with this command:</p><div class=codehilite><pre><span></span><code><span class=err>MIPSymCLI -i hello_world.obj</span>
</code></pre></div><p>In debug mode, you can type <kbd>?</kbd> at any point to get a list of commands you can use, or <kbd>x</kbd> to exit the current mode.</p><p>When you enter debug mode, you will see a cryptic series of numbers and letters across the top of the screen. For example, you might see this:</p><div class=codehilite><pre><span></span><code><span class=err>Mem Addr  Contents Inst    Hex Args  Last Reg Diff</span>
<span class=err>00400000  340a0021 ori   0a,00,0021  $ra = 004000f0 &gt;&gt;</span>
</code></pre></div><p>The top line is meant to help you to understand the line below it. There are five columns of data here, followed by a <code>&gt;&gt;</code> symbol. The <code>&gt;&gt;</code> symbol is a prompt, meaning that MIPSymCLI expects you to type something.</p><p>The five columns of data are:</p><ol><li>The memory address that the Program Counter is currently pointed to. The <code>.text</code> section of MIPS programs usually begins at 0x400000, and that's where most MIPS programs start. If you wrote a MIPS program with a <code>main</code> label at some other location, and used the <code>.globl main</code> instruction to export that symbol, you would see some other memory address in this column. Note that all the numbers in this display are printed in hexadecimal; they are more compact and easier to read this way.</li><li>The 32-bit integer stored at this memory address. Since we are in the <code>.text</code> section, this integer is most likely machine code for a MIPS instruction. The MIPSym simulator will interpret this number as if it were a MIPS instruction. Hopefully, the author of this program kept all the program's data in the <code>.data</code> section, and out of the <code>.text</code> section, so the MIPSym simulator doesn't try to interpret data as MIPS instructions!</li><li>The assembly instruction that MIPSym will try to run when it sees the 32-bit integer at this address.</li><li>The arguments to the MIPS instruction at this address, written in hexadecimal.</li><li>The integer register that changed during the previous instruction. If no register has changed, this column will point to <code>$ra</code> by default. This column also shows you the value held in that register.</li></ol><p>You can step through the program one instruction at a time by pressing the <kbd>i</kbd> or <kbd>F10</kbd> key.</p><p>At any point, you can set or clear breakpoints, view the contents of the registers, or view and edit the contents of memory. Press <kbd>?</kbd> to see a complete list of commands.</p><h4 id=mipsymcli_win_memory>The Memory Viewer/Editor</h4><p>From debug mode, you can enter the memory editor by pressing <kbd>m</kbd>. In this mode, the prompt turns into a <code>&gt;&gt;&gt;</code> to denote that you are in the memory editor, and not in debug mode. From this point, you can press <kbd>x</kbd> to get back to debug mode.</p><p>In the memory editor, you can press <kbd>d</kbd> to display and edit memory. Once you have pressed <kbd>d</kbd>, you will see something like this:</p><div class=codehilite><pre><span></span><code><span class=mh>0x10010000</span><span class=o>:</span> <span class=mi>20202020</span> <span class=o>&gt;</span>
</code></pre></div><p>The first number is the hex address of the current location in memory, 0x10010000, which happens to be the beginning of the <code>.data</code> section. The second number is the value at that address: a series of 0x20's. In this program, the beginning of the data section is filled by a string of ASCII space characters. The last thing on this line is the data-entry prompt, a <code>&gt;</code> symbol.</p><p>If you were to enter a 32-bit number here, the first four bytes at address 0x10010000 would be replaced by the number you entered.</p><p>If you were to press the up or down arrow keys, the memory address would increment/decrement by 4, and the value at the new address would be displayed in place of the previous value.</p><p>If you entered nothing at all, and just pressed the Enter key, the next memory address and memory value would appear on the next line. This is a good way to view a large block of memory at once: just press Enter over and over again, and the whole block will print out four bytes at a time.</p><p>Press <kbd>x</kbd> to leave data-entry mode and go back to the memory editor. Note that the prompt changes back to a <code>&gt;&gt;&gt;</code>.</p><p>There are three things you can change in the memory editor:</p><ol><li>The current memory address (press <kbd>a</kbd> to modify). It could take a long time to press the arrow keys to reach the address you want to display or modify; this will get you there directly.</li><li>Size mode (press <kbd>s</kbd> to modify). If you are modifying integers, you can choose between modifying 1 byte, 2 bytes, 4 bytes, or 8 bytes at a time.</li><li>Entry mode (press <kbd>e</kbd> to modify). This allows you to change the way that data is displayed and entered in data-entry mode. You can use this to display blocks of memory as floating-point data, string data, integers, or as disassembled MIPS machine code.</li></ol><p>You can press <kbd>?</kbd> at any time in the memory editor to see what address, size mode, and entry mode are currently selected.</p><hr><p><br><br></p><h2 id=differences>Differences between MIPSym's assembler and other MIPS assemblers (SPIM, GCC etc)</h2><hr><p><br><br></p><h3 id=delay>Delay slot</h3><p>The MIPS R2000 processor executes every instruction placed directly after a branch instruction before it executes the branch. This is called the delay slot. By default, the MIPSym simulator disables this behavior. The delay slot behavior may be restored by using the <code>.delay</code> pseudocode at the top of any program. Programs written for SPIM must be modified by adding this pseudocode before all other lines:</p><div class=codehilite><pre><span></span><code><span class=err>    .delay</span>
</code></pre></div><p>The following blocks of code illustrate how the delay slot can alter the behavior of your programs.</p><div class=codehilite><pre><span></span><code><span class=o>#</span> <span class=k>Default</span> <span class=n>behavior</span><span class=p>:</span> <span class=n>the</span> <span class=s1>&#39;.delay&#39;</span> <span class=n>pseudocode</span> <span class=k>is</span> <span class=n>absent</span>
    <span class=n>li</span>      <span class=err>$</span><span class=n>a0</span><span class=p>,</span><span class=mi>5</span>           <span class=o>#</span> <span class=n>put</span> <span class=n>a</span> <span class=mi>5</span> <span class=k>in</span> <span class=err>$</span><span class=n>a0</span>
    <span class=n>jal</span>     <span class=n>some_function</span>   <span class=o>#</span> <span class=n>jump</span> <span class=k>to</span> <span class=n>some_function</span><span class=p>,</span> <span class=k>with</span> <span class=n>argument</span> <span class=err>$</span><span class=n>a0</span> <span class=o>==</span> <span class=mi>5</span>
    <span class=n>addi</span>    <span class=err>$</span><span class=n>a0</span><span class=p>,</span><span class=err>$</span><span class=n>a0</span><span class=p>,</span><span class=mi>8</span>       <span class=o>#</span> <span class=k>when</span> <span class=n>some_function</span> <span class=k>returns</span><span class=p>,</span> <span class=k>set</span> <span class=err>$</span><span class=n>a0</span> <span class=o>=</span> <span class=mi>5</span> <span class=o>+</span> <span class=mi>8</span>


<span class=o>#</span> <span class=n>Delay</span> <span class=n>slot</span> <span class=k>mode</span><span class=p>:</span> <span class=n>the</span> <span class=s1>&#39;.delay&#39;</span> <span class=n>pseudocode</span> <span class=n>appeared</span> <span class=k>at</span> <span class=n>the</span> <span class=n>top</span> <span class=k>of</span> <span class=n>the</span> <span class=n>program</span>
    <span class=n>li</span>      <span class=err>$</span><span class=n>a0</span><span class=p>,</span><span class=mi>5</span>           <span class=o>#</span> <span class=n>put</span> <span class=n>a</span> <span class=mi>5</span> <span class=k>in</span> <span class=err>$</span><span class=n>a0</span>
    <span class=n>jal</span>     <span class=n>some_function</span>   <span class=o>#</span> <span class=n>jump</span> <span class=k>to</span> <span class=n>some_function</span><span class=p>,</span> <span class=k>with</span> <span class=n>argument</span> <span class=err>$</span><span class=n>a0</span> <span class=o>==</span> <span class=mi>13</span>
    <span class=n>addi</span>    <span class=err>$</span><span class=n>a0</span><span class=p>,</span><span class=err>$</span><span class=n>a0</span><span class=p>,</span><span class=mi>8</span>       <span class=o>#</span> <span class=n>delay</span> <span class=n>slot</span><span class=p>:</span> <span class=n>this</span> <span class=n>instruction</span> <span class=n>runs</span> <span class=k>before</span> <span class=n>some_function</span>
</code></pre></div><p>Please do not attempt to use a macro in the delay slot: the first line of the macro will be executed before a branch, but subsequent instructions will not! </p><hr><p><br><br></p><h3 id=fields>Fields</h3><p>The MIPSym assembler reads each line of assembly code as a series of three fields, separated by whitespace:</p><ol><li>the label field</li><li>the opcode/pseudo-op field</li><li>the arguments field</li></ol><p>This has two very important consequences that are common pain points for new users of MIPSym:</p><ol><li><p>Lines of code without a label must be indented</p><div class=codehilite><pre><span></span><code><span class=err># Valid code:</span>
<span class=err>    add     $t0,$t0,$t0</span>
<span class=err># Not valid:</span>
<span class=err>add     $t0,$t0,$t0</span>
</code></pre></div></li><li><p>Whitespace is not allowed between arguments or within mathematical expressions.</p><div class=codehilite><pre><span></span><code><span class=err># Not valid:</span>
<span class=err>    add     $t0, $t0, $t0</span>
<span class=err># Valid code:</span>
<span class=err>    addi    $t0,$t0,1+2+3      # adds 6 to $t0</span>
<span class=err># Valid, but not what you meant:</span>
<span class=err>    addi    $t0,$t0,1 + 2 + 3  # adds 1 to $t0, not 6</span>
</code></pre></div></li></ol><hr><p><br><br></p><h3 id=expressions>Expressions</h3><p>Mathematical expressions are evaluated from left to right, with no regard to operator precedence. Parentheses are not allowed.</p><div class=codehilite><pre><span></span><code><span class=err># Valid code:</span>
<span class=err>    addi  $t0,$0,1+2*3     # stores (1+2)*3, or 9, in $t0</span>
<span class=err># Not valid:</span>
<span class=err>    addi  $t0,$0,1+(2*3)   # does not assemble</span>
</code></pre></div><p>Note that the MIPSym assembler evaluates each value in an expression as an integer, not as floating point data.</p><div class=codehilite><pre><span></span><code><span class=err># Valid code:</span>
<span class=err>    addi  $t0,$0,3.9+3.9   # stores 3+3, or 6, in $t0</span>
</code></pre></div><hr><p><br><br></p><h3 id=aliasing>Aliasing and Constant Values</h3><p>Like SPIM, you can use the assignment operator to assign a constant value to an identifier. This feature is meant to allow you to write readable code that isn't full of magic numbers. For example:</p><div class=codehilite><pre><span></span><code><span class=err># Valid code:</span>
<span class=err>num_days_in_year = 365</span>
<span class=err>num_days_in_leap_year = num_days_in_year+1</span>
<span class=err>    li    $t0,num_days_in_leap_year    # store 366 in register $t0</span>
</code></pre></div><p>Don't forget to use whitespace before and after the <code>=</code> operator:</p><div class=codehilite><pre><span></span><code><span class=n>x</span><span class=o>=</span><span class=mi>7</span>     <span class=c1># fail; the `=` is interpreted as part of a label</span>
<span class=n>x</span> <span class=o>=</span><span class=mi>7</span>    <span class=c1># fail; the `=7` is interpreted as an undefined opcode</span>
<span class=n>x</span><span class=o>=</span> <span class=mi>7</span>    <span class=c1># fail; the `x=` is interpreted as part of a label</span>
<span class=n>x</span> <span class=o>=</span> <span class=mi>7</span>   <span class=c1># OK: `7` is now assigned to `x`</span>
</code></pre></div><p>This feature is often used with labels as well:</p><div class=codehilite><pre><span></span><code><span class=o>#</span> <span class=k>Valid</span> <span class=n>code</span><span class=p>:</span>
<span class=n>my_string</span><span class=p>:</span>  <span class=p>.</span><span class=n>asciiz</span>   <span class=ss>&quot;I am the best programmer in my seat!&quot;</span>
<span class=n>end_my_string</span><span class=p>:</span>

<span class=o>#</span> <span class=n>assigns</span> <span class=n>the</span> <span class=k>length</span> <span class=k>of</span> <span class=n>the</span> <span class=n>string</span><span class=p>,</span> <span class=n>plus</span> <span class=mi>1</span> <span class=k>for</span> <span class=n>the</span> <span class=k>null</span> <span class=n>terminal</span>
<span class=n>my_string_length</span> <span class=o>=</span> <span class=n>end_my_string</span><span class=o>-</span><span class=n>my_string</span>
</code></pre></div><p>You may also assign identifiers to registers, as long as your identifier begins with a '$':</p><div class=codehilite><pre><span></span><code><span class=err>first_year_of_MIPS = 1986</span>
<span class=err>$year = $t0</span>
<span class=err>    li    $year,first_year_of_MIPS    # load 1986 into $t0</span>
</code></pre></div><p>The value attached to the identifier is assigned during assembly, and cannot be reassigned during runtime. </p><p>The MIPSym assembler stores these values as integers. If you attempt to assign a floating point value to an identifier, the value will be truncated.</p><hr><p><br><br></p><h3 id=repeats>Repeating Data</h3><p>The MIPSym assembler provides a means of repeating sections of data, using the ':' operator. </p><p>Suppose you wanted to write a null-terminated string, consisting of 5 copies of the letter 'A'. You could (and probably should) use the <code>.asciiz</code> pseudocode, but let's see what happens when we use the <code>.byte</code> pseudocode.</p><div class=codehilite><pre><span></span><code><span class=c>five_As:    .byte   65:5      # write 5 &#39;A&#39;s</span>
<span class=c>            .byte   0         # null-terminal</span>
</code></pre></div><p>The result is a printable string that looks like: <code>"AAAAA\0"</code></p><p>Please note that the MIPSym assembler will repeat all of the data on the line, not just the value that precedes the ':' operator. If you didn't know that, you might be tempted to tack the 0 onto the end of the first line, like this:</p><div class=codehilite><pre><span></span><code><span class=c>five_A0:    .byte   65:5,0</span>
</code></pre></div><p>This will not yield the same string; instead, it will result in 5 alternating A's and 0's, like this: <code>"A\0A\0A\0A\0"</code></p><hr><p><br><br></p><h3 id=char_literals>Character literals</h3><p>MIPSym does not currently support unicode. It interprets all ASCII characters as being on <a href=https://en.wikipedia.org/wiki/Code_page_437>IBM code page 437</a>. This was done to make it easy for students to develop text-mode games, using the box-drawing characters in the range 0xb0 to 0xdf. All characters on this code page have a uniform width and height, which makes ASCII art simple to draw. This property is not true of some unicode characters, no matter what font you're using. Each character is exactly 8 bytes, which makes it easy to reason about the positioning of each character in a buffer, as opposed to the variable-length characters in <a href=https://en.wikipedia.org/wiki/UTF-8>utf-8</a>.</p><p>You may represent character literals in code, preceded by a single quote:</p><div class=codehilite><pre><span></span><code><span class=err>    li      $a0,&#39;A      # load 65, the ASCII value for &#39;A&#39;, in register $a0</span>
<span class=err>    li      $a0,&#39;\n     # load 10, the ASCII value for newline, in $a0</span>
<span class=err>    li      $a0,&#39;\&#39;     # load 39, the value for single quote, in $a0</span>
<span class=err>    li      $a0,&#39;\\     # load 92, the value for backslash, in $a0</span>
</code></pre></div><p>You may find it useful to run the program 'page2ASCII.asm', included in the 'examples' directory. This program prints every character that MIPSym is capable of printing, alongside the corresponding ASCII values.</p><p>The following escape codes are supported by the assembler:</p><div class=table-responsive><table class=table><tr><th>Escape code</th><th>ASCII value</th><th>Name</th></tr><tr><td>\a</td><td>7</td><td>Bell</td></tr><tr><td>\b</td><td>8</td><td>Backspace</td></tr><tr><td>\t</td><td>9</td><td>Horizontal Tab</td></tr><tr><td>\n</td><td>10</td><td>Newline</td></tr><tr><td>\v</td><td>11</td><td>Vertical tab</td></tr><tr><td>\f</td><td>12</td><td>Form feed</td></tr><tr><td>\r</td><td>13</td><td>Carriage return</td></tr><tr><td>\xFF</td><td>255</td><td>Hex number: any number between 0 and 255</td></tr><tr><td>\255</td><td>255</td><td>Decimal number: any number between 0 and 255</td></tr><tr><td>\o377</td><td>255</td><td>Octal number: any number between 0 and 255</td></tr><tr><td>\B11111111</td><td>255</td><td>Binary number: any number between 0 and 255</td></tr></table></div><p>If you need to print '&#8962;' in a string or character literal, you can use the escaped hex value:</p><div class=codehilite><pre><span></span><code><span class=err>    .data</span>
<span class=err>    .ascii  &quot;\x7F&quot;</span>
<span class=err>    .byte   &#39;\x7F</span>
<span class=err>    .text</span>
<span class=err>    li      $a0,&#39;\x7F</span>
</code></pre></div><p>Please note that you cannot include raw control characters (ASCII values 0-31 and 127) in string literals or character literals. The assembler will convert these characters to blank space characters, aka ASCII <code>0x20</code>. Indiscriminate use of these characters can have unpredictable effects, depending on which platform you are using. For example, on Windows, the character <code>0x1a</code>, aka the 'substitute' character, causes a file IO error when a file is read in text mode. This is not a bug; it is a misuse of the text file format.</p><p>If you plan on using text editors other than MIPSym to edit assembly files, please only use characters within the range [32-126] inclusive. Most modern editors expect that text files are encoded in some form of Unicode, and characters outside this range will either cause IO errors or be interpreted as malformed UTF-8 text.</p><p>If you absolutely must use UTF-8 text in your programs, you are encouraged to use escape sequences to form UTF-8 characters. For example, to write the UTF-8 form of the character '&#8962;', you would need to write this sequence of bytes: <code>0xE2 0x8C 0x82</code> To write this as an ASCII string, you could use:</p><div class=codehilite><pre><span></span><code><span class=c>house:  .asciiz   &quot;\xE2\x8C\x82&quot;</span>
</code></pre></div><p>or:</p><div class=codehilite><pre><span></span><code><span class=c>house:  .byte     &#39;\xE2,&#39;\x8C,&#39;\x82,0</span>
</code></pre></div><p>You can print this string as a UTF-8 character if you are using MIPSymCLI in ANSI Mode. To do this, pass the <code>-a</code> flag to MIPSymCLI at the command line:</p><div class=codehilite><pre><span></span><code>$ MIPSymCLI -a your_utf8_program.obj
</code></pre></div><hr><p><br><br></p><h3 id=keywords>Keywords/Reserved Words</h3><p>Unlike SPIM and GCC assembler, MIPSym does not consider pseudocodes, opcodes, or registers to be reserved words. This means that you may use labels with the same names as opcodes and pseudocodes. The assembler can decide whether an identifier should be interpreted as a label or an opcode/pseudocode based on which field it is in.</p><div class=codehilite><pre><span></span><code><span class=c1># Valid code (antipattern):</span>

<span class=c1># define a label (addi), and store part of the address of that label in $t0</span>
<span class=nl>addi:</span>   <span class=nf>addi</span>    <span class=no>$t0</span><span class=p>,</span><span class=no>$0</span><span class=p>,</span><span class=no>addi</span>

<span class=c1># define a label (.data), and store the address of that label in $s0</span>
<span class=nl>.data:</span>  <span class=nf>li</span>      <span class=no>$s0</span><span class=p>,.</span><span class=no>data</span>

<span class=c1># define a label (.byte), and write 3 copies of the low 8 bits of that label</span>
<span class=nl>.byte:</span>  <span class=na>.byte</span>   <span class=no>.byte</span><span class=p>,.</span><span class=no>byte</span><span class=p>,.</span><span class=no>byte</span>
</code></pre></div><p><strong>WARNING</strong>: Do not write code like this without a very good reason for doing so! Redefining opcodes and pseudocodes can be fun, but it makes your code very hard to read!</p><p>If you want to copy this code into MIPSym, make sure it isn't indented before you try to build it. Notice that the code highlighter can't figure out that addi, .data, and .byte are being used as labels and not opcodes or pseudocodes. The highlighter is meant to run fast and to help make your code more readable, not to parse nonsense like this.</p><hr><p><br><br></p><h3 id=other>Syscalls, Register Names, Pseudocodes, and Macros</h3><p>MIPSym aims to provide good compatibility with SPIM, but some differences exist. MIPSym adds several <a href=#mipsym_syscalls>syscalls that do not exist in SPIM</a>, a few <a href=#fp_math_opcodes>nonstandard floating-point instructions</a>, and many convenient <a href=#macros>macros</a> that do not exist in SPIM or GCC. Specific differences are discussed in the appropriate section of the <a href=#reference>Quick Reference Guide</a>.</p><hr><p><br><br></p><h1 id=reference>Quick Reference Guide</h1><p>This section presents a listing of all pseudocodes (assembler directives), syscalls, registers, opcodes, and macros. Please note that all the information presented here is available within MIPSym's code editor, in the form of tooltips. Within the editor, just hover your mouse over a term that you are interested in, and the documentation for that term will pop up.</p><hr><p><br><br></p><h2 id=pseudos>Pseudocodes (aka assembler directives)</h2><p>MIPSym handles a subset of the pseudocodes that SPIM and the GCC assembler support. A full listing of these is provided here.</p><div class=table-responsive><table class=table><thead><tr><th>Pseudo Name</th><th>Arguments</th><th>Comment</th></tr></thead><tbody><tr><td>.align</td><td>n</td><td>Increment the location counter to make the n low order bits of the counter 0. <br> If n is zero, turns off auto alignment.</td></tr><tr><td>.ascii</td><td>string delimited by double quotes</td><td>Writes a string without marking an endpoint</td></tr><tr><td>.asciiz</td><td>string delimited by double quotes</td><td>Writes a null-terminated string</td></tr><tr><td>.byte</td><td>comma-separated ints or expressions</td><td>Writes data in 8-bit chunks</td></tr><tr><td>.code</td><td>optional address</td><td>Enters the section of the program that contains code. <br> Alias for '.text'</td></tr><tr><td>.data</td><td>optional address</td><td>Enters the section of the program that contains data</td></tr><tr><td>.delay</td><td>no args</td><td>Turns on branch-delay mode: the simulator will execute the first instruction following a branch instruction before taking the branch. <br> The assembler will use special versions of macros containing branches. <br> Should be the first line of a program.</td></tr><tr><td>.double</td><td>comma-separated doubles</td><td>Writes 64-bit floating point datapoints</td></tr><tr><td>.endr</td><td>no args</td><td>Not implemented! <br> Ends the repeated section begun by .repeat.</td></tr><tr><td>.extern</td><td>name of variable, size of variable</td><td>Defines a global symbol offset from the $gp, whose size is n bytes.</td></tr><tr><td>.external</td><td>name of variable</td><td>Declares that a symbol is externally visible so it can be referenced by other files via $gp</td></tr><tr><td>.float</td><td>comma-separated floats</td><td>Writes 32-bit floating point datapoints</td></tr><tr><td>.global</td><td>name of variable, size of variable</td><td>Defines a global symbol whose size is n bytes.</td></tr><tr><td>.globl</td><td>name of variable</td><td>Declares that a symbol is externally visible so it can be referenced by other files via $gp</td></tr><tr><td>.half</td><td>comma-separated ints</td><td>Writes data in 16-bit chunks</td></tr><tr><td>.kcode</td><td>optional address</td><td>Enters the section of the program that contains kernel code</td></tr><tr><td>.kdata</td><td>optional address</td><td>Enters the section of the program that contains data, accessible by the kernel</td></tr><tr><td>.ktext</td><td>optional address</td><td>Enters the section of the program that contains kernel code</td></tr><tr><td>.repeat</td><td>number of repetitions</td><td>Not implemented! <br> Repeats all instructions or data between the .repeat and .endr directives.</td></tr><tr><td>.sdata</td><td>optional address</td><td>Enters the small data section; <br> accessible via $gp using 16-bit addressing</td></tr><tr><td>.space</td><td>number of bytes</td><td>Adds n bytes of empty space</td></tr><tr><td>.struct</td><td>optional argument: defines inheritance from another struct</td><td>Defines a data structure type as the label. <br> The value of the label is the length of the structure in bytes. <br> Subsequent items are included in the structure until the next segment directive or another struct. <br> The optional 'symbol' argument defines inheritance from another struct.</td></tr><tr><td>.text</td><td>optional address</td><td>Enters the section of the program that contains code.</td></tr><tr><td>.word</td><td>comma-separated ints</td><td>Writes data in 32-bit chunks</td></tr></tbody></table></div><hr><p><br><br></p><h2 id=syscalls>Syscalls</h2><p>Like SPIM, MIPSym employs syscalls to handle operations that would otherwise be very tedious to write. MIPSym provides compatibility with all of SPIM's syscalls and allows you to call them the same way. MIPSym also provides its own syntax for syscalls, which is more concise and readable.</p><div class=codehilite><pre><span></span><code><span class=err># Valid code (SPIM syntax):</span>
<span class=err>    li      $v0,5     # 5 denotes the read_int syscall</span>
<span class=err>    syscall           # runs the syscall in $v0</span>
<span class=err># Valid code (MIPSym syntax):</span>
<span class=err>    syscall $read_int # runs the read_int syscall directly</span>
</code></pre></div><p>MIPSym supports all of the syscalls that SPIM supports. A full listing of these syscalls is provided here.</p><p><br><br></p><h3 id=spim_syscalls>SPIM-Compatible Syscalls</h3><div class=table-responsive><table class=table><thead><tr><th>Syscall Name</th><th>Arguments</th><th>Comment</th></tr></thead><tbody><tr><td>$close</td><td>$a0 holds file handle</td><td>Closes file</td></tr><tr><td>$exit</td><td>no args</td><td>ends program</td></tr><tr><td>$exit2</td><td>$a0 holds return value</td><td>ends program, returning the value in $a0</td></tr><tr><td>$malloc</td><td>$a0 holds number of bytes requested.</td><td>Returns address in $v0</td></tr><tr><td>$open</td><td>$a0 holds address of filename, <br> $a1 holds flags, <br> $a2 holds mode.</td><td>Returns file handle in $v0</td></tr><tr><td>$print_char</td><td>$a0 holds char to print</td><td>prints char in $a0</td></tr><tr><td>$print_double</td><td>$a0 holds double to print</td><td>prints double in $f12</td></tr><tr><td>$print_float</td><td>$a0 holds float to print</td><td>prints float in $f12</td></tr><tr><td>$print_int</td><td>$a0 holds int to print</td><td>prints integer in $a0</td></tr><tr><td>$print_string</td><td>$a0 holds string to print</td><td>prints string in memory at $a0</td></tr><tr><td>$read</td><td>$a0 holds file handle, <br> $a1 holds buffer address, <br> $a2 holds buffer length.</td><td>Returns number of bytes read in $v0</td></tr><tr><td>$read_char</td><td>no args</td><td>returns char from console input in $v0</td></tr><tr><td>$read_double</td><td>no args</td><td>returns double from console input in $f0</td></tr><tr><td>$read_float</td><td>no args</td><td>returns float from console input in $f0</td></tr><tr><td>$read_int</td><td>no args</td><td>returns integer from console input in $v0</td></tr><tr><td>$read_string</td><td>$a0 holds address of buffer in memory, <br> $a1 holds buffer length.</td><td>Returns string length in $v0</td></tr><tr><td>$write</td><td>$a0 holds file handle, <br> $a1 holds buffer address, <br> $a2 holds buffer length.</td><td>Returns number of bytes written in $v0</td></tr></tbody></table></div><p><br></p><h3 id=mipsym_syscalls>MIPSym-Specific Syscalls</h3><div class=table-responsive><table class=table><thead><tr><th>Syscall Name</th><th>Arguments</th><th>Comment</th></tr></thead><tbody><tr><td>$IO_read</td><td>$a0 holds address, <br> $a1 holds number of bytes {1,2,4}.</td><td>Returns data in $v0</td></tr><tr><td>$IO_write</td><td>$a0 holds address, <br> $a1 holds number of bytes {1,2,4}, <br> $a2 holds data to write</td><td>writes data to hardware</td></tr><tr><td>$callback</td><td>$a0 holds address of interrupt callback routine, <br> $a1 holds interrupt number [2-7]</td><td>assigns callback function</td></tr><tr><td>$close_cons</td><td>$a0 holds id of console to close</td><td>Unimplemented</td></tr><tr><td>$date_time</td><td>no args</td><td>Returns local datetime, spanned across $v0-$v1. <br> Bits from high($v1) to low($v0): 23 bits=year, 4=month, 5=day, 5=hour, 6=min, 6=sec, 10=mil, 5=local timezone offset from UTC</td></tr><tr><td>$flush_print</td><td>no args</td><td>transfers the screen buffer to console, avoiding flicker.</td></tr><tr><td>$free</td><td>$a0 holds address of buffer to free</td><td>Frees memory at address</td></tr><tr><td>$open_cons</td><td>$a0 is console height, <br> $a1 is console width</td><td>Unimplemented</td></tr><tr><td>$position</td><td>$a0 holds file handle, <br> $a1 holds number of bytes from $a2, <br> $a2 = start / current / end of file: 0/1/2</td><td>Returns absolute position in $v0</td></tr><tr><td>$random</td><td>no args</td><td>Copies the RANDOM register to $v0. <br> RANDOM counts down with each instruction run since the program began. <br> Commonly used to seed an RNG algorithm after waiting for user input.</td></tr><tr><td>$select_cons</td><td>$a0 holds id of console to select</td><td>Unimplemented</td></tr><tr><td>$spool_print</td><td>no args</td><td>holds outputs to screen buffer until $flush_print</td></tr><tr><td>$string2double</td><td>$a0 holds address of input string</td><td>Returns double in $f0 converted from string in memory at $a0</td></tr><tr><td>$utc_date_time</td><td>no args</td><td>Returns datetime in Universal Coordinated Time, spanned across $v0-$v1. <br> Bits from high($v1) to low($v0): 23 bits=year, 4=month, 5=day, 5=hour, 6=min, 6=sec, 10=mil, 5=local timezone offset from UTC</td></tr><tr><td>$utc_millis</td><td>no args</td><td>Returns the number of milliseconds since the Unix Epoch, in Universal Coordinated Time, spanned across $v0-$v1</td></tr><tr><td>$xy</td><td>$a0 holds cursor column [0-79], <br> $a1 holds cursor row [0-24].</td><td>Positions Cursor on the console. <br> Returns character at ($a0,$a1) in $v0.</td></tr></tbody></table></div><hr><p><br><br></p><h2 id=registers>Register Names</h2><p>The GCC assembler refers to registers only by their numeric values, $0-$31. By default MIPSym does not allow the use of $0-$31 as register names, unless you define the symbols $0-$31 in your own code (see <a href=#aliasing>aliasing</a>) or add them to MIPSym/asm/mips1.adf. For example, in your own code you could type the following (unindented):</p><div class=codehilite><pre><span></span><code><span class=err>$31 = 31</span>
</code></pre></div><p>MIPSym uses the register names enumerated below. SPIM allows the use of either type of register name. Code written for SPIM or GCC must be adjusted accordingly before the MIPSym assembler will be able to assemble it. </p><p><br></p><h3 id=int_registers>Integer Registers</h3><div class=table-responsive><table class=table><tr><th>GCC name</th><th>MIPSym name</th><th>Purpose</th></tr><tr><td>$0</td><td>$zero $0</td><td>Always 0</td></tr><tr><td>$1</td><td>$at</td><td>Assembler Temporary</td></tr><tr><td>$2-$3</td><td>$v0-$v1</td><td>Function return values/ syscall choice</td></tr><tr><td>$4-$7</td><td>$a0-$a3</td><td>Function arguments</td></tr><tr><td>$8-$15</td><td>$t0-$t7</td><td>Temporary storage, not saved</td></tr><tr><td>$16-$23</td><td>$s0-$s7</td><td>Saved storage, not overwritten</td></tr><tr><td>$24-$25</td><td>$t8-$t9</td><td>Temporary storage, not saved</td></tr><tr><td>$26-$27</td><td>$k0-$k1</td><td>For kernel use only</td></tr><tr><td>$28</td><td>$gp</td><td>Global pointer</td></tr><tr><td>$29</td><td>$sp</td><td>Stack pointer</td></tr><tr><td>$30</td><td>$fp</td><td>Frame pointer</td></tr><tr><td>$31</td><td>$ra</td><td>Return address</td></tr></table></div><p><br></p><h3 id=flt_registers>Floating Point Registers</h3><div class=table-responsive><table class=table><tr><th>GCC name</th><th>MIPSym name</th><th>Purpose</th></tr><tr><td>$0-$31</td><td>$f0-$f31</td><td>Floating point registers in coprocessor 1</td></tr></table></div><p><br></p><h3 id=cp0_registers>Coprocessor 0 Control Registers</h3><div class=table-responsive><table class=table><thead><tr><th>GCC Name</th><th>MIPSym Name</th><th>Register Type</th></tr></thead><tbody><tr><td>$0</td><td>$INDEX</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$1</td><td>$RANDOM</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$10</td><td>$ENTRY_HI</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$11</td><td>$COMPARE</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$12</td><td>$STATUS</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$13</td><td>$CAUSE</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$14</td><td>$EPC</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$15</td><td>$PRID</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$16</td><td>$CONFIG</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$17</td><td>$LLADDR</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$18</td><td>$WATCH_LO</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$19</td><td>$WATCH_HI</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$2</td><td>$ENTRY_LO</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$26</td><td>$ECC</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$27</td><td>$CACHE_ERR</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$28</td><td>$TAG_LO</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$29</td><td>$TAG_HI</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$3</td><td>$ENTRY_LO1</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$30</td><td>$ERROR_EPC</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$4</td><td>$CONTEXT</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$5</td><td>$PAGEMASK</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$6</td><td>$WIRED</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$7</td><td>$ERROR</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$8</td><td>$BAD_V_ADDR</td><td>Coprocessor 0 Control Register</td></tr><tr><td>$9</td><td>$COUNT</td><td>Coprocessor 0 Control Register</td></tr></tbody></table></div><p><br></p><h3 id=cp1_registers>Coprocessor 1 Control Registers</h3><div class=table-responsive><table class=table><thead><tr><th>GCC Name</th><th>MIPSym Name</th><th>Register Type</th></tr></thead><tbody><tr><td>$0</td><td>$FCR0</td><td>Coprocessor 1 Control Register</td></tr><tr><td>$31</td><td>$FCR31</td><td>Coprocessor 1 Control Register</td></tr></tbody></table></div><hr><p><br><br></p><h2 id=opcodes>Opcodes and Macros</h2><hr><p><br><br></p><h3 id=table_explanation>How to read these tables</h3><p>These tables present each opcode or macro in the R2000 instruction set, along with its required arguments, and in most cases a brief comment to describe what the instruction does.</p><p>In general, the destination argument comes first in an argument list, and the source operand(s) come afterwards. However, five of instructions have this order backwards: mtc0, sb, sh, sw, swl, and swr. These instructions have comments marked in bold to warn you of this.</p><p>There are several kinds of arguments:</p><ul><li>imm: This stands for 'immediate value'. This can be any constant integer value. It can be a number, an <a href=#aliasing>alias</a>, or a <a href=#expressions>mathematical expression</a>.</li><li>label: This is exactly the same as an 'immediate value'. The assembler sees both as integers, and it doesn't care whether it's really a label, or just some number you made up. The distinction is meant to show you how the instructions are meant to be used, and to help other programmers to understand your code.</li><li>rd/rs/rt: These symbols denote integer <a href=#int_registers>registers</a>. Usually, the 'd' stands for 'destination' and the 's' stands for 'source.' In the majority of the instructions (r-form instructions), the 't' stands for 'second source' (t comes right after s in the alphabet). Most of the remaining instructions (i-form instructions) use 'rt' as the destination register instead, and rd is unused.</li><li>fd/fs/ft: These symbols denote single floating point registers ($f0-31). The same general rule for d, s, and t that applies to the integer registers also applies here.</li><li><p>dd/ds/dt: These symbols denote double floating point registers: floating point registers with even numbers ($f0-30). The R2000 has 32-bit floating point registers, so a single 64-bit value needs to be spanned across two 32-bit registers. For example:</p><div class=codehilite><pre><span></span><code><span class=err># Add the value in $f2-$f3 to the value in $f4-$f5, and store it in $f0-$f1</span>
<span class=err>    add.d   $f0,$f2,$f4</span>
<span class=err># Attempt addition with misaligned registers: this is undefined behavior!</span>
<span class=err>    add.d   $f6,$f8,$f9</span>
</code></pre></div></li><li><p>cd/cs/ct: These symbols denote <a href=#cp0_registers>registers in Coprocessor 0</a>, the System Control Processor.</p></li><li>Cd/Cs/Ct: These symbols denote control word registers in Coprocessor 1 ($FCR0 &amp; $FCR31).</li></ul><p>Comments field: The comment field usually includes some pseudocode to describe what the instruction does. This pseudocode includes some abbreviations that may not be clear at first:</p><ul><li>RF[Rs]: The 'RF' stands for 'Register File', and the Rs denotes the source register. This notation makes more sense if you think of all 32 integer registers as an array of integers. If the source register is $t0 ($t0 is the 8th register), then Rf[Rs] evaluates to the value in register $t0.</li><li>FpRf[fs]: The 'FpRf' stands for 'Floating Point Register File,' and the 'fs' denotes the source register.</li><li>un(): This stands for the 'unordered' function. In this context, it means 'check to see if this value is NaN.' See <a href=https://en.wikipedia.org/wiki/NaN>Wikipedia NaN</a></li></ul><p>Memory offsets: Several instructions have the last argument in parentheses. For example, the instruction 'lb' takes the arguments 'rt,imm(rs)'. The comment includes the pseudocode 'RF[Rt] = Mem[RF[Rs] + Offset]'. 'Mem' stands for MIPSym's simulated memory. It is expected that Rs is an integer register that holds a pointer to a particular location in memory. 'Offset' is the 'imm' in the second argument: here, it is used as an offset from the pointer in Rs. So, the 'lb' instruction finds the memory that Rs points to, looks 'imm' bytes away from that address, and copies the byte at that location into Rt.</p><p>Note that any instruction that takes the arguments 'rt,imm(rs)' will also take the arguments 'rt,(rs)'. The assembler will interpret the offset as 0 in this case.</p><hr><p><br><br></p><h3 id=int_opcodes>Integer Instruction Set</h3><p>Most of these instructions are standard on the R2000/R3000. A few of these are from later processors; these are marked as 'Unimplemented.' </p><div class=table-responsive><table class=table><thead><tr><th>Opcode Name</th><th>Arguments</th><th>Comment</th><th>Form</th></tr></thead><tbody><tr><td>add</td><td>rd,rs,rt</td><td>Add <br> RF[Rd] = RF[Rs] + RF[Rt]</td><td>r</td></tr><tr><td>add</td><td>rt,rs,imm</td><td>Add <br> alias for <strong>addi rt,rs,imm</strong> <br> RF[Rt] = RF[Rs] + Imm</td><td>i</td></tr><tr><td>addi</td><td>rt,rs,imm</td><td>Add Immediate <br> RF[Rt] = RF[Rs] + Imm</td><td>i</td></tr><tr><td>addiu</td><td>rt,rs,imm</td><td>Add Immediate Unsigned <br> RF[Rt] = RF[Rs] + Imm</td><td>i</td></tr><tr><td>addu</td><td>rd,rs,rt</td><td>Add Unsigned <br> RF[Rd] = RF[Rs] + RF[Rt]</td><td>r</td></tr><tr><td>addu</td><td>rt,rs,imm</td><td>Add Unsigned <br> alias for <strong>addiu rt,rs,imm</strong> <br> RF[Rt] = RF[Rs] + imm</td><td>i</td></tr><tr><td>and</td><td>rd,rs,rt</td><td>Bitwise And <br> RF[Rd] = RF[Rs] & RF[Rt]</td><td>r</td></tr><tr><td>andi</td><td>rt,rs,imm</td><td>Bitwise And Immediate <br> RF[Rt] = RF[Rs] & Imm</td><td>i</td></tr><tr><td>b</td><td>label</td><td>Branch <br> alias for <strong>bgez $0,label</strong> <br> PC = label</td><td>i</td></tr><tr><td>bc0f</td><td>label</td><td>Branch Coprocessor0 True <br> This is a do nothing. It used to test a pin on the part.</td><td>i</td></tr><tr><td>bc0t</td><td>label</td><td>Branch Coprocessor0 False <br> This is a do nothing. It used to test a pin on the part.</td><td>i</td></tr><tr><td>beq</td><td>rs,rt,label</td><td>Branch Equal <br> If (RF[Rs] == RF[Rt] )then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>beqz</td><td>rs,label</td><td>Branch Equal to Zero <br> alias for <strong>beq rs,$0,label</strong> <br> If (RF[Rs] == 0) then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>bgez</td><td>rs,label</td><td>Branch Greater than or Equal to Zero <br> If (RF[Rs] >= RF[0]) then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>bgezal</td><td>rs,label</td><td>Branch Greater than or Equal to Zero And Link <br> If ( RF[Rs] >= RF[0] ) then {RF[$ra] = PC; PC = PC + Imm<< 2 }</td><td>i</td></tr><tr><td>bgtz</td><td>rs,label</td><td>Branch Greater Than Zero <br> If (RF[Rs] > RF[0] ) then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>blez</td><td>rs,label</td><td>Branch Less than or Equal to Zero <br> If (RF[Rs] <= RF[0]) then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>bltz</td><td>rs,label</td><td>Branch Less Than Zero <br> If RF[Rs] < RF[0] then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>bltzal</td><td>rs,label</td><td>Branch Less Than Zero And Link <br> If ( RF[Rs] < RF[0] ) then {RF[$ra] = PC; PC = PC + Imm<< 2 }</td><td>i</td></tr><tr><td>bne</td><td>rs,rt,label</td><td>Branch Not Equal <br> If RF[Rs] != RF[Rt] then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>bnez</td><td>rs,label</td><td>Branch Not Equal to Zero <br> alias for <strong>bne rs,$0,label</strong> <br> If RF[Rs] != 0 then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>break</td><td>icode</td><td>pause execution</td><td>b</td></tr><tr><td>break</td><td>rcode</td><td>pause execution</td><td>b</td></tr><tr><td>break</td><td></td><td>pause execution <br> alias for <strong>break 0</strong></td><td>b</td></tr><tr><td>div</td><td>rs,rt</td><td>Divide (signed) <br> Low = Quotient ( RF[Rs] / RF[Rt] ); <br> High = Remainder ( RF[Rs] / RF[Rt] )</td><td>r</td></tr><tr><td>divu</td><td>rs,rt</td><td>Divide Unsigned <br> Low = Quotient ( RF[Rs] / RF[Rt] ); <br> High = Remainder ( RF[Rs] / RF[Rt] )</td><td>r</td></tr><tr><td>j</td><td>label</td><td>Jump <br> PC = PC(31:28) | Imm<< 2</td><td>j</td></tr><tr><td>jal</td><td>label</td><td>Jump And Link <br> RF[$ra] = PC; <br> PC = PC(31:28) | Imm<< 2</td><td>j</td></tr><tr><td>jalr</td><td>rd,rs</td><td>Jump And Link Register <br> RF[Rd] = PC; <br> PC = RF[Rs]</td><td>r</td></tr><tr><td>jalr</td><td>rs</td><td>Jump And Link Register <br> alias for <strong>jalr $ra,rs</strong> <br> $ra = PC; <br> PC = RF[Rs]</td><td>r</td></tr><tr><td>jr</td><td>rs</td><td>Jump Register <br> PC = RF[Rs]</td><td>r</td></tr><tr><td>lb</td><td>rt,imm(rs)</td><td>Load Byte <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>lbu</td><td>rt,imm(rs)</td><td>Load Byte Unsigned <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>lh</td><td>rt,imm(rs)</td><td>Load Half <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>lhu</td><td>rt,imm(rs)</td><td>Load Half Unsigned <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>ll</td><td>rt,imm(rs)</td><td>Load Linked <br> Unimplemented</td><td>i</td></tr><tr><td>lui</td><td>rt,imm</td><td>Load Upper Immediate <br> RF[Rt] = Imm<<16</td><td>i</td></tr><tr><td>lw</td><td>rt,imm(rs)</td><td>Load Word <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>lwl</td><td>rt,imm(rs)</td><td>Load Word Left <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>lwr</td><td>rt,imm(rs)</td><td>Load Word Right <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>mfc0</td><td>rt,cd</td><td>Move From Coprocessor0: <br> Rf[rt] = CP0Rf[cd]</td><td>r</td></tr><tr><td>mfhi</td><td>rd</td><td>Move From Hi <br> RF[Rd] = HIGH</td><td>r</td></tr><tr><td>mflo</td><td>rd</td><td>Move From Low <br> RF[Rd] = LOW</td><td>r</td></tr><tr><td>mov</td><td>rd,rs</td><td>Move <br> alias for <strong>addu rd,rs,$0</strong> <br> RF[Rd] = RF[Rs]</td><td>r</td></tr><tr><td>move</td><td>rd,rs</td><td>Move <br> alias for <strong>addu rd,rs,$0</strong> <br> RF[Rd] = RF[Rs]</td><td>r</td></tr><tr><td>mtc0</td><td><strong>rt,cd</strong></td><td>Move To Coprocessor0: <br> CP0Rf[cd] = Rf[rt] <br> <strong>Backwards Arguments!</strong></td><td>r</td></tr><tr><td>mthi</td><td>rs</td><td>Move To Hi <br> HIGH = RF[Rs]</td><td>r</td></tr><tr><td>mtlo</td><td>rs</td><td>Move To Low <br> LOW = RF[Rs]</td><td>r</td></tr><tr><td>mult</td><td>rs,rt</td><td>Multiply (signed) <br> High |Low = RF[Rs] * RF[Rt]</td><td>r</td></tr><tr><td>multu</td><td>rs,rt</td><td>Multiply Unsigned <br> High |Low = RF[Rs] * RF[Rt]</td><td>r</td></tr><tr><td>neg</td><td>rd,rt</td><td>Negate <br> alias for <strong>sub rd,$0,rt</strong> <br> RF[Rd] = -RF[Rt]</td><td>r</td></tr><tr><td>negu</td><td>rd,rt</td><td>Negate <br> alias for <strong>subu rd,$0,rt</strong> <br> RF[Rd] = -RF[Rt]</td><td>r</td></tr><tr><td>nop</td><td></td><td>no operation <br> alias for <strong>sll $0,$0,0</strong></td><td>r</td></tr><tr><td>nor</td><td>rd,rs,rt</td><td>Bitwise Nor <br> RF[Rd] = !(RF[Rs] | RF[Rt])</td><td>r</td></tr><tr><td>not</td><td>rd,rs</td><td>Boolean Not <br> alias for <strong>nor rd,rs,$0</strong> <br> RF[Rd] = !(RF[Rs] | 0)</td><td>r</td></tr><tr><td>or</td><td>rd,rs,rt</td><td>Bitwise Or <br> RF[Rd] = RF[Rs] | RF[Rt]</td><td>r</td></tr><tr><td>ori</td><td>rt,rs,imm</td><td>Bitwise Or Immediate <br> RF[Rt] = RF[Rs] | Imm</td><td>i</td></tr><tr><td>rfe</td><td></td><td>Restore From Exception <br>restores the status register to its value before the last exception occurred.</td><td>r</td></tr><tr><td>sb</td><td><strong>rt,imm(rs)</strong></td><td>Store Byte: <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td><td>i</td></tr><tr><td>sgt</td><td>rd,rt,rs</td><td>Set Greater Than <br> alias for <strong>slt rd,rs,rt</strong> <br> if (RF[Rt] > RF[Rs] ) then RF[Rd] =1 else RF[Rd] = 0</td><td>r</td></tr><tr><td>sgtu</td><td>rd,rt,rs</td><td>Set Greater Than Unsigned <br> alias for <strong>sltu rd,rs,rt</strong> <br> if (RF[Rt] > RF[Rs] ) then RF[Rd] =1 else RF[Rd] = 0</td><td>r</td></tr><tr><td>sh</td><td><strong>rt,imm(rs)</strong></td><td>Store Half: <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td><td>i</td></tr><tr><td>sll</td><td>rd,rt,n</td><td>Shift Left Logical (immediate) <br> RF[Rd] = RF[Rt] << n</td><td>r</td></tr><tr><td>sll</td><td>rd,rt,rs</td><td>Shift Left Logical <br> alias for <strong>sllv rd,rt,rs</strong> <br> RF[Rd] = RF[Rt] << RF[Rs] amount</td><td>r</td></tr><tr><td>sllv</td><td>rd,rt,rs</td><td>Shift Left Logical Variable <br> RF[Rd] = RF[Rt] << RF[Rs] amount</td><td>r</td></tr><tr><td>slt</td><td>rd,rs,rt</td><td>Set Less Than <br> if (RF[Rs] < RF[Rt] ) then RF[Rd] =1 else RF[Rd] = 0</td><td>r</td></tr><tr><td>slti</td><td>rt,rs,imm</td><td>Set Less Than Immediate <br> if (RF[Rs] < Imm) then RF[Rt] = 1 else RF[Rt] = 0</td><td>i</td></tr><tr><td>sltiu</td><td>rt,rs,imm</td><td>Set Less Than Immediate Unsigned <br> if (RF[Rs] < Imm) then RF[Rt] = 1 else RF[Rt] = 0</td><td>i</td></tr><tr><td>sltu</td><td>rd,rs,rt</td><td>Set Less Than Unsigned <br> if (RF[Rs] < RF[Rt] ) then RF[Rd] =1 else RF[Rd] = 0</td><td>r</td></tr><tr><td>sra</td><td>rd,rt,n</td><td>Shift Right Arithmetic (immediate) <br> RF[Rd] = RF[Rt] >> n (sign-extend)</td><td>r</td></tr><tr><td>sra</td><td>rd,rt,rs</td><td>Shift Right Arithmetic <br> alias for <strong>srav rd,rt,rs</strong> <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (sign-extend)</td><td>r</td></tr><tr><td>srav</td><td>rd,rt,rs</td><td>Shift Right Arithmetic Variable <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (sign-extend)</td><td>r</td></tr><tr><td>srl</td><td>rd,rt,n</td><td>Shift Right Logical <br> RF[Rd] = RF[Rt] >> n (no sign extension)</td><td>r</td></tr><tr><td>srl</td><td>rd,rt,rs</td><td>Shift Right Logical <br> alias for <strong>srlv rd,rt,rs</strong> <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (no sign extension)</td><td>r</td></tr><tr><td>srlv</td><td>rd,rt,rs</td><td>Shift Right Logical Variable <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (no sign extension)</td><td>r</td></tr><tr><td>sub</td><td>rd,rs,rt</td><td>Subtract <br> RF[Rd] = RF[Rs] - RF[Rt]</td><td>r</td></tr><tr><td>subu</td><td>rd,rs,rt</td><td>Subtract Unsigned <br> RF[Rd] = RF[Rs] - RF[Rt]</td><td>r</td></tr><tr><td>sw</td><td><strong>rt,imm(rs)</strong></td><td>Store Word: <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td><td>i</td></tr><tr><td>swl</td><td><strong>rt,imm(rs)</strong></td><td>Store Word Left (1-4 bytes, depending on offset): <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td><td>i</td></tr><tr><td>swr</td><td><strong>rt,imm(rs)</strong></td><td>Store Word Right (1-4 bytes, depending on offset): <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td><td>i</td></tr><tr><td>syscall</td><td></td><td>call syscall in $v0</td><td>b</td></tr><tr><td>syscall</td><td>scode</td><td>call syscall in argument</td><td>b</td></tr><tr><td>syscall</td><td>rcode</td><td>call syscall in register</td><td>b</td></tr><tr><td>tlbp</td><td></td><td>Probe TLB For Matching Entry <br> Unimplemented</td><td>r</td></tr><tr><td>tlbr</td><td></td><td>Read Indexed TLB Entry <br> Unimplemented</td><td>r</td></tr><tr><td>tlbwi</td><td></td><td>Write Indexed TLB Entry <br> Unimplemented</td><td>r</td></tr><tr><td>tlbwr</td><td></td><td>Write Random TLB Entry <br> Unimplemented</td><td>r</td></tr><tr><td>xor</td><td>rd,rs,rt</td><td>Bitwise Xor <br> RF[Rd] = RF[Rs] ^ RF[Rt]</td><td>r</td></tr><tr><td>xori</td><td>rt,rs,imm</td><td>Bitwise Xor Immediate <br> RF[Rt] = RF[Rs] ^ Imm</td><td>i</td></tr></tbody></table></div><hr><p><br><br></p><h3 id=fp_opcodes>Floating-Point Instruction Set</h3><p>Most of these instructions are standard on the R2000/R3000. A few of these are from later processors; these are marked as 'Unimplemented.' </p><div class=table-responsive><table class=table><thead><tr><th>Opcode Name</th><th>Arguments</th><th>Comment</th><th>Form</th></tr></thead><tbody><tr><td>abs.d</td><td>dd,ds</td><td>Absolute value double: <br> FpRf[dd] = |FpRf[ds]|</td><td>r</td></tr><tr><td>abs.s</td><td>fd,fs</td><td>Absolute value single: <br> FpRf[fd] = |FpRf[fs]|</td><td>r</td></tr><tr><td>add.d</td><td>dd,ds,dt</td><td>Add double: <br> FpRf[dd] = FpRf[ds] + FpRf[dt]</td><td>r</td></tr><tr><td>add.s</td><td>fd,fs,ft</td><td>Add single: <br> FpRf[fd] = FpRf[fs] + FpRf[ft]</td><td>r</td></tr><tr><td>bc1f</td><td>label</td><td>branch if status flag is false</td><td>i</td></tr><tr><td>bc1t</td><td>label</td><td>branch if status flag is true</td><td>i</td></tr><tr><td>c.eq.d</td><td>ds,dt</td><td>Compare Equal Doubles: <br> ControlRf[31].condition_bit = FpRf[dt] == FpRf[ds] && !(un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.eq.s</td><td>fs,ft</td><td>Compare Equal Singles: <br> ControlRf[31].condition_bit = FpRf[ft] == FpRf[fs] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.f.d</td><td>ds,dt</td><td>Compare False: <br> ControlRf[31].condition_bit = 0</td><td>r</td></tr><tr><td>c.f.s</td><td>fs,ft</td><td>Compare False: <br> ControlRf[31].condition_bit = 0</td><td>r</td></tr><tr><td>c.le.d</td><td>ds,dt</td><td>Compare Less Than or Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.le.s</td><td>fs,ft</td><td>Compare Less Than or Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.lt.d</td><td>ds,dt</td><td>Compare Less Than: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.lt.s</td><td>fs,ft</td><td>Compare Less Than: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.nge.d</td><td>ds,dt</td><td>Compare Not Greater or Equal, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] || (un(FpRf[ds]) || un(FpRf[dt]))</td><td>r</td></tr><tr><td>c.nge.s</td><td>fs,ft</td><td>Compare Not Greater or Equal, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] || (un(FpRf[fs]) || un(FpRf[ft]))</td><td>r</td></tr><tr><td>c.ngl.d</td><td>ds,dt</td><td>Compare Not Greater or Less Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] == FpRf[dt] || (un(FpRf[ds]) || un(FpRf[dt]))</td><td>r</td></tr><tr><td>c.ngl.s</td><td>fs,ft</td><td>Compare Not Greater or Less Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] == FpRf[ft] || (un(FpRf[fs]) || un(FpRf[ft]))</td><td>r</td></tr><tr><td>c.ngle.d</td><td>ds,dt</td><td>Compare Not Greater, Less, or Equal (only true if unordered): <br> exception if unordered; <br> ControlRf[31].condition_bit = (un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.ngle.s</td><td>fs,ft</td><td>Compare Not Greater, Less, or Equal (only true if unordered): <br> exception if unordered; <br> ControlRf[31].condition_bit = (un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.ngt.d</td><td>ds,dt</td><td>Compare Not Greater Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] || (un(FpRf[fs]) || un(FpRf[ft]))</td><td>r</td></tr><tr><td>c.ngt.s</td><td>fs,ft</td><td>Compare Not Greater Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] || (un(FpRf[fs]) || un(FpRf[ft]))</td><td>r</td></tr><tr><td>c.ole.d</td><td>ds,dt</td><td>Compare Ordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.ole.s</td><td>fs,ft</td><td>Compare Ordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.olt.d</td><td>ds,dt</td><td>Compare Ordered Less Than: <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.olt.s</td><td>fs,ft</td><td>Compare Ordered Less Than: <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.seq.d</td><td>ds,dt</td><td>Compare Signaling Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] == FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.seq.s</td><td>fs,ft</td><td>Compare Signaling Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] == FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.sf.d</td><td>ds,dt</td><td>Compare Signaling False: <br> exception if unordered; <br> ControlRf[31].condition_bit = 0</td><td>r</td></tr><tr><td>c.sf.s</td><td>fs,ft</td><td>Compare Signaling False: <br> exception if unordered; <br> ControlRf[31].condition_bit = 0</td><td>r</td></tr><tr><td>c.ueq.d</td><td>ds,dt</td><td>Compare Unordered/Equal Doubles: <br> ControlRf[31].condition_bit = (FpRf[dt] == FpRf[ds]) || (un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.ueq.s</td><td>fs,ft</td><td>Compare Unordered/Equal Singles: <br> ControlRf[31].condition_bit = (FpRf[ft] == FpRf[fs]) || (un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.ule.d</td><td>ds,dt</td><td>Compare Unordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] || (un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.ule.s</td><td>fs,ft</td><td>Compare Unordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] || (un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.ult.d</td><td>ds,dt</td><td>Compare Unordered Less Than: <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] || (un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.ult.s</td><td>fs,ft</td><td>Compare Unordered Less Than: <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] || (un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.un.d</td><td>ds,dt</td><td>Compare Unordered Doubles: <br> ControlRf[31].condition_bit = un(FpRf[dt]) || un(FpRf[ds])</td><td>r</td></tr><tr><td>c.un.s</td><td>fs,ft</td><td>Compare Unordered Singles: <br> ControlRf[31].condition_bit = un(FpRf[ft]) || un(FpRf[fs])</td><td>r</td></tr><tr><td>cfc1</td><td>rt,Cs</td><td>move control word from cop1: <br> Rf[rt] = ControlRf[Cs]</td><td>r</td></tr><tr><td>ctc1</td><td>rt,Cs</td><td>move control word to cop1: <br> ControlRf[Cs] = Rf[rt]</td><td>r</td></tr><tr><td>cvt.d.s</td><td>dd,fs</td><td>Convert single to double: <br> FpRf[dd] = (double) FpRf[fs]</td><td>r</td></tr><tr><td>cvt.d.w</td><td>dd,fs</td><td>Convert integer to double: <br> FpRf[dd] = (double) FpRf[fs]</td><td>r</td></tr><tr><td>cvt.s.d</td><td>fd,ds</td><td>Convert double to single: <br> FpRf[fd] = (float) FpRf[ds]</td><td>r</td></tr><tr><td>cvt.s.w</td><td>fd,fs</td><td>Convert integer to single: <br> FpRf[fd] = (float) FpRf[fs]</td><td>r</td></tr><tr><td>cvt.w.d</td><td>fd,ds</td><td>Convert double to integer: <br> FpRf[fd] = (int) FpRf[ds]</td><td>r</td></tr><tr><td>cvt.w.s</td><td>fd,fs</td><td>Convert single to integer: <br> FpRf[fd] = (int) FpRf[fs]</td><td>r</td></tr><tr><td>div.d</td><td>dd,ds,dt</td><td>Divide double: <br> FpRf[dd] = FpRf[ds] / FpRf[dt]</td><td>r</td></tr><tr><td>div.s</td><td>fd,fs,ft</td><td>Divide single: <br> FpRf[fd] = FpRf[fs] / FpRf[ft]</td><td>r</td></tr><tr><td>l.s</td><td>ft,imm(rs)</td><td>load word to cop1: <br> FpRf[ft] = Mem[Rf[rs] + Offset]</td><td>i</td></tr><tr><td>lwc1</td><td>ft,imm(rs)</td><td>load word to cop1: <br> FpRf[ft] = Mem[Rf[rs] + Offset]</td><td>i</td></tr><tr><td>lwc2</td><td>rt,imm(rs)</td><td>load word to cop2: <br> Unimplemented</td><td>i</td></tr><tr><td>lwc3</td><td>rt,imm(rs)</td><td>load word to cop3: <br> Unimplemented</td><td>i</td></tr><tr><td>mfc1</td><td>rt,fs</td><td>move from cop1: <br> Rf[rt] = FpRf[fs]</td><td>r</td></tr><tr><td>mov.d</td><td>dd,ds</td><td>Copy double value: <br> FpRf[dd] = FpRf[ds]</td><td>r</td></tr><tr><td>mov.s</td><td>fd,fs</td><td>Copy single value: <br> FpRf[fd] = FpRf[fs]</td><td>r</td></tr><tr><td>mtc1</td><td>rt,fs</td><td>move to cop1: <br> FpRf[fs] = Rf[rt]</td><td>r</td></tr><tr><td>mul.d</td><td>dd,ds,dt</td><td>Multiply double: <br> FpRf[dd] = FpRf[ds] * FpRf[dt]</td><td>r</td></tr><tr><td>mul.s</td><td>fd,fs,ft</td><td>Multiply single: <br> FpRf[fd] = FpRf[fs] * FpRf[ft]</td><td>r</td></tr><tr><td>neg.d</td><td>dd,ds</td><td>Negate double value: <br> FpRf[dd] = -FpRf[ds]</td><td>r</td></tr><tr><td>neg.s</td><td>fd,fs</td><td>Negate single value: <br> FpRf[fd] = -FpRf[fs]</td><td>r</td></tr><tr><td>s.s</td><td>ft,imm(rs)</td><td>store word from cop1: <br> Mem[Rf[rs] + Offset] = FpRf[ft]</td><td>i</td></tr><tr><td>sc</td><td>rt,imm(rs)</td><td>Unimplemented</td><td>i</td></tr><tr><td>sub.d</td><td>dd,ds,dt</td><td>Subtract double: <br> FpRf[dd] = FpRf[ds] - FpRf[dt]</td><td>r</td></tr><tr><td>sub.s</td><td>fd,fs,ft</td><td>Subtract single: <br> FpRf[fd] = FpRf[fs] - FpRf[ft]</td><td>r</td></tr><tr><td>swc1</td><td>ft,imm(rs)</td><td>store word from cop1: <br> Mem[Rf[rs] + Offset] = FpRf[ft]</td><td>i</td></tr><tr><td>swc2</td><td>rt,imm(rs)</td><td>store word from cop2: <br> Mem[Rf[rs] + Offset] = Unimplemented</td><td>i</td></tr><tr><td>swc3</td><td>rt,imm(rs)</td><td>store word from cop3: <br> Mem[Rf[rs] + Offset] = Unimplemented</td><td>i</td></tr></tbody></table></div><hr><p><br><br></p><h3 id=fp_math_opcodes>Floating-Point Math Opcodes, MIPSym-Specific</h3><p>These are nonstandard opcodes for various mathematic functions. They are not native to the R2000/R3000, but they may be useful for your programs. Some of these opcodes are standard in later versions of MIPS.</p><div class=table-responsive><table class=table><thead><tr><th>Opcode Name</th><th>Arguments</th><th>Comment</th><th>Form</th></tr></thead><tbody><tr><td>acos.d</td><td>dd,ds</td><td>arc cosine double: <br> FpRf[dd] = acos(FpRf[ds])</td><td>r</td></tr><tr><td>acos.s</td><td>fd,fs</td><td>arc cosine single: <br> FpRf[fd] = acos(FpRf[fs])</td><td>r</td></tr><tr><td>acosh.d</td><td>dd,ds</td><td>arc hyperbolic cosine double: <br> FpRf[dd] = acosh(FpRf[ds])</td><td>r</td></tr><tr><td>acosh.s</td><td>fd,fs</td><td>arc hyperbolic cosine single: <br> FpRf[fd] = acosh(FpRf[fs])</td><td>r</td></tr><tr><td>asin.d</td><td>dd,ds</td><td>arc sine double: <br> FpRf[dd] = asin(FpRf[ds])</td><td>r</td></tr><tr><td>asin.s</td><td>fd,fs</td><td>arc sine single: <br> FpRf[fd] = asin(FpRf[fs])</td><td>r</td></tr><tr><td>asinh.d</td><td>dd,ds</td><td>arc hyperbolic sine double: <br> FpRf[dd] = asinh(FpRf[ds])</td><td>r</td></tr><tr><td>asinh.s</td><td>fd,fs</td><td>arc hyperbolic sine single: <br> FpRf[fd] = asinh(FpRf[fs])</td><td>r</td></tr><tr><td>atan.d</td><td>dd,ds</td><td>arc tangent double: <br> FpRf[dd] = atan(FpRf[ds])</td><td>r</td></tr><tr><td>atan.s</td><td>fd,fs</td><td>arc tangent single: <br> FpRf[fd] = atan(FpRf[fs])</td><td>r</td></tr><tr><td>atan2.d</td><td>dd,ds,dt</td><td>arc tangent of y,x double: <br> FpRf[dd] = atan2(FpRf[ds],FpRf[dt])</td><td>r</td></tr><tr><td>atan2.s</td><td>fd,fs,ft</td><td>arc tangent of y,x single: <br> FpRf[fd] = atan2(FpRf[fs],FpRf[ft])</td><td>r</td></tr><tr><td>atanh.d</td><td>dd,ds</td><td>arc hyperbolic tangent double: <br> FpRf[dd] = atanh(FpRf[ds])</td><td>r</td></tr><tr><td>atanh.s</td><td>fd,fs</td><td>arc hyperbolic tangent single: <br> FpRf[fd] = atanh(FpRf[fs])</td><td>r</td></tr><tr><td>ceil.d</td><td>dd,ds</td><td>ceiling double: <br> FpRf[dd] = ceil(FpRf[ds])</td><td>r</td></tr><tr><td>ceil.s</td><td>fd,fs</td><td>ceiling single: <br> FpRf[fd] = ceil(FpRf[fs])</td><td>r</td></tr><tr><td>cos.d</td><td>dd,ds</td><td>cosine double: <br> FpRf[dd] = cos(FpRf[ds])</td><td>r</td></tr><tr><td>cos.s</td><td>fd,fs</td><td>cosine single: <br> FpRf[fd] = cos(FpRf[fs])</td><td>r</td></tr><tr><td>cosh.d</td><td>dd,ds</td><td>hyperbolic cosine double: <br> FpRf[dd] = cosh(FpRf[ds])</td><td>r</td></tr><tr><td>cosh.s</td><td>fd,fs</td><td>hyperbolic cosine single: <br> FpRf[fd] = cosh(FpRf[fs])</td><td>r</td></tr><tr><td>exp.d</td><td>dd,ds</td><td>e to the x power double: <br> FpRf[dd] = exp(FpRf[ds])</td><td>r</td></tr><tr><td>exp.s</td><td>fd,fs</td><td>e to the x power single: <br> FpRf[fd] = exp(FpRf[fs])</td><td>r</td></tr><tr><td>floor.d</td><td>dd,ds</td><td>floor double: <br> FpRf[dd] = floor(FpRf[ds])</td><td>r</td></tr><tr><td>floor.s</td><td>fd,fs</td><td>floor single: <br> FpRf[fd] = floor(FpRf[fs])</td><td>r</td></tr><tr><td>ln.d</td><td>dd,ds</td><td>natural log double: <br> FpRf[dd] = ln(FpRf[ds])</td><td>r</td></tr><tr><td>ln.s</td><td>fd,fs</td><td>natural log single: <br> FpRf[fd] = ln(FpRf[fs])</td><td>r</td></tr><tr><td>round.d</td><td>dd,ds</td><td>round double: <br> FpRf[dd] = round(FpRf[ds])</td><td>r</td></tr><tr><td>round.s</td><td>fd,fs</td><td>round single: <br> FpRf[fd] = round(FpRf[fs])</td><td>r</td></tr><tr><td>sin.d</td><td>dd,ds</td><td>sine double: <br> FpRf[dd] = sin(FpRf[ds])</td><td>r</td></tr><tr><td>sin.s</td><td>fd,fs</td><td>sine single: <br> FpRf[fd] = sin(FpRf[fs])</td><td>r</td></tr><tr><td>sinh.d</td><td>dd,ds</td><td>hyperbolic sine double: <br> FpRf[dd] = sinh(FpRf[ds])</td><td>r</td></tr><tr><td>sinh.s</td><td>fd,fs</td><td>hyperbolic sine single: <br> FpRf[fd] = sinh(FpRf[fs])</td><td>r</td></tr><tr><td>sqrt.d</td><td>dd,ds</td><td>square root double: <br> FpRf[dd] = sqrt(FpRf[ds])</td><td>r</td></tr><tr><td>sqrt.s</td><td>fd,fs</td><td>square root single: <br> FpRf[fd] = sqrt(FpRf[fs])</td><td>r</td></tr><tr><td>tan.d</td><td>dd,ds</td><td>tangent double: <br> FpRf[dd] = tan(FpRf[ds])</td><td>r</td></tr><tr><td>tan.s</td><td>fd,fs</td><td>tangent single: <br> FpRf[fd] = tan(FpRf[fs])</td><td>r</td></tr><tr><td>tanh.d</td><td>dd,ds</td><td>hyperbolic tangent double: <br> FpRf[dd] = tanh(FpRf[ds])</td><td>r</td></tr><tr><td>tanh.s</td><td>fd,fs</td><td>hyperbolic tangent single: <br> FpRf[fd] = tanh(FpRf[fs])</td><td>r</td></tr><tr><td>trunc.d</td><td>dd,ds</td><td>truncate double: <br> FpRf[dd] = trunc(FpRf[ds])</td><td>r</td></tr><tr><td>trunc.s</td><td>fd,fs</td><td>truncate single: <br> FpRf[fd] = trunc(FpRf[fs])</td><td>r</td></tr></tbody></table></div><hr><p><br><br></p><h3 id=macros>Macros</h3><p>In addition to the original instructions implemented in the R2000, MIPSym also supports the use of several macros to make the process of writing assembly code easier. </p><p>Unlike SPIM, macros cannot be defined in program code. Supported macros are defined in the file MIPSym/asm/Mips1.adf.</p><div class=table-responsive><table class=table><thead><tr><th>Macro Name</th><th>Arguments</th><th>Definition</th><th>Comment</th></tr></thead><tbody><tr><td>abs</td><td>rd,rs</td><td><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  addu  rd,$0,rs
  bgez  rs,09f
  sub   rd,$0,rs
09:</code></pre></td><td><pre><code>  bgez  rs,09f
  addu  rd,$0,rs
  sub   rd,$0,rs
09:</code></pre></td></tr></tbody></table></td><td>Absolute Value</td></tr><tr><td>addi</td><td>rt,imm</td><td><pre><code>  addi  rt,rt,imm</code></pre></td><td>Add immediate: <br> Rf[rt] = Rf[rt] + imm</td></tr><tr><td>addiu</td><td>rt,imm</td><td><pre><code>  addiu rt,rt,imm</code></pre></td><td>Add immediate unsigned: <br> Rf[rt] = Rf[rt] + imm</td></tr><tr><td>andi</td><td>rt,imm</td><td><pre><code>  andi  rt,rt,imm</code></pre></td><td>And immediate: <br> Rf[rt] = Rf[rt] & imm</td></tr><tr><td>beq</td><td>rs,imm,label</td><td><pre><code>  li    $at,imm
  beq   rs,$at,label</code></pre></td><td>Branch equal to <br> If (RF[Rs] == Imm) then branch to Label</td></tr><tr><td>bge</td><td>rs,rt,label</td><td><pre><code>  slt   $at,rs,rt
  beq   $at,$0,label</code></pre></td><td>Branch greater than or equal to <br> If (RF[Rs] >= Rf[Rt]) then branch to Label</td></tr><tr><td>bge</td><td>rs,imm,label</td><td><pre><code>  li    $at,imm
  slt   $at,rs,$at
  beq   $at,$0,label</code></pre></td><td>Branch greater than or equal to <br> If (RF[Rs] >= Imm) then branch to Label</td></tr><tr><td>bgeu</td><td>rs,rt,label</td><td><pre><code>  sltu  $at,rs,rt
  beq   $at,$0,label</code></pre></td><td>Branch greater than or equal to (Unsigned) <br> If (RF[Rs] >= Rf[Rt]) then branch to Label</td></tr><tr><td>bgeu</td><td>rs,imm,label</td><td><pre><code>  li    $at,imm
  sltu  $at,rs,$at
  beq   $at,$0,label</code></pre></td><td>Branch greater than or equal to (Unsigned) <br> If (RF[Rs] >= Imm) then branch to Label</td></tr><tr><td>bgt</td><td>rs,rt,label</td><td><pre><code>  slt   $at,rt,rs
  bne   $at,$0,label</code></pre></td><td>Branch greater than <br> If (RF[Rs] > Rf[Rt]) then branch to Label</td></tr><tr><td>bgt</td><td>rs,imm,label</td><td><pre><code>  li    $at,imm
  slt   $at,$at,rs
  bne   $at,$0,label</code></pre></td><td>Branch greater than <br> If (RF[Rs] > Imm) then branch to Label</td></tr><tr><td>bgtu</td><td>rs,rt,label</td><td><pre><code>  sltu  $at,rt,rs
  bne   $at,$0,label</code></pre></td><td>Branch greater than (Unsigned) <br> If (RF[Rs] > Rf[Rt]) then branch to Label</td></tr><tr><td>bgtu</td><td>rs,imm,label</td><td><pre><code>  li    $at,imm
  sltu  $at,$at,rs
  bne   $at,$0,label</code></pre></td><td>Branch greater than (Unsigned) <br> If (RF[Rs] > Imm) then branch to Label</td></tr><tr><td>ble</td><td>rs,rt,label</td><td><pre><code>  slt   $at,rt,rs
  beq   $at,$0,label</code></pre></td><td>Branch less than or equal to <br> If (RF[Rs] <= Rf[Rt]) then branch to Label</td></tr><tr><td>ble</td><td>rs,imm,label</td><td><pre><code>  li    $at,imm
  slt   $at,$at,rs
  beq   $at,$0,label</code></pre></td><td>Branch less than or equal to <br> If (RF[Rs] <= Imm) then branch to Label</td></tr><tr><td>bleu</td><td>rs,rt,label</td><td><pre><code>  sltu  $at,rt,rs
  beq   $at,$0,label</code></pre></td><td>Branch less than or equal to (Unsigned) <br> If (RF[Rs] <= Rf[Rt]) then branch to Label</td></tr><tr><td>bleu</td><td>rs,imm,label</td><td><pre><code>  li    $at,imm
  sltu  $at,$at,rs
  beq   $at,$0,label</code></pre></td><td>Branch less than or equal to (Unsigned) <br> If (RF[Rs] <= Imm) then branch to Label</td></tr><tr><td>blt</td><td>rs,rt,label</td><td><pre><code>  slt   $at,rs,rt
  bne   $at,$0,label</code></pre></td><td>Branch less than <br> If (RF[Rs] < Rf[Rt]) then branch to Label</td></tr><tr><td>blt</td><td>rs,imm,label</td><td><pre><code>  li    $at,imm
  slt   $at,rs,$at
  bne   $at,$0,label</code></pre></td><td>Branch less than <br> If (RF[Rs] < Imm) then branch to Label</td></tr><tr><td>bltu</td><td>rs,rt,label</td><td><pre><code>  sltu  $at,rs,rt
  bne   $at,$0,label</code></pre></td><td>Branch less than (Unsigned) <br> If (RF[Rs] < Rf[Rt]) then branch to Label</td></tr><tr><td>bltu</td><td>rs,imm,label</td><td><pre><code>  li    $at,imm
  sltu  $at,rs,$at
  bne   $at,$0,label</code></pre></td><td>Branch less than (Unsigned) <br> If (RF[Rs] < Imm) then branch to Label</td></tr><tr><td>bne</td><td>rs,imm,label</td><td><pre><code>  li    $at,imm
  bne   rs,$at,label</code></pre></td><td>Branch not equal <br> If (RF[Rs] != Imm) then branch to Label</td></tr><tr><td>div</td><td>rd,rs,rt</td><td><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  div   rs,rt
  mflo  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  div   rs,rt
  mflo  rd</code></pre></td></tr></tbody></table></td><td>Divide: <br> Rf[rd] = Rf[rs]/Rf[rt] <br> (break on divide by zero)</td></tr><tr><td>div</td><td>rd,rs,n</td><td><pre><code>  li    $at,n
  div   rs,$at
  mflo  rd</code></pre></td><td>Divide: <br> Rf[rd] = Rf[rs]/n</td></tr><tr><td>div</td><td>rd,n</td><td><pre><code>  li    $at,n
  div   rd,$at
  mflo  rd</code></pre></td><td>Divide: <br> Rf[rd] = Rf[rd]/n</td></tr><tr><td>divu</td><td>rd,rs,rt</td><td><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  divu  rs,rt
  mflo  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  divu  rs,rt
  mflo  rd</code></pre></td></tr></tbody></table></td><td>Divide unsigned: <br> Rf[rd] = Rf[rs] / Rf[rt] <br> (break on divide by zero)</td></tr><tr><td>divu</td><td>rd,rs,n</td><td><pre><code>  li    $at,n
  divu  rs,$at
  mflo  rd</code></pre></td><td>Divide unsigned: <br> Rf[rd] = Rf[rs] / n</td></tr><tr><td>divu</td><td>rd,n</td><td><pre><code>  li    $at,n
  divu  rd,$at
  mflo  rd</code></pre></td><td>Divide unsigned: <br> Rf[rd] = Rf[rd] / n</td></tr><tr><td>l.d</td><td>dd,laddress</td><td><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lwc1  dd,laddress&0xFFFF($at)
  lwc1  dd+1,laddress&0xFFFF+4($at)</code></pre></td><td>Load double: <br> FpRf[dd] = laddress</td></tr><tr><td>l.d</td><td>dd,imm(rs)</td><td><pre><code>  lwc1  dd,imm(rs)
  lwc1  dd+1,imm+4(rs)</code></pre></td><td>Load double: <br> FpRf[dd] = Mem[RF[Rs] + Offset]</td></tr><tr><td>l.s</td><td>fd,laddress</td><td><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lwc1  fd,laddress&0xFFFF($at)</code></pre></td><td>Load single: <br> FpRf[fd] = laddress</td></tr><tr><td>la</td><td>rd,laddress</td><td><pre><code>  lui   rd,laddress>>16
  ori   rd,rd,laddress&0xffff</code></pre></td><td>Load Address into Rf[rd]</td></tr><tr><td>lb</td><td>rd,laddress</td><td><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lb    rd,laddress&0xFFFF($at)</code></pre></td><td>Load byte (low 8 bits): <br> Rf[rd] = Mem[laddress]</td></tr><tr><td>lbu</td><td>rd,laddress</td><td><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lbu   rd,laddress&0xFFFF($at)</code></pre></td><td>Load byte unsigned (low 8 bits): <br> Rf[rd] = Mem[laddress]</td></tr><tr><td>lh</td><td>rd,laddress</td><td><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lh    rd,laddress&0xFFFF($at)</code></pre></td><td>Load half (low 16 bits): <br> Rf[rd] = Mem[laddress]</td></tr><tr><td>lhu</td><td>rd,laddress</td><td><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lhu   rd,laddress&0xFFFF($at)</code></pre></td><td>Load half unsigned (low 16 bits): <br> Rf[rd] = Mem[laddress]</td></tr><tr><td>li</td><td>rd,imm</td><td><pre><code>ori   rd,$0,imm</code></pre></td><td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when the high 16 bits of imm are empty.</td></tr><tr><td>li</td><td>rd,imm</td><td><pre><code>lui   rd,imm</code></pre></td><td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when the low 16 bits of imm are empty.</td></tr><tr><td>li</td><td>rd,imm</td><td><pre><code>addi   rd,$0,imm</code></pre></td><td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when the high 17 bits of imm are 1 (it's a small negative number).</td></tr><tr><td>li</td><td>rd,imm</td><td><pre><code>lui   rd,imm
ori   rd,$0,imm</code></pre></td><td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when none of the three other forms can be used.</td></tr><tr><td>lw</td><td>rd,laddress</td><td><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lw    rd,laddress&0xFFFF($at)</code></pre></td><td>Load word (full 32 bits): <br> Rf[rd] = Mem[laddress]</td></tr><tr><td>mul</td><td>rd,rs,rt</td><td><pre><code>  mult  rs,rt
  mflo  rd</code></pre></td><td>Multiply: <br> Rf[rd] = Rf[rs] * Rf[rt]</td></tr><tr><td>mul</td><td>rd,rs,n</td><td><pre><code>  li    $at,n
  mult  rs,$at
  mflo  rd</code></pre></td><td>Multiply: <br> Rf[rd] = Rf[rs]*n</td></tr><tr><td>mul</td><td>rd,n</td><td><pre><code>  li    $at,n
  mult  rd,$at
  mflo  rd</code></pre></td><td>Multiply: <br> Rf[rd] = Rf[rd]*n</td></tr><tr><td>mulo</td><td>rd,rs,rt</td><td><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  mult  rs,rt
  mfhi  $at
  mflo  rd
  sra   rd,rd,31
  beq   $at,rd,08f
  break
08:
  mflo  rd</code></pre></td><td><pre><code>  mult  rs,rt
  mfhi  $at
  mflo  rd
  sra   rd,rd,31
  beq   $at,rd,08f
  mflo  rd
  break
08:</code></pre></td></tr></tbody></table></td><td>Multiply, break on overflow</td></tr><tr><td>mulou</td><td>rd,rs,rt</td><td><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  multu rs,rt
  mfhi  $at
  beq   $at,$0,08f
  break
08:
  mflo  rd</code></pre></td><td><pre><code>  multu rs,rt
  mfhi  $at
  beq   $at,$0,08f
  mflo  rd
  break
08:</code></pre></td></tr></tbody></table></td><td>Multiply unsigned, break on overflow</td></tr><tr><td>mulu</td><td>rd,rs,rt</td><td><pre><code>  multu rs,rt
  mflo  rd</code></pre></td><td>Multiply unsigned: <br> Rf[rd] = Rf[rs] * Rf[rt]</td></tr><tr><td>mulu</td><td>rd,rs,n</td><td><pre><code>  li    $at,n
  multu rs,$at
  mflo  rd</code></pre></td><td>Multiply unsigned: <br> Rf[rd] = Rf[rs] * n</td></tr><tr><td>mulu</td><td>rd,n</td><td><pre><code>  li    $at,n
  multu rd,$at
  mflo  rd</code></pre></td><td>Multiply unsigned: <br> Rf[rd] = Rf[rd] * n</td></tr><tr><td>ori</td><td>rt,imm</td><td><pre><code>  ori   rt,rt,imm</code></pre></td><td>Or immediate: <br> Rf[rt] = Rf[rt] | imm</td></tr><tr><td>rem</td><td>rd,rs,rt</td><td><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  div   rs,rt
  mfhi  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  div   rs,rt
  mfhi  rd</code></pre></td></tr></tbody></table></td><td>Remainder: <br> Rf[rd] = Rf[rs] % Rf[rt]</td></tr><tr><td>rem</td><td>rd,rs,n</td><td><pre><code>  li    $at,n
  div   rs,$at
  mfhi  rd</code></pre></td><td>Remainder: <br> Rf[rd] = Rf[rs] % n</td></tr><tr><td>rem</td><td>rd,n</td><td><pre><code>  li    $at,n
  div   rd,$at
  mfhi  rd</code></pre></td><td>Remainder: <br> Rf[rd] = Rf[rd] % n</td></tr><tr><td>remu</td><td>rd,rs,rt</td><td><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  divu  rs,rt
  mfhi  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  divu  rs,rt
  mfhi  rd</code></pre></td></tr></tbody></table></td><td>Remainder unsigned: <br> Rf[rd] = Rf[rs] % Rf[rt]</td></tr><tr><td>remu</td><td>rd,rs,n</td><td><pre><code>  li    $at,n
  divu  rs,$at
  mfhi  rd</code></pre></td><td>Remainder unsigned: <br> Rf[rd] = Rf[rs] % n</td></tr><tr><td>remu</td><td>rd,n</td><td><pre><code>  li    $at,n
  divu  rd,$at
  mfhi  rd</code></pre></td><td>Remainder unsigned: <br> Rf[rd] = Rf[rd] % n</td></tr><tr><td>rol</td><td>rd,rt,rs</td><td><pre><code>  subu  $at,$0,rs
  srlv  $at,rt,$at
  sllv  rd,rt,rs
  or    rd,rd,$at</code></pre></td><td>Rotate left</td></tr><tr><td>rol</td><td>rd,rt,n</td><td><pre><code>  srl   $at,rt,-n
  sll   rd,rt,n
  or    rd,rd,$at</code></pre></td><td>Rotate left</td></tr><tr><td>ror</td><td>rd,rt,rs</td><td><pre><code>  subu  $at,$0,rs
  sllv  $at,rt,$at
  srlv  rd,rt,rs
  or    rd,rd,$at</code></pre></td><td>Rotate right</td></tr><tr><td>ror</td><td>rd,rt,n</td><td><pre><code>  sll   $at,rt,-n
  srl   rd,rt,n
  or    rd,rd,$at</code></pre></td><td>Rotate right</td></tr><tr><td>s.d</td><td>dd,laddress</td><td><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  swc1  dd,laddress&0xFFFF($at)
  swc1  dd+1,laddress&0xFFFF+4($at)</code></pre></td><td>Store double: <br> Mem[laddress] = FpRf[dd]</td></tr><tr><td>s.d</td><td>dd,imm(rs)</td><td><pre><code>  swc1  dd,imm(rs)
  swc1  dd+1,imm+4(rs)</code></pre></td><td>Store double: <br> Mem[RF[Rs] + Offset] = FpRf[dd]</td></tr><tr><td>s.s</td><td>fd,laddress</td><td><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  swc1  fd,laddress&0xFFFF($at)</code></pre></td><td>Store single: <br> Mem[laddress] = FpRf[fd]</td></tr><tr><td>sb</td><td>rd,laddress</td><td><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  sb    rd,laddress&0xFFFF($at)</code></pre></td><td>Store byte (low 8 bits): <br> Mem[laddress] = Rf[rd]</td></tr><tr><td>seq</td><td>rd,rs,rt</td><td><pre><code>  subu  $at,rs,rt
  sltiu rd,$at,1</code></pre></td><td>Set if equal: <br> Rf[rd] = Rf[rs] == Rf[rt]</td></tr><tr><td>sge</td><td>rd,rs,rt</td><td><pre><code>  slt   rd,rs,rt
  slti  rd,rd,1</code></pre></td><td>Set greater than: <br> Rf[rd] = Rf[rs] > Rf[rt]</td></tr><tr><td>sgeu</td><td>rd,rs,rt</td><td><pre><code>  sltu  rd,rs,rt
  slti  rd,rd,1</code></pre></td><td>Set greater than unsigned: <br> Rf[rd] = Rf[rs] > Rf[rt]</td></tr><tr><td>sh</td><td>rd,laddress</td><td><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  sh    rd,laddress&0xFFFF($at)</code></pre></td><td>Store half (low 16 bits): <br> Mem[laddress] = Rf[rd]</td></tr><tr><td>sle</td><td>rd,rs,rt</td><td><pre><code>  slt   rd,rt,rs
  slti  rd,rd,1</code></pre></td><td>Set less than or equal: <br> Rf[rd] = Rf[rs] <= Rf[rt]</td></tr><tr><td>sleu</td><td>rd,rs,rt</td><td><pre><code>  sltu  rd,rt,rs
  slti  rd,rd,1</code></pre></td><td>Set less than or equal unsigned: <br> Rf[rd] = Rf[rs] <= Rf[rt]</td></tr><tr><td>sne</td><td>rd,rs,rt</td><td><pre><code>  subu  $at,rs,rt
  sltu  rd,$0,$at</code></pre></td><td>Set if not equal: <br> Rf[rd] = Rf[rs] != Rf[rt]</td></tr><tr><td>sub</td><td>rt,rs,imm</td><td><pre><code>  addi  rt,rs,-imm</code></pre></td><td>Subtract: <br> Rf[rt] = Rf[rs] - imm</td></tr><tr><td>sub</td><td>rt,imm</td><td><pre><code>  addi  rt,rt,-imm</code></pre></td><td>Subtract: <br> Rf[rt] = Rf[rt] - imm</td></tr><tr><td>subu</td><td>rt,imm</td><td><pre><code>  addiu rt,rt,-imm</code></pre></td><td>Subtract unsigned: <br> Rf[rt] = Rf[rt] - imm</td></tr><tr><td>subu</td><td>rt,rs,imm</td><td><pre><code>  addiu rt,rs,-imm</code></pre></td><td>Subtract unsigned: <br> Rf[rt] = Rf[rs] - imm</td></tr><tr><td>sw</td><td>rd,laddress</td><td><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  sw    rd,laddress&0xFFFF($at)</code></pre></td><td>Store word (full 32 bits): <br> Mem[laddress] = Rf[rd]</td></tr><tr><td>ulh</td><td>rt,imm(rs)</td><td><pre><code>  lb    rt,imm+1(rs)
  lbu   $at,imm(rs)
  sll   rt,rt,8
  or    rt,rt,$at</code></pre></td><td></td></tr><tr><td>ulhu</td><td>rt,imm(rs)</td><td><pre><code>  lbu   rt,imm+1(rs)
  lbu   $at,imm(rs)
  sll   rt,rt,8
  or    rt,rt,$at</code></pre></td><td></td></tr><tr><td>ulw</td><td>rt,imm(rs)</td><td><pre><code>  lwl   rt,imm+3(rs)
  lwr   rt,imm(rs)</code></pre></td><td></td></tr><tr><td>ush</td><td>rt,imm(rs)</td><td><pre><code>  sb    rt,imm(rs)
  srl   $at,rt,8
  sb    $at,imm+1(rs)</code></pre></td><td></td></tr><tr><td>usw</td><td>rt,imm(rs)</td><td><pre><code>  swl   rt,imm+3(rs)
  swr   rt,imm(rs)</code></pre></td><td></td></tr><tr><td>xori</td><td>rt,imm</td><td><pre><code>  xori  rt,rt,imm</code></pre></td><td>Xor immediate: <br> Rf[rt] = Rf[rt] ^ imm</td></tr></tbody></table></div><hr><p><br><br></p><h3 id=full_list_opcodes_macros>Full Listing of All Opcodes and Macros</h3><p>For your convenience, all of the opcodes and macros are repeated here, alphabetized. Many of the opcodes have overloaded macro definitions, which will be invoked based on the arguments you provide. This view is intended to help you to see what those overloads are.</p><div class=table-responsive><table class=table><thead><tr><th>Opcode/Macro Name</th><th>Arguments</th><th>Comment</th><th>Form</th></tr></thead><tbody><tr><td>abs</td><td>rd,rs</td><td>Absolute Value<br><br><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  addu  rd,$0,rs
  bgez  rs,09f
  sub   rd,$0,rs
09:</code></pre></td><td><pre><code>  bgez  rs,09f
  addu  rd,$0,rs
  sub   rd,$0,rs
09:</code></pre></td></tr></tbody></table></td><td></td></tr><tr><td>abs.d</td><td>dd,ds</td><td>Absolute value double: <br> FpRf[dd] = |FpRf[ds]|</td><td>r</td></tr><tr><td>abs.s</td><td>fd,fs</td><td>Absolute value single: <br> FpRf[fd] = |FpRf[fs]|</td><td>r</td></tr><tr><td>acos.d</td><td>dd,ds</td><td>arc cosine double: <br> FpRf[dd] = acos(FpRf[ds])</td><td>r</td></tr><tr><td>acos.s</td><td>fd,fs</td><td>arc cosine single: <br> FpRf[fd] = acos(FpRf[fs])</td><td>r</td></tr><tr><td>acosh.d</td><td>dd,ds</td><td>arc hyperbolic cosine double: <br> FpRf[dd] = acosh(FpRf[ds])</td><td>r</td></tr><tr><td>acosh.s</td><td>fd,fs</td><td>arc hyperbolic cosine single: <br> FpRf[fd] = acosh(FpRf[fs])</td><td>r</td></tr><tr><td>add</td><td>rd,rs,rt</td><td>Add <br> RF[Rd] = RF[Rs] + RF[Rt]</td><td>r</td></tr><tr><td>add</td><td>rt,rs,imm</td><td>Add <br> alias for <strong>addi rt,rs,imm</strong> <br> RF[Rt] = RF[Rs] + Imm</td><td>i</td></tr><tr><td>add.d</td><td>dd,ds,dt</td><td>Add double: <br> FpRf[dd] = FpRf[ds] + FpRf[dt]</td><td>r</td></tr><tr><td>add.s</td><td>fd,fs,ft</td><td>Add single: <br> FpRf[fd] = FpRf[fs] + FpRf[ft]</td><td>r</td></tr><tr><td>addi</td><td>rt,rs,imm</td><td>Add Immediate <br> RF[Rt] = RF[Rs] + Imm</td><td>i</td></tr><tr><td>addi</td><td>rt,imm</td><td>Add immediate: <br> Rf[rt] = Rf[rt] + imm<br><br><pre><code>  addi  rt,rt,imm</code></pre></td><td></td></tr><tr><td>addiu</td><td>rt,rs,imm</td><td>Add Immediate Unsigned <br> RF[Rt] = RF[Rs] + Imm</td><td>i</td></tr><tr><td>addiu</td><td>rt,imm</td><td>Add immediate unsigned: <br> Rf[rt] = Rf[rt] + imm<br><br><pre><code>  addiu rt,rt,imm</code></pre></td><td></td></tr><tr><td>addu</td><td>rd,rs,rt</td><td>Add Unsigned <br> RF[Rd] = RF[Rs] + RF[Rt]</td><td>r</td></tr><tr><td>addu</td><td>rt,rs,imm</td><td>Add Unsigned <br> alias for <strong>addiu rt,rs,imm</strong> <br> RF[Rt] = RF[Rs] + imm</td><td>i</td></tr><tr><td>and</td><td>rd,rs,rt</td><td>Bitwise And <br> RF[Rd] = RF[Rs] & RF[Rt]</td><td>r</td></tr><tr><td>andi</td><td>rt,rs,imm</td><td>Bitwise And Immediate <br> RF[Rt] = RF[Rs] & Imm</td><td>i</td></tr><tr><td>andi</td><td>rt,imm</td><td>And immediate: <br> Rf[rt] = Rf[rt] & imm<br><br><pre><code>  andi  rt,rt,imm</code></pre></td><td></td></tr><tr><td>asin.d</td><td>dd,ds</td><td>arc sine double: <br> FpRf[dd] = asin(FpRf[ds])</td><td>r</td></tr><tr><td>asin.s</td><td>fd,fs</td><td>arc sine single: <br> FpRf[fd] = asin(FpRf[fs])</td><td>r</td></tr><tr><td>asinh.d</td><td>dd,ds</td><td>arc hyperbolic sine double: <br> FpRf[dd] = asinh(FpRf[ds])</td><td>r</td></tr><tr><td>asinh.s</td><td>fd,fs</td><td>arc hyperbolic sine single: <br> FpRf[fd] = asinh(FpRf[fs])</td><td>r</td></tr><tr><td>atan.d</td><td>dd,ds</td><td>arc tangent double: <br> FpRf[dd] = atan(FpRf[ds])</td><td>r</td></tr><tr><td>atan.s</td><td>fd,fs</td><td>arc tangent single: <br> FpRf[fd] = atan(FpRf[fs])</td><td>r</td></tr><tr><td>atan2.d</td><td>dd,ds,dt</td><td>arc tangent of y,x double: <br> FpRf[dd] = atan2(FpRf[ds],FpRf[dt])</td><td>r</td></tr><tr><td>atan2.s</td><td>fd,fs,ft</td><td>arc tangent of y,x single: <br> FpRf[fd] = atan2(FpRf[fs],FpRf[ft])</td><td>r</td></tr><tr><td>atanh.d</td><td>dd,ds</td><td>arc hyperbolic tangent double: <br> FpRf[dd] = atanh(FpRf[ds])</td><td>r</td></tr><tr><td>atanh.s</td><td>fd,fs</td><td>arc hyperbolic tangent single: <br> FpRf[fd] = atanh(FpRf[fs])</td><td>r</td></tr><tr><td>b</td><td>label</td><td>Branch <br> alias for <strong>bgez $0,label</strong> <br> PC = label</td><td>i</td></tr><tr><td>bc0f</td><td>label</td><td>Branch Coprocessor0 True <br> This is a do nothing. It used to test a pin on the part.</td><td>i</td></tr><tr><td>bc0t</td><td>label</td><td>Branch Coprocessor0 False <br> This is a do nothing. It used to test a pin on the part.</td><td>i</td></tr><tr><td>bc1f</td><td>label</td><td>branch if status flag is false</td><td>i</td></tr><tr><td>bc1t</td><td>label</td><td>branch if status flag is true</td><td>i</td></tr><tr><td>beq</td><td>rs,rt,label</td><td>Branch Equal <br> If (RF[Rs] == RF[Rt] )then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>beq</td><td>rs,imm,label</td><td>Branch equal to <br> If (RF[Rs] == Imm) then branch to Label<br><br><pre><code>  li    $at,imm
  beq   rs,$at,label</code></pre></td><td></td></tr><tr><td>beqz</td><td>rs,label</td><td>Branch Equal to Zero <br> alias for <strong>beq rs,$0,label</strong> <br> If (RF[Rs] == 0) then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>bge</td><td>rs,rt,label</td><td>Branch greater than or equal to <br> If (RF[Rs] >= Rf[Rt]) then branch to Label<br><br><pre><code>  slt   $at,rs,rt
  beq   $at,$0,label</code></pre></td><td></td></tr><tr><td>bge</td><td>rs,imm,label</td><td>Branch greater than or equal to <br> If (RF[Rs] >= Imm) then branch to Label<br><br><pre><code>  li    $at,imm
  slt   $at,rs,$at
  beq   $at,$0,label</code></pre></td><td></td></tr><tr><td>bgeu</td><td>rs,rt,label</td><td>Branch greater than or equal to (Unsigned) <br> If (RF[Rs] >= Rf[Rt]) then branch to Label<br><br><pre><code>  sltu  $at,rs,rt
  beq   $at,$0,label</code></pre></td><td></td></tr><tr><td>bgeu</td><td>rs,imm,label</td><td>Branch greater than or equal to (Unsigned) <br> If (RF[Rs] >= Imm) then branch to Label<br><br><pre><code>  li    $at,imm
  sltu  $at,rs,$at
  beq   $at,$0,label</code></pre></td><td></td></tr><tr><td>bgez</td><td>rs,label</td><td>Branch Greater than or Equal to Zero <br> If (RF[Rs] >= RF[0]) then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>bgezal</td><td>rs,label</td><td>Branch Greater than or Equal to Zero And Link <br> If ( RF[Rs] >= RF[0] ) then {RF[$ra] = PC; PC = PC + Imm<< 2 }</td><td>i</td></tr><tr><td>bgt</td><td>rs,rt,label</td><td>Branch greater than <br> If (RF[Rs] > Rf[Rt]) then branch to Label<br><br><pre><code>  slt   $at,rt,rs
  bne   $at,$0,label</code></pre></td><td></td></tr><tr><td>bgt</td><td>rs,imm,label</td><td>Branch greater than <br> If (RF[Rs] > Imm) then branch to Label<br><br><pre><code>  li    $at,imm
  slt   $at,$at,rs
  bne   $at,$0,label</code></pre></td><td></td></tr><tr><td>bgtu</td><td>rs,rt,label</td><td>Branch greater than (Unsigned) <br> If (RF[Rs] > Rf[Rt]) then branch to Label<br><br><pre><code>  sltu  $at,rt,rs
  bne   $at,$0,label</code></pre></td><td></td></tr><tr><td>bgtu</td><td>rs,imm,label</td><td>Branch greater than (Unsigned) <br> If (RF[Rs] > Imm) then branch to Label<br><br><pre><code>  li    $at,imm
  sltu  $at,$at,rs
  bne   $at,$0,label</code></pre></td><td></td></tr><tr><td>bgtz</td><td>rs,label</td><td>Branch Greater Than Zero <br> If (RF[Rs] > RF[0] ) then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>ble</td><td>rs,rt,label</td><td>Branch less than or equal to <br> If (RF[Rs] <= Rf[Rt]) then branch to Label<br><br><pre><code>  slt   $at,rt,rs
  beq   $at,$0,label</code></pre></td><td></td></tr><tr><td>ble</td><td>rs,imm,label</td><td>Branch less than or equal to <br> If (RF[Rs] <= Imm) then branch to Label<br><br><pre><code>  li    $at,imm
  slt   $at,$at,rs
  beq   $at,$0,label</code></pre></td><td></td></tr><tr><td>bleu</td><td>rs,rt,label</td><td>Branch less than or equal to (Unsigned) <br> If (RF[Rs] <= Rf[Rt]) then branch to Label<br><br><pre><code>  sltu  $at,rt,rs
  beq   $at,$0,label</code></pre></td><td></td></tr><tr><td>bleu</td><td>rs,imm,label</td><td>Branch less than or equal to (Unsigned) <br> If (RF[Rs] <= Imm) then branch to Label<br><br><pre><code>  li    $at,imm
  sltu  $at,$at,rs
  beq   $at,$0,label</code></pre></td><td></td></tr><tr><td>blez</td><td>rs,label</td><td>Branch Less than or Equal to Zero <br> If (RF[Rs] <= RF[0]) then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>blt</td><td>rs,rt,label</td><td>Branch less than <br> If (RF[Rs] < Rf[Rt]) then branch to Label<br><br><pre><code>  slt   $at,rs,rt
  bne   $at,$0,label</code></pre></td><td></td></tr><tr><td>blt</td><td>rs,imm,label</td><td>Branch less than <br> If (RF[Rs] < Imm) then branch to Label<br><br><pre><code>  li    $at,imm
  slt   $at,rs,$at
  bne   $at,$0,label</code></pre></td><td></td></tr><tr><td>bltu</td><td>rs,rt,label</td><td>Branch less than (Unsigned) <br> If (RF[Rs] < Rf[Rt]) then branch to Label<br><br><pre><code>  sltu  $at,rs,rt
  bne   $at,$0,label</code></pre></td><td></td></tr><tr><td>bltu</td><td>rs,imm,label</td><td>Branch less than (Unsigned) <br> If (RF[Rs] < Imm) then branch to Label<br><br><pre><code>  li    $at,imm
  sltu  $at,rs,$at
  bne   $at,$0,label</code></pre></td><td></td></tr><tr><td>bltz</td><td>rs,label</td><td>Branch Less Than Zero <br> If RF[Rs] < RF[0] then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>bltzal</td><td>rs,label</td><td>Branch Less Than Zero And Link <br> If ( RF[Rs] < RF[0] ) then {RF[$ra] = PC; PC = PC + Imm<< 2 }</td><td>i</td></tr><tr><td>bne</td><td>rs,rt,label</td><td>Branch Not Equal <br> If RF[Rs] != RF[Rt] then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>bne</td><td>rs,imm,label</td><td>Branch not equal <br> If (RF[Rs] != Imm) then branch to Label<br><br><pre><code>  li    $at,imm
  bne   rs,$at,label</code></pre></td><td></td></tr><tr><td>bnez</td><td>rs,label</td><td>Branch Not Equal to Zero <br> alias for <strong>bne rs,$0,label</strong> <br> If RF[Rs] != 0 then PC = PC + Imm<< 2</td><td>i</td></tr><tr><td>break</td><td>icode</td><td>pause execution</td><td>b</td></tr><tr><td>break</td><td>rcode</td><td>pause execution</td><td>b</td></tr><tr><td>break</td><td></td><td>pause execution <br> alias for <strong>break 0</strong></td><td>b</td></tr><tr><td>c.eq.d</td><td>ds,dt</td><td>Compare Equal Doubles: <br> ControlRf[31].condition_bit = FpRf[dt] == FpRf[ds] && !(un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.eq.s</td><td>fs,ft</td><td>Compare Equal Singles: <br> ControlRf[31].condition_bit = FpRf[ft] == FpRf[fs] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.f.d</td><td>ds,dt</td><td>Compare False: <br> ControlRf[31].condition_bit = 0</td><td>r</td></tr><tr><td>c.f.s</td><td>fs,ft</td><td>Compare False: <br> ControlRf[31].condition_bit = 0</td><td>r</td></tr><tr><td>c.le.d</td><td>ds,dt</td><td>Compare Less Than or Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.le.s</td><td>fs,ft</td><td>Compare Less Than or Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.lt.d</td><td>ds,dt</td><td>Compare Less Than: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.lt.s</td><td>fs,ft</td><td>Compare Less Than: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.nge.d</td><td>ds,dt</td><td>Compare Not Greater or Equal, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] || (un(FpRf[ds]) || un(FpRf[dt]))</td><td>r</td></tr><tr><td>c.nge.s</td><td>fs,ft</td><td>Compare Not Greater or Equal, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] || (un(FpRf[fs]) || un(FpRf[ft]))</td><td>r</td></tr><tr><td>c.ngl.d</td><td>ds,dt</td><td>Compare Not Greater or Less Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] == FpRf[dt] || (un(FpRf[ds]) || un(FpRf[dt]))</td><td>r</td></tr><tr><td>c.ngl.s</td><td>fs,ft</td><td>Compare Not Greater or Less Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] == FpRf[ft] || (un(FpRf[fs]) || un(FpRf[ft]))</td><td>r</td></tr><tr><td>c.ngle.d</td><td>ds,dt</td><td>Compare Not Greater, Less, or Equal (only true if unordered): <br> exception if unordered; <br> ControlRf[31].condition_bit = (un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.ngle.s</td><td>fs,ft</td><td>Compare Not Greater, Less, or Equal (only true if unordered): <br> exception if unordered; <br> ControlRf[31].condition_bit = (un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.ngt.d</td><td>ds,dt</td><td>Compare Not Greater Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] || (un(FpRf[fs]) || un(FpRf[ft]))</td><td>r</td></tr><tr><td>c.ngt.s</td><td>fs,ft</td><td>Compare Not Greater Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] || (un(FpRf[fs]) || un(FpRf[ft]))</td><td>r</td></tr><tr><td>c.ole.d</td><td>ds,dt</td><td>Compare Ordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.ole.s</td><td>fs,ft</td><td>Compare Ordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.olt.d</td><td>ds,dt</td><td>Compare Ordered Less Than: <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.olt.s</td><td>fs,ft</td><td>Compare Ordered Less Than: <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.seq.d</td><td>ds,dt</td><td>Compare Signaling Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] == FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.seq.s</td><td>fs,ft</td><td>Compare Signaling Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] == FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.sf.d</td><td>ds,dt</td><td>Compare Signaling False: <br> exception if unordered; <br> ControlRf[31].condition_bit = 0</td><td>r</td></tr><tr><td>c.sf.s</td><td>fs,ft</td><td>Compare Signaling False: <br> exception if unordered; <br> ControlRf[31].condition_bit = 0</td><td>r</td></tr><tr><td>c.ueq.d</td><td>ds,dt</td><td>Compare Unordered/Equal Doubles: <br> ControlRf[31].condition_bit = (FpRf[dt] == FpRf[ds]) || (un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.ueq.s</td><td>fs,ft</td><td>Compare Unordered/Equal Singles: <br> ControlRf[31].condition_bit = (FpRf[ft] == FpRf[fs]) || (un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.ule.d</td><td>ds,dt</td><td>Compare Unordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] || (un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.ule.s</td><td>fs,ft</td><td>Compare Unordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] || (un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.ult.d</td><td>ds,dt</td><td>Compare Unordered Less Than: <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] || (un(FpRf[dt]) || un(FpRf[ds]))</td><td>r</td></tr><tr><td>c.ult.s</td><td>fs,ft</td><td>Compare Unordered Less Than: <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] || (un(FpRf[ft]) || un(FpRf[fs]))</td><td>r</td></tr><tr><td>c.un.d</td><td>ds,dt</td><td>Compare Unordered Doubles: <br> ControlRf[31].condition_bit = un(FpRf[dt]) || un(FpRf[ds])</td><td>r</td></tr><tr><td>c.un.s</td><td>fs,ft</td><td>Compare Unordered Singles: <br> ControlRf[31].condition_bit = un(FpRf[ft]) || un(FpRf[fs])</td><td>r</td></tr><tr><td>ceil.d</td><td>dd,ds</td><td>ceiling double: <br> FpRf[dd] = ceil(FpRf[ds])</td><td>r</td></tr><tr><td>ceil.s</td><td>fd,fs</td><td>ceiling single: <br> FpRf[fd] = ceil(FpRf[fs])</td><td>r</td></tr><tr><td>cfc1</td><td>rt,Cs</td><td>move control word from cop1: <br> Rf[rt] = ControlRf[Cs]</td><td>r</td></tr><tr><td>cos.d</td><td>dd,ds</td><td>cosine double: <br> FpRf[dd] = cos(FpRf[ds])</td><td>r</td></tr><tr><td>cos.s</td><td>fd,fs</td><td>cosine single: <br> FpRf[fd] = cos(FpRf[fs])</td><td>r</td></tr><tr><td>cosh.d</td><td>dd,ds</td><td>hyperbolic cosine double: <br> FpRf[dd] = cosh(FpRf[ds])</td><td>r</td></tr><tr><td>cosh.s</td><td>fd,fs</td><td>hyperbolic cosine single: <br> FpRf[fd] = cosh(FpRf[fs])</td><td>r</td></tr><tr><td>ctc1</td><td>rt,Cs</td><td>move control word to cop1: <br> ControlRf[Cs] = Rf[rt]</td><td>r</td></tr><tr><td>cvt.d.s</td><td>dd,fs</td><td>Convert single to double: <br> FpRf[dd] = (double) FpRf[fs]</td><td>r</td></tr><tr><td>cvt.d.w</td><td>dd,fs</td><td>Convert integer to double: <br> FpRf[dd] = (double) FpRf[fs]</td><td>r</td></tr><tr><td>cvt.s.d</td><td>fd,ds</td><td>Convert double to single: <br> FpRf[fd] = (float) FpRf[ds]</td><td>r</td></tr><tr><td>cvt.s.w</td><td>fd,fs</td><td>Convert integer to single: <br> FpRf[fd] = (float) FpRf[fs]</td><td>r</td></tr><tr><td>cvt.w.d</td><td>fd,ds</td><td>Convert double to integer: <br> FpRf[fd] = (int) FpRf[ds]</td><td>r</td></tr><tr><td>cvt.w.s</td><td>fd,fs</td><td>Convert single to integer: <br> FpRf[fd] = (int) FpRf[fs]</td><td>r</td></tr><tr><td>div</td><td>rs,rt</td><td>Divide (signed) <br> Low = Quotient ( RF[Rs] / RF[Rt] ); <br> High = Remainder ( RF[Rs] / RF[Rt] )</td><td>r</td></tr><tr><td>div</td><td>rd,rs,rt</td><td>Divide: <br> Rf[rd] = Rf[rs]/Rf[rt] <br> (break on divide by zero)<br><br><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  div   rs,rt
  mflo  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  div   rs,rt
  mflo  rd</code></pre></td></tr></tbody></table></td><td></td></tr><tr><td>div</td><td>rd,rs,n</td><td>Divide: <br> Rf[rd] = Rf[rs]/n<br><br><pre><code>  li    $at,n
  div   rs,$at
  mflo  rd</code></pre></td><td></td></tr><tr><td>div</td><td>rd,n</td><td>Divide: <br> Rf[rd] = Rf[rd]/n<br><br><pre><code>  li    $at,n
  div   rd,$at
  mflo  rd</code></pre></td><td></td></tr><tr><td>div.d</td><td>dd,ds,dt</td><td>Divide double: <br> FpRf[dd] = FpRf[ds] / FpRf[dt]</td><td>r</td></tr><tr><td>div.s</td><td>fd,fs,ft</td><td>Divide single: <br> FpRf[fd] = FpRf[fs] / FpRf[ft]</td><td>r</td></tr><tr><td>divu</td><td>rs,rt</td><td>Divide Unsigned <br> Low = Quotient ( RF[Rs] / RF[Rt] ); <br> High = Remainder ( RF[Rs] / RF[Rt] )</td><td>r</td></tr><tr><td>divu</td><td>rd,rs,rt</td><td>Divide unsigned: <br> Rf[rd] = Rf[rs] / Rf[rt] <br> (break on divide by zero)<br><br><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  divu  rs,rt
  mflo  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  divu  rs,rt
  mflo  rd</code></pre></td></tr></tbody></table></td><td></td></tr><tr><td>divu</td><td>rd,rs,n</td><td>Divide unsigned: <br> Rf[rd] = Rf[rs] / n<br><br><pre><code>  li    $at,n
  divu  rs,$at
  mflo  rd</code></pre></td><td></td></tr><tr><td>divu</td><td>rd,n</td><td>Divide unsigned: <br> Rf[rd] = Rf[rd] / n<br><br><pre><code>  li    $at,n
  divu  rd,$at
  mflo  rd</code></pre></td><td></td></tr><tr><td>exp.d</td><td>dd,ds</td><td>e to the x power double: <br> FpRf[dd] = exp(FpRf[ds])</td><td>r</td></tr><tr><td>exp.s</td><td>fd,fs</td><td>e to the x power single: <br> FpRf[fd] = exp(FpRf[fs])</td><td>r</td></tr><tr><td>floor.d</td><td>dd,ds</td><td>floor double: <br> FpRf[dd] = floor(FpRf[ds])</td><td>r</td></tr><tr><td>floor.s</td><td>fd,fs</td><td>floor single: <br> FpRf[fd] = floor(FpRf[fs])</td><td>r</td></tr><tr><td>j</td><td>label</td><td>Jump <br> PC = PC(31:28) | Imm<< 2</td><td>j</td></tr><tr><td>jal</td><td>label</td><td>Jump And Link <br> RF[$ra] = PC; <br> PC = PC(31:28) | Imm<< 2</td><td>j</td></tr><tr><td>jalr</td><td>rd,rs</td><td>Jump And Link Register <br> RF[Rd] = PC; <br> PC = RF[Rs]</td><td>r</td></tr><tr><td>jalr</td><td>rs</td><td>Jump And Link Register <br> alias for <strong>jalr $ra,rs</strong> <br> $ra = PC; <br> PC = RF[Rs]</td><td>r</td></tr><tr><td>jr</td><td>rs</td><td>Jump Register <br> PC = RF[Rs]</td><td>r</td></tr><tr><td>l.d</td><td>dd,laddress</td><td>Load double: <br> FpRf[dd] = laddress<br><br><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lwc1  dd,laddress&0xFFFF($at)
  lwc1  dd+1,laddress&0xFFFF+4($at)</code></pre></td><td></td></tr><tr><td>l.d</td><td>dd,imm(rs)</td><td>Load double: <br> FpRf[dd] = Mem[RF[Rs] + Offset]<br><br><pre><code>  lwc1  dd,imm(rs)
  lwc1  dd+1,imm+4(rs)</code></pre></td><td></td></tr><tr><td>l.s</td><td>ft,imm(rs)</td><td>load word to cop1: <br> FpRf[ft] = Mem[Rf[rs] + Offset]</td><td>i</td></tr><tr><td>l.s</td><td>fd,laddress</td><td>Load single: <br> FpRf[fd] = laddress<br><br><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lwc1  fd,laddress&0xFFFF($at)</code></pre></td><td></td></tr><tr><td>la</td><td>rd,laddress</td><td>Load Address into Rf[rd]<br><br><pre><code>  lui   rd,laddress>>16
  ori   rd,rd,laddress&0xffff</code></pre></td><td></td></tr><tr><td>lb</td><td>rt,imm(rs)</td><td>Load Byte <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>lb</td><td>rd,laddress</td><td>Load byte (low 8 bits): <br> Rf[rd] = Mem[laddress]<br><br><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lb    rd,laddress&0xFFFF($at)</code></pre></td><td></td></tr><tr><td>lbu</td><td>rt,imm(rs)</td><td>Load Byte Unsigned <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>lbu</td><td>rd,laddress</td><td>Load byte unsigned (low 8 bits): <br> Rf[rd] = Mem[laddress]<br><br><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lbu   rd,laddress&0xFFFF($at)</code></pre></td><td></td></tr><tr><td>lh</td><td>rt,imm(rs)</td><td>Load Half <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>lh</td><td>rd,laddress</td><td>Load half (low 16 bits): <br> Rf[rd] = Mem[laddress]<br><br><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lh    rd,laddress&0xFFFF($at)</code></pre></td><td></td></tr><tr><td>lhu</td><td>rt,imm(rs)</td><td>Load Half Unsigned <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>lhu</td><td>rd,laddress</td><td>Load half unsigned (low 16 bits): <br> Rf[rd] = Mem[laddress]<br><br><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lhu   rd,laddress&0xFFFF($at)</code></pre></td><td></td></tr><tr><td>li</td><td>rd,imm</td><td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when the high 16 bits of imm are empty.<br><br><pre><code>ori   rd,$0,imm</code></pre></td><td></td></tr><tr><td>li</td><td>rd,imm</td><td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when the low 16 bits of imm are empty.<br><br><pre><code>lui   rd,imm</code></pre></td><td></td></tr><tr><td>li</td><td>rd,imm</td><td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when the high 17 bits of imm are 1 (it's a small negative number).<br><br><pre><code>addi   rd,$0,imm</code></pre></td><td></td></tr><tr><td>li</td><td>rd,imm</td><td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when none of the three other forms can be used.<br><br><pre><code>lui   rd,imm
ori   rd,$0,imm</code></pre></td><td></td></tr><tr><td>ll</td><td>rt,imm(rs)</td><td>Load Linked <br> Unimplemented</td><td>i</td></tr><tr><td>ln.d</td><td>dd,ds</td><td>natural log double: <br> FpRf[dd] = ln(FpRf[ds])</td><td>r</td></tr><tr><td>ln.s</td><td>fd,fs</td><td>natural log single: <br> FpRf[fd] = ln(FpRf[fs])</td><td>r</td></tr><tr><td>lui</td><td>rt,imm</td><td>Load Upper Immediate <br> RF[Rt] = Imm<<16</td><td>i</td></tr><tr><td>lw</td><td>rt,imm(rs)</td><td>Load Word <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>lw</td><td>rd,laddress</td><td>Load word (full 32 bits): <br> Rf[rd] = Mem[laddress]<br><br><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lw    rd,laddress&0xFFFF($at)</code></pre></td><td></td></tr><tr><td>lwc1</td><td>ft,imm(rs)</td><td>load word to cop1: <br> FpRf[ft] = Mem[Rf[rs] + Offset]</td><td>i</td></tr><tr><td>lwc2</td><td>rt,imm(rs)</td><td>load word to cop2: <br> Unimplemented</td><td>i</td></tr><tr><td>lwc3</td><td>rt,imm(rs)</td><td>load word to cop3: <br> Unimplemented</td><td>i</td></tr><tr><td>lwl</td><td>rt,imm(rs)</td><td>Load Word Left <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>lwr</td><td>rt,imm(rs)</td><td>Load Word Right <br> RF[Rt] = Mem[RF[Rs] + Offset]</td><td>i</td></tr><tr><td>mfc0</td><td>rt,cd</td><td>Move From Coprocessor0: <br> Rf[rt] = CP0Rf[cd]</td><td>r</td></tr><tr><td>mfc1</td><td>rt,fs</td><td>move from cop1: <br> Rf[rt] = FpRf[fs]</td><td>r</td></tr><tr><td>mfhi</td><td>rd</td><td>Move From Hi <br> RF[Rd] = HIGH</td><td>r</td></tr><tr><td>mflo</td><td>rd</td><td>Move From Low <br> RF[Rd] = LOW</td><td>r</td></tr><tr><td>mov</td><td>rd,rs</td><td>Move <br> alias for <strong>addu rd,rs,$0</strong> <br> RF[Rd] = RF[Rs]</td><td>r</td></tr><tr><td>mov.d</td><td>dd,ds</td><td>Copy double value: <br> FpRf[dd] = FpRf[ds]</td><td>r</td></tr><tr><td>mov.s</td><td>fd,fs</td><td>Copy single value: <br> FpRf[fd] = FpRf[fs]</td><td>r</td></tr><tr><td>move</td><td>rd,rs</td><td>Move <br> alias for <strong>addu rd,rs,$0</strong> <br> RF[Rd] = RF[Rs]</td><td>r</td></tr><tr><td>mtc0</td><td><strong>rt,cd</strong></td><td>Move To Coprocessor0: <br> CP0Rf[cd] = Rf[rt] <br> <strong>Backwards Arguments!</strong></td><td>r</td></tr><tr><td>mtc1</td><td>rt,fs</td><td>move to cop1: <br> FpRf[fs] = Rf[rt]</td><td>r</td></tr><tr><td>mthi</td><td>rs</td><td>Move To Hi <br> HIGH = RF[Rs]</td><td>r</td></tr><tr><td>mtlo</td><td>rs</td><td>Move To Low <br> LOW = RF[Rs]</td><td>r</td></tr><tr><td>mul</td><td>rd,rs,rt</td><td>Multiply: <br> Rf[rd] = Rf[rs] * Rf[rt]<br><br><pre><code>  mult  rs,rt
  mflo  rd</code></pre></td><td></td></tr><tr><td>mul</td><td>rd,rs,n</td><td>Multiply: <br> Rf[rd] = Rf[rs]*n<br><br><pre><code>  li    $at,n
  mult  rs,$at
  mflo  rd</code></pre></td><td></td></tr><tr><td>mul</td><td>rd,n</td><td>Multiply: <br> Rf[rd] = Rf[rd]*n<br><br><pre><code>  li    $at,n
  mult  rd,$at
  mflo  rd</code></pre></td><td></td></tr><tr><td>mul.d</td><td>dd,ds,dt</td><td>Multiply double: <br> FpRf[dd] = FpRf[ds] * FpRf[dt]</td><td>r</td></tr><tr><td>mul.s</td><td>fd,fs,ft</td><td>Multiply single: <br> FpRf[fd] = FpRf[fs] * FpRf[ft]</td><td>r</td></tr><tr><td>mulo</td><td>rd,rs,rt</td><td>Multiply, break on overflow<br><br><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  mult  rs,rt
  mfhi  $at
  mflo  rd
  sra   rd,rd,31
  beq   $at,rd,08f
  break
08:
  mflo  rd</code></pre></td><td><pre><code>  mult  rs,rt
  mfhi  $at
  mflo  rd
  sra   rd,rd,31
  beq   $at,rd,08f
  mflo  rd
  break
08:</code></pre></td></tr></tbody></table></td><td></td></tr><tr><td>mulou</td><td>rd,rs,rt</td><td>Multiply unsigned, break on overflow<br><br><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  multu rs,rt
  mfhi  $at
  beq   $at,$0,08f
  break
08:
  mflo  rd</code></pre></td><td><pre><code>  multu rs,rt
  mfhi  $at
  beq   $at,$0,08f
  mflo  rd
  break
08:</code></pre></td></tr></tbody></table></td><td></td></tr><tr><td>mult</td><td>rs,rt</td><td>Multiply (signed) <br> High |Low = RF[Rs] * RF[Rt]</td><td>r</td></tr><tr><td>multu</td><td>rs,rt</td><td>Multiply Unsigned <br> High |Low = RF[Rs] * RF[Rt]</td><td>r</td></tr><tr><td>mulu</td><td>rd,rs,rt</td><td>Multiply unsigned: <br> Rf[rd] = Rf[rs] * Rf[rt]<br><br><pre><code>  multu rs,rt
  mflo  rd</code></pre></td><td></td></tr><tr><td>mulu</td><td>rd,rs,n</td><td>Multiply unsigned: <br> Rf[rd] = Rf[rs] * n<br><br><pre><code>  li    $at,n
  multu rs,$at
  mflo  rd</code></pre></td><td></td></tr><tr><td>mulu</td><td>rd,n</td><td>Multiply unsigned: <br> Rf[rd] = Rf[rd] * n<br><br><pre><code>  li    $at,n
  multu rd,$at
  mflo  rd</code></pre></td><td></td></tr><tr><td>neg</td><td>rd,rt</td><td>Negate <br> alias for <strong>sub rd,$0,rt</strong> <br> RF[Rd] = -RF[Rt]</td><td>r</td></tr><tr><td>neg.d</td><td>dd,ds</td><td>Negate double value: <br> FpRf[dd] = -FpRf[ds]</td><td>r</td></tr><tr><td>neg.s</td><td>fd,fs</td><td>Negate single value: <br> FpRf[fd] = -FpRf[fs]</td><td>r</td></tr><tr><td>negu</td><td>rd,rt</td><td>Negate <br> alias for <strong>subu rd,$0,rt</strong> <br> RF[Rd] = -RF[Rt]</td><td>r</td></tr><tr><td>nop</td><td></td><td>no operation <br> alias for <strong>sll $0,$0,0</strong></td><td>r</td></tr><tr><td>nor</td><td>rd,rs,rt</td><td>Bitwise Nor <br> RF[Rd] = !(RF[Rs] | RF[Rt])</td><td>r</td></tr><tr><td>not</td><td>rd,rs</td><td>Boolean Not <br> alias for <strong>nor rd,rs,$0</strong> <br> RF[Rd] = !(RF[Rs] | 0)</td><td>r</td></tr><tr><td>or</td><td>rd,rs,rt</td><td>Bitwise Or <br> RF[Rd] = RF[Rs] | RF[Rt]</td><td>r</td></tr><tr><td>ori</td><td>rt,rs,imm</td><td>Bitwise Or Immediate <br> RF[Rt] = RF[Rs] | Imm</td><td>i</td></tr><tr><td>ori</td><td>rt,imm</td><td>Or immediate: <br> Rf[rt] = Rf[rt] | imm<br><br><pre><code>  ori   rt,rt,imm</code></pre></td><td></td></tr><tr><td>rem</td><td>rd,rs,rt</td><td>Remainder: <br> Rf[rd] = Rf[rs] % Rf[rt]<br><br><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  div   rs,rt
  mfhi  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  div   rs,rt
  mfhi  rd</code></pre></td></tr></tbody></table></td><td></td></tr><tr><td>rem</td><td>rd,rs,n</td><td>Remainder: <br> Rf[rd] = Rf[rs] % n<br><br><pre><code>  li    $at,n
  div   rs,$at
  mfhi  rd</code></pre></td><td></td></tr><tr><td>rem</td><td>rd,n</td><td>Remainder: <br> Rf[rd] = Rf[rd] % n<br><br><pre><code>  li    $at,n
  div   rd,$at
  mfhi  rd</code></pre></td><td></td></tr><tr><td>remu</td><td>rd,rs,rt</td><td>Remainder unsigned: <br> Rf[rd] = Rf[rs] % Rf[rt]<br><br><table class=table><thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead><tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  divu  rs,rt
  mfhi  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  divu  rs,rt
  mfhi  rd</code></pre></td></tr></tbody></table></td><td></td></tr><tr><td>remu</td><td>rd,rs,n</td><td>Remainder unsigned: <br> Rf[rd] = Rf[rs] % n<br><br><pre><code>  li    $at,n
  divu  rs,$at
  mfhi  rd</code></pre></td><td></td></tr><tr><td>remu</td><td>rd,n</td><td>Remainder unsigned: <br> Rf[rd] = Rf[rd] % n<br><br><pre><code>  li    $at,n
  divu  rd,$at
  mfhi  rd</code></pre></td><td></td></tr><tr><td>rfe</td><td></td><td>Restore From Exception <br>restores the status register to its value before the last exception occurred.</td><td>r</td></tr><tr><td>rol</td><td>rd,rt,rs</td><td>Rotate left<br><br><pre><code>  subu  $at,$0,rs
  srlv  $at,rt,$at
  sllv  rd,rt,rs
  or    rd,rd,$at</code></pre></td><td></td></tr><tr><td>rol</td><td>rd,rt,n</td><td>Rotate left<br><br><pre><code>  srl   $at,rt,-n
  sll   rd,rt,n
  or    rd,rd,$at</code></pre></td><td></td></tr><tr><td>ror</td><td>rd,rt,rs</td><td>Rotate right<br><br><pre><code>  subu  $at,$0,rs
  sllv  $at,rt,$at
  srlv  rd,rt,rs
  or    rd,rd,$at</code></pre></td><td></td></tr><tr><td>ror</td><td>rd,rt,n</td><td>Rotate right<br><br><pre><code>  sll   $at,rt,-n
  srl   rd,rt,n
  or    rd,rd,$at</code></pre></td><td></td></tr><tr><td>round.d</td><td>dd,ds</td><td>round double: <br> FpRf[dd] = round(FpRf[ds])</td><td>r</td></tr><tr><td>round.s</td><td>fd,fs</td><td>round single: <br> FpRf[fd] = round(FpRf[fs])</td><td>r</td></tr><tr><td>s.d</td><td>dd,laddress</td><td>Store double: <br> Mem[laddress] = FpRf[dd]<br><br><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  swc1  dd,laddress&0xFFFF($at)
  swc1  dd+1,laddress&0xFFFF+4($at)</code></pre></td><td></td></tr><tr><td>s.d</td><td>dd,imm(rs)</td><td>Store double: <br> Mem[RF[Rs] + Offset] = FpRf[dd]<br><br><pre><code>  swc1  dd,imm(rs)
  swc1  dd+1,imm+4(rs)</code></pre></td><td></td></tr><tr><td>s.s</td><td>ft,imm(rs)</td><td>store word from cop1: <br> Mem[Rf[rs] + Offset] = FpRf[ft]</td><td>i</td></tr><tr><td>s.s</td><td>fd,laddress</td><td>Store single: <br> Mem[laddress] = FpRf[fd]<br><br><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  swc1  fd,laddress&0xFFFF($at)</code></pre></td><td></td></tr><tr><td>sb</td><td><strong>rt,imm(rs)</strong></td><td>Store Byte: <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td><td>i</td></tr><tr><td>sb</td><td>rd,laddress</td><td>Store byte (low 8 bits): <br> Mem[laddress] = Rf[rd]<br><br><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  sb    rd,laddress&0xFFFF($at)</code></pre></td><td></td></tr><tr><td>sc</td><td>rt,imm(rs)</td><td>Unimplemented</td><td>i</td></tr><tr><td>seq</td><td>rd,rs,rt</td><td>Set if equal: <br> Rf[rd] = Rf[rs] == Rf[rt]<br><br><pre><code>  subu  $at,rs,rt
  sltiu rd,$at,1</code></pre></td><td></td></tr><tr><td>sge</td><td>rd,rs,rt</td><td>Set greater than: <br> Rf[rd] = Rf[rs] > Rf[rt]<br><br><pre><code>  slt   rd,rs,rt
  slti  rd,rd,1</code></pre></td><td></td></tr><tr><td>sgeu</td><td>rd,rs,rt</td><td>Set greater than unsigned: <br> Rf[rd] = Rf[rs] > Rf[rt]<br><br><pre><code>  sltu  rd,rs,rt
  slti  rd,rd,1</code></pre></td><td></td></tr><tr><td>sgt</td><td>rd,rt,rs</td><td>Set Greater Than <br> alias for <strong>slt rd,rs,rt</strong> <br> if (RF[Rt] > RF[Rs] ) then RF[Rd] =1 else RF[Rd] = 0</td><td>r</td></tr><tr><td>sgtu</td><td>rd,rt,rs</td><td>Set Greater Than Unsigned <br> alias for <strong>sltu rd,rs,rt</strong> <br> if (RF[Rt] > RF[Rs] ) then RF[Rd] =1 else RF[Rd] = 0</td><td>r</td></tr><tr><td>sh</td><td><strong>rt,imm(rs)</strong></td><td>Store Half: <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td><td>i</td></tr><tr><td>sh</td><td>rd,laddress</td><td>Store half (low 16 bits): <br> Mem[laddress] = Rf[rd]<br><br><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  sh    rd,laddress&0xFFFF($at)</code></pre></td><td></td></tr><tr><td>sin.d</td><td>dd,ds</td><td>sine double: <br> FpRf[dd] = sin(FpRf[ds])</td><td>r</td></tr><tr><td>sin.s</td><td>fd,fs</td><td>sine single: <br> FpRf[fd] = sin(FpRf[fs])</td><td>r</td></tr><tr><td>sinh.d</td><td>dd,ds</td><td>hyperbolic sine double: <br> FpRf[dd] = sinh(FpRf[ds])</td><td>r</td></tr><tr><td>sinh.s</td><td>fd,fs</td><td>hyperbolic sine single: <br> FpRf[fd] = sinh(FpRf[fs])</td><td>r</td></tr><tr><td>sle</td><td>rd,rs,rt</td><td>Set less than or equal: <br> Rf[rd] = Rf[rs] <= Rf[rt]<br><br><pre><code>  slt   rd,rt,rs
  slti  rd,rd,1</code></pre></td><td></td></tr><tr><td>sleu</td><td>rd,rs,rt</td><td>Set less than or equal unsigned: <br> Rf[rd] = Rf[rs] <= Rf[rt]<br><br><pre><code>  sltu  rd,rt,rs
  slti  rd,rd,1</code></pre></td><td></td></tr><tr><td>sll</td><td>rd,rt,n</td><td>Shift Left Logical (immediate) <br> RF[Rd] = RF[Rt] << n</td><td>r</td></tr><tr><td>sll</td><td>rd,rt,rs</td><td>Shift Left Logical <br> alias for <strong>sllv rd,rt,rs</strong> <br> RF[Rd] = RF[Rt] << RF[Rs] amount</td><td>r</td></tr><tr><td>sllv</td><td>rd,rt,rs</td><td>Shift Left Logical Variable <br> RF[Rd] = RF[Rt] << RF[Rs] amount</td><td>r</td></tr><tr><td>slt</td><td>rd,rs,rt</td><td>Set Less Than <br> if (RF[Rs] < RF[Rt] ) then RF[Rd] =1 else RF[Rd] = 0</td><td>r</td></tr><tr><td>slti</td><td>rt,rs,imm</td><td>Set Less Than Immediate <br> if (RF[Rs] < Imm) then RF[Rt] = 1 else RF[Rt] = 0</td><td>i</td></tr><tr><td>sltiu</td><td>rt,rs,imm</td><td>Set Less Than Immediate Unsigned <br> if (RF[Rs] < Imm) then RF[Rt] = 1 else RF[Rt] = 0</td><td>i</td></tr><tr><td>sltu</td><td>rd,rs,rt</td><td>Set Less Than Unsigned <br> if (RF[Rs] < RF[Rt] ) then RF[Rd] =1 else RF[Rd] = 0</td><td>r</td></tr><tr><td>sne</td><td>rd,rs,rt</td><td>Set if not equal: <br> Rf[rd] = Rf[rs] != Rf[rt]<br><br><pre><code>  subu  $at,rs,rt
  sltu  rd,$0,$at</code></pre></td><td></td></tr><tr><td>sqrt.d</td><td>dd,ds</td><td>square root double: <br> FpRf[dd] = sqrt(FpRf[ds])</td><td>r</td></tr><tr><td>sqrt.s</td><td>fd,fs</td><td>square root single: <br> FpRf[fd] = sqrt(FpRf[fs])</td><td>r</td></tr><tr><td>sra</td><td>rd,rt,n</td><td>Shift Right Arithmetic (immediate) <br> RF[Rd] = RF[Rt] >> n (sign-extend)</td><td>r</td></tr><tr><td>sra</td><td>rd,rt,rs</td><td>Shift Right Arithmetic <br> alias for <strong>srav rd,rt,rs</strong> <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (sign-extend)</td><td>r</td></tr><tr><td>srav</td><td>rd,rt,rs</td><td>Shift Right Arithmetic Variable <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (sign-extend)</td><td>r</td></tr><tr><td>srl</td><td>rd,rt,n</td><td>Shift Right Logical <br> RF[Rd] = RF[Rt] >> n (no sign extension)</td><td>r</td></tr><tr><td>srl</td><td>rd,rt,rs</td><td>Shift Right Logical <br> alias for <strong>srlv rd,rt,rs</strong> <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (no sign extension)</td><td>r</td></tr><tr><td>srlv</td><td>rd,rt,rs</td><td>Shift Right Logical Variable <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (no sign extension)</td><td>r</td></tr><tr><td>sub</td><td>rd,rs,rt</td><td>Subtract <br> RF[Rd] = RF[Rs] - RF[Rt]</td><td>r</td></tr><tr><td>sub</td><td>rt,rs,imm</td><td>Subtract: <br> Rf[rt] = Rf[rs] - imm<br><br><pre><code>  addi  rt,rs,-imm</code></pre></td><td></td></tr><tr><td>sub</td><td>rt,imm</td><td>Subtract: <br> Rf[rt] = Rf[rt] - imm<br><br><pre><code>  addi  rt,rt,-imm</code></pre></td><td></td></tr><tr><td>sub.d</td><td>dd,ds,dt</td><td>Subtract double: <br> FpRf[dd] = FpRf[ds] - FpRf[dt]</td><td>r</td></tr><tr><td>sub.s</td><td>fd,fs,ft</td><td>Subtract single: <br> FpRf[fd] = FpRf[fs] - FpRf[ft]</td><td>r</td></tr><tr><td>subu</td><td>rd,rs,rt</td><td>Subtract Unsigned <br> RF[Rd] = RF[Rs] - RF[Rt]</td><td>r</td></tr><tr><td>subu</td><td>rt,imm</td><td>Subtract unsigned: <br> Rf[rt] = Rf[rt] - imm<br><br><pre><code>  addiu rt,rt,-imm</code></pre></td><td></td></tr><tr><td>subu</td><td>rt,rs,imm</td><td>Subtract unsigned: <br> Rf[rt] = Rf[rs] - imm<br><br><pre><code>  addiu rt,rs,-imm</code></pre></td><td></td></tr><tr><td>sw</td><td><strong>rt,imm(rs)</strong></td><td>Store Word: <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td><td>i</td></tr><tr><td>sw</td><td>rd,laddress</td><td>Store word (full 32 bits): <br> Mem[laddress] = Rf[rd]<br><br><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  sw    rd,laddress&0xFFFF($at)</code></pre></td><td></td></tr><tr><td>swc1</td><td>ft,imm(rs)</td><td>store word from cop1: <br> Mem[Rf[rs] + Offset] = FpRf[ft]</td><td>i</td></tr><tr><td>swc2</td><td>rt,imm(rs)</td><td>store word from cop2: <br> Mem[Rf[rs] + Offset] = Unimplemented</td><td>i</td></tr><tr><td>swc3</td><td>rt,imm(rs)</td><td>store word from cop3: <br> Mem[Rf[rs] + Offset] = Unimplemented</td><td>i</td></tr><tr><td>swl</td><td><strong>rt,imm(rs)</strong></td><td>Store Word Left (1-4 bytes, depending on offset): <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td><td>i</td></tr><tr><td>swr</td><td><strong>rt,imm(rs)</strong></td><td>Store Word Right (1-4 bytes, depending on offset): <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td><td>i</td></tr><tr><td>syscall</td><td></td><td>call syscall in $v0</td><td>b</td></tr><tr><td>syscall</td><td>scode</td><td>call syscall in argument</td><td>b</td></tr><tr><td>syscall</td><td>rcode</td><td>call syscall in register</td><td>b</td></tr><tr><td>tan.d</td><td>dd,ds</td><td>tangent double: <br> FpRf[dd] = tan(FpRf[ds])</td><td>r</td></tr><tr><td>tan.s</td><td>fd,fs</td><td>tangent single: <br> FpRf[fd] = tan(FpRf[fs])</td><td>r</td></tr><tr><td>tanh.d</td><td>dd,ds</td><td>hyperbolic tangent double: <br> FpRf[dd] = tanh(FpRf[ds])</td><td>r</td></tr><tr><td>tanh.s</td><td>fd,fs</td><td>hyperbolic tangent single: <br> FpRf[fd] = tanh(FpRf[fs])</td><td>r</td></tr><tr><td>tlbp</td><td></td><td>Probe TLB For Matching Entry <br> Unimplemented</td><td>r</td></tr><tr><td>tlbr</td><td></td><td>Read Indexed TLB Entry <br> Unimplemented</td><td>r</td></tr><tr><td>tlbwi</td><td></td><td>Write Indexed TLB Entry <br> Unimplemented</td><td>r</td></tr><tr><td>tlbwr</td><td></td><td>Write Random TLB Entry <br> Unimplemented</td><td>r</td></tr><tr><td>trunc.d</td><td>dd,ds</td><td>truncate double: <br> FpRf[dd] = trunc(FpRf[ds])</td><td>r</td></tr><tr><td>trunc.s</td><td>fd,fs</td><td>truncate single: <br> FpRf[fd] = trunc(FpRf[fs])</td><td>r</td></tr><tr><td>ulh</td><td>rt,imm(rs)</td><td><br><br><pre><code>  lb    rt,imm+1(rs)
  lbu   $at,imm(rs)
  sll   rt,rt,8
  or    rt,rt,$at</code></pre></td><td></td></tr><tr><td>ulhu</td><td>rt,imm(rs)</td><td><br><br><pre><code>  lbu   rt,imm+1(rs)
  lbu   $at,imm(rs)
  sll   rt,rt,8
  or    rt,rt,$at</code></pre></td><td></td></tr><tr><td>ulw</td><td>rt,imm(rs)</td><td><br><br><pre><code>  lwl   rt,imm+3(rs)
  lwr   rt,imm(rs)</code></pre></td><td></td></tr><tr><td>ush</td><td>rt,imm(rs)</td><td><br><br><pre><code>  sb    rt,imm(rs)
  srl   $at,rt,8
  sb    $at,imm+1(rs)</code></pre></td><td></td></tr><tr><td>usw</td><td>rt,imm(rs)</td><td><br><br><pre><code>  swl   rt,imm+3(rs)
  swr   rt,imm(rs)</code></pre></td><td></td></tr><tr><td>xor</td><td>rd,rs,rt</td><td>Bitwise Xor <br> RF[Rd] = RF[Rs] ^ RF[Rt]</td><td>r</td></tr><tr><td>xori</td><td>rt,rs,imm</td><td>Bitwise Xor Immediate <br> RF[Rt] = RF[Rs] ^ Imm</td><td>i</td></tr><tr><td>xori</td><td>rt,imm</td><td>Xor immediate: <br> Rf[rt] = Rf[rt] ^ imm<br><br><pre><code>  xori  rt,rt,imm</code></pre></td><td></td></tr></tbody></table></div></div><div class="container footer mw-100"><span>Last update: 2021 April 15</span></div></div><!-- col-md-12 --></div><!-- row --></div><!-- container-fluid --></body></html>