<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="description" content="MIPSym is an academic tool used to teach assembly language programming.">
<meta name="keywords" content="MIPS MIPSym simulation assembler R2000 R3000">
<title>MIPSym Documentation</title>
<link rel="icon" href="resources/img/favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1">

  <script>(function(i,s,o,g,r,a,m){{i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){{(i[r].q=i[r].q||[]).push(arguments)}},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)}})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-84648174-1', 'auto');ga('send', 'pageview');</script>

<link rel="stylesheet" href="resources/include/styles/mipsym-bootstrap.css" type="text/css"/>

  <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous" defer></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous" defer></script>
  <script> window.addEventListener("load", function(event){
  $("#toggle-toc-btn").click(function(){
    if ($(this).hasClass("opened")) {
      $("div.sidebar-col").removeClass("col-lg-3").addClass("col-lg-1");
      $("div.contents-col").removeClass("col-lg-9").addClass("col-lg-11");
      $("div.sidebar-col nav *").hide();
      $(this).removeClass("opened").addClass("closed").show().children().show();
    } else {
      $("div.sidebar-col").removeClass("col-lg-1").addClass("col-lg-3");
      $("div.contents-col").removeClass("col-lg-11").addClass("col-lg-9");
      $("div.sidebar-col nav *").show();
      $(".sidebar-col .dp3").css("display", "");
      $(".sidebar-col .dp4").css("display", "");
      $(this).removeClass("closed").addClass("opened").show();
    }
  });
}); </script>
</head>
<body>
    <div class="container-fluid">
      <div class="row">

        <div class="col-lg-3 d-none d-lg-block sidebar-col navbar-dark bg-dark">
          <nav id="navbar-contents" class="navbar navbar-dark">
            <a class="navbar-brand" href="#">MIPSym Documentation</a>
            <button id="toggle-toc-btn"
                    type="button" aria-label="Toggle Table of Contents"
                    class="navbar-toggler opened"
                    style="text-align: right">
              <span class="navbar-toggler-icon"></span>
            </button>
            
            <nav class="nav nav-pills dark-pill flex-column">
              <a class="nav-link dp1"
                 href="#mipsym_documentation">MIPSym User's Guide</a>
                <nav class="nav nav-pills dark-pill flex-column">
                  <a class="nav-link dp2"
                     href="#mipsym">Using the MIPSym Simulator</a>
                    <nav class="nav nav-pills dark-pill flex-column">
                      <a class="nav-link dp3"
                         href="#mipsym_files">Files</a>
                      <a class="nav-link dp3"
                         href="#mipsym_find">Find and Replace</a>
                      <a class="nav-link dp3"
                         href="#mipsym_shortcuts">Code editor shortcut keys</a>
                      <a class="nav-link dp3"
                         href="#mipsym_panels">Panels</a>
                      <a class="nav-link dp3"
                         href="#mipsym_build">Building Code</a>
                      <a class="nav-link dp3"
                         href="#mipsym_run">Running Code</a>
                      <a class="nav-link dp3"
                         href="#mipsym_breakpoints">Breakpoints</a>
                      <a class="nav-link dp3"
                         href="#mipsym_privacy">Privacy</a>
                    </nav>
                  <a class="nav-link dp2"
                     href="#mipsymcli">Using the MIPSymCLI Simulator</a>
                    <nav class="nav nav-pills dark-pill flex-column">
                      <a class="nav-link dp3"
                         href="#mipsymcli_win">Windows</a>
                        <nav class="nav nav-pills dark-pill flex-column">
                          <a class="nav-link dp4"
                             href="#mipsymcli_win_assembly">Assembling Programs</a>
                          <a class="nav-link dp4"
                             href="#mipsymcli_win_run">Running Programs</a>
                        </nav>
                      <a class="nav-link dp3"
                         href="#mipsymcli_linux">Linux</a>
                      <a class="nav-link dp3"
                         href="#mipsymcli_mac">Mac</a>
                      <a class="nav-link dp3"
                         href="#mipsymcli_debug">Debugging Programs in MIPSymCLI</a>
                        <nav class="nav nav-pills dark-pill flex-column">
                          <a class="nav-link dp4"
                             href="#mipsymcli_win_memory">The Memory Viewer/Editor</a>
                        </nav>
                    </nav>
                  <a class="nav-link dp2"
                     href="#differences">Differences between MIPSym's assembler and other MIPS assemblers (SPIM, GCC etc)</a>
                    <nav class="nav nav-pills dark-pill flex-column">
                      <a class="nav-link dp3"
                         href="#local_labels">Local labels</a>
                      <a class="nav-link dp3"
                         href="#delay">Delay slot</a>
                      <a class="nav-link dp3"
                         href="#fields">Fields</a>
                      <a class="nav-link dp3"
                         href="#expressions">Expressions</a>
                      <a class="nav-link dp3"
                         href="#aliasing">Aliasing and Constant Values</a>
                      <a class="nav-link dp3"
                         href="#repeats">Repeating Data</a>
                      <a class="nav-link dp3"
                         href="#char_literals">Character literals</a>
                      <a class="nav-link dp3"
                         href="#keywords">Keywords/Reserved Words</a>
                      <a class="nav-link dp3"
                         href="#user_macros">User-Defined Macros</a>
                      <a class="nav-link dp3"
                         href="#include">Include Directive</a>
                      <a class="nav-link dp3"
                         href="#other">Syscalls, Register Names, Assembler Directives, and Macros</a>
                    </nav>
                </nav>
              <a class="nav-link dp1"
                 href="#reference">Quick Reference Guide</a>
                <nav class="nav nav-pills dark-pill flex-column">
                  <a class="nav-link dp2"
                     href="#pseudos">Assembler Directives</a>
                  <a class="nav-link dp2"
                     href="#syscalls">Syscalls</a>
                    <nav class="nav nav-pills dark-pill flex-column">
                      <a class="nav-link dp3"
                         href="#spim_syscalls">SPIM-Compatible Syscalls</a>
                      <a class="nav-link dp3"
                         href="#mipsym_syscalls">MIPSym-Specific Syscalls</a>
                    </nav>
                  <a class="nav-link dp2"
                     href="#registers">Register Names</a>
                    <nav class="nav nav-pills dark-pill flex-column">
                      <a class="nav-link dp3"
                         href="#int_registers">Integer Registers</a>
                      <a class="nav-link dp3"
                         href="#flt_registers">Floating Point Registers</a>
                      <a class="nav-link dp3"
                         href="#cp0_registers">Coprocessor 0 Control Registers</a>
                      <a class="nav-link dp3"
                         href="#cp1_registers">Coprocessor 1 Control Registers</a>
                    </nav>
                  <a class="nav-link dp2"
                     href="#opcodes">Opcodes and Macros</a>
                    <nav class="nav nav-pills dark-pill flex-column">
                      <a class="nav-link dp3"
                         href="#table_explanation">How to read these tables</a>
                      <a class="nav-link dp3"
                         href="#int_opcodes">Integer Instruction Set</a>
                      <a class="nav-link dp3"
                         href="#fp_opcodes">Floating-Point Instruction Set</a>
                      <a class="nav-link dp3"
                         href="#fp_math_opcodes">Floating-Point Math Opcodes, MIPSym-Specific</a>
                      <a class="nav-link dp3"
                         href="#macros">Macros</a>
                      <a class="nav-link dp3"
                         href="#full_list_opcodes_macros">Full Listing of All Opcodes and Macros</a>
                    </nav>
                </nav>
            </nav>
          </nav>
        </div><!-- sidebar -->
        
        <div class="col-lg-9 col-md-12 contents-col" data-spy="scroll"
             data-target="#navbar-contents" data-offset="50">
<nav class="navbar navbar-expand-md navbar-dark bg-dark">
  <a class="navbar-brand" href="#">MIPSym.com</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse"
        data-target="#pageNavbar" aria-controls="pageNavbar"
        aria-expanded="false" aria-label="Toggle page navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="pageNavbar">
    <ul class="nav navbar-nav mr-auto">
        <li id="DownloadsNavBar" class="nav-item">
          <a class="nav-link" href="index.html">Downloads</a>
        </li>
        <li id="DocumentationNavBar" class="nav-item active">
          <a class="nav-link" href="#">Documentation</a>
        </li>
        <li id="ChangeLogNavBar" class="nav-item">
          <a class="nav-link" href="ChangeLog.html">Change Log</a>
        </li>
        <li id="CrossCompileNavBar" class="nav-item">
          <a class="nav-link" href="CrossCompile.html">Cross Compile</a>
        </li>
        <li id="AboutNavBar" class="nav-item">
          <a class="nav-link" href="About.html">About</a>
        </li>
    </ul>
  </div>
</nav>            <div class="content">
              <h1 id="mipsym_documentation">MIPSym User's Guide</h1>
<hr />
<p><br />
<br /></p>
<h2 id="mipsym">Using the MIPSym Simulator</h2>
<hr />
<p><br />
<br /></p>
<h3 id="mipsym_files">Files</h3>
<p>MIPSym is designed to open text files with a <code>.asm</code> or <code>.s</code> extension.</p>
<p>MIPSym can also open MIPSym-assembler generated object files with a <code>.obj</code>
extension, using the <strong>'File &gt; Load .obj'</strong> command. This is a MIPSym-specific
text file format, designed to be human-readable in a text editor; no
hex editors required.</p>
<p>Please note that the <strong>'Load .obj'</strong> command assumes that you have a <code>.asm</code>
file with the same filename in the same directory; it will load this file 
in the code editor.</p>
<p>As soon as you begin making changes to a source file that you have saved,
MIPSym begins making timed backup saves of your code. You can set the amount 
of time between automatic backups, in seconds, with 
<strong>'Settings &gt; Set Automatic Backup Interval'</strong>. By default, the interval is 5 
minutes, but you can set it as low as 1 second. You can turn the feature off
by setting it to 0 seconds. Auto-saves are typically saved as the original
filename with a tilde and a unique number after it. These files are usually
cleaned up when MIPSym exits normally.</p>
<p>MIPSym does not crash often, but if it does, it will make an attempt to open
the last file it auto-saved the next time you run it.</p>
<hr />
<p><br />
<br /></p>
<h3 id="mipsym_find">Find and Replace</h3>
<p>You can access Find and Replace feature with <kbd><kbd>Ctrl</kbd>-<kbd>F</kbd></kbd>. 
This feature is meant to work much the same as it does in other text editors.</p>
<p>Regular expression matching: MIPSym allows you to find and replace using Qt's regular 
expression engine, QRegExp. You can find documentation on QRegExp at 
<a href="http://doc.qt.io/qt-5/qregexp.html#details">doc.qt.io</a>.</p>
<p>Regular expression capture groups: Regular expression engines allow you to reference
capture groups in your replacement strings, often using <code>$1</code>, <code>$2</code>, <code>$3</code> and so on.
Using QRegExp's string replacement tools, you will need to use <code>\1</code>, <code>\2</code>, <code>\3</code> and so on.</p>
<p>For example, if you had text that looked like this:</p>
<div class="codehilite"><pre><span></span><code>    Apples: add     $t0,$t1,$t2
</code></pre></div>


<p>... and you had a search string that looked like this:</p>
<div class="codehilite"><pre><span></span><code>    (\w+):\s+add\s+(\$\w+),(\$\w+),(\$\w+)
</code></pre></div>


<p>... and you had a replacement string that looked like this:</p>
<div class="codehilite"><pre><span></span><code>    # At label \1, we add \4 to \3 and store the result in \2.
</code></pre></div>


<p>... you could find that string, hit <strong>'Replace'</strong>, and end up with this string:</p>
<div class="codehilite"><pre><span></span><code>    # At label Apples, we add $t2 to $t1 and store the result in $t0.
</code></pre></div>


<hr />
<p><br />
<br /></p>
<h3 id="mipsym_shortcuts">Code editor shortcut keys</h3>
<p>Menu tabs can be accessed through <kbd>Alt</kbd>. Each tab's corresponding key will be
underlined on pressing <kbd>Alt</kbd>, at which point pressing its key will send you
to the menu tab dropdown. Most of the shortcut keys you might need are written in the
menus, right next  to the actions they trigger. For instance, under the <strong>'File'</strong> menu,
the <strong>'Save'</strong> action has the text <kbd><kbd>Ctrl</kbd>-<kbd>S</kbd></kbd> next to it, or
<kbd><kbd>&#8984;</kbd>-<kbd>S</kbd></kbd> on Mac.</p>
<p>There are a few keyboard shortcuts that are not on the menu; these are listed here:</p>
<div class="table-responsive">
  <table class="table">
    <tr>
      <th>Shortcut Keys</th>
      <th>Mac Equivalent</th>
      <th>Action</th>
    </tr>
    <tr>
      <td><kbd><kbd>Ctrl</kbd>-<kbd>/</kbd></kbd></td>
      <td><kbd><kbd>&#8984;</kbd>-<kbd>/</kbd></kbd></td>
      <td>
        Toggle-comment the line that the cursor is on.<br>
        If multiple lines are selected, every line selected will toggle-comment.
      </td>
    </tr>
    <tr>
      <td><kbd>Tab</kbd></td>
      <td><kbd>Tab</kbd></td>
      <td>
        If any text is selected, the entire line (or block of lines) is indented with Tab characters.
      </td>
    </tr>
    <tr>
      <td><kbd><kbd>Shift</kbd>-<kbd>Tab</kbd></kbd></td>
      <td><kbd><kbd>Shift</kbd>-<kbd>Tab</kbd></kbd></td>
      <td>
        If any text is selected, the entire line (or block of lines) is unindented.
      </td>
    </tr>
    <tr>
      <td><kbd><kbd>Ctrl</kbd>-<kbd>MouseWheel+/-</kbd></kbd></td>
      <td><kbd><kbd>&#8984;</kbd>-<kbd>MouseWheel+/-</kbd></kbd></td>
      <td>
        Increase/decrease the size of the text in the IDE or the console.
      </td>
    </tr>
  </table>
</div>

<hr />
<p><br />
<br /></p>
<h3 id="mipsym_panels">Panels</h3>
<p>The main window of the MIPSym IDE is divided into four panels:</p>
<ul>
<li>The Code Panel</li>
<li>The Register Panel</li>
<li>The Message Log Panel</li>
<li>The Memory Panel</li>
</ul>
<p>By default, only the Code panel is visible when you start up MIPSym.
You can change this behavior under <strong>'Settings &gt; On Startup Show'</strong>.</p>
<p>By default, the Message Log panel will show itself whenever it receives a new
message. You can prevent this behavior with 
<strong>'Settings &gt; Auto Show Messages on Arrival'</strong>.
The Message Log is used to provide feedback any time MIPSym has something useful
to tell you, but doesn't want to use an obtrusive dialog box to do so. It is
usually best to leave this setting turned on, unless you are really worried
about screen space. If you turn it off, the Message Log will still record
messages, and you can access them at any time.</p>
<p>The Register and Memory panels can be accessed at any time, either by using the
<strong>'View'</strong> menu, or by pulling on the vertical panel sliders at the right edge of
the window. The panel sliders look like thick black lines, and your mouse cursor
will change shape as you hover over them. If the Message Log is hidden, you can
also access the Message Log using the horizontal panel slider at the bottom of
the window.</p>
<hr />
<p><br />
<br /></p>
<h3 id="mipsym_build">Building Code</h3>
<p>To build a program, click <strong>'Run &gt; Build <kbd>F8</kbd>'</strong>. The assembler should 
run on the code in the leftmost source tab, and the assembly results should 
show up in the Listing tab of the code panel.</p>
<p>Your copy of MIPSym may contain alternate assemblers in a directory marked
<code>asm</code>; if you wish to use one of them instead of the default assembler,
you can do so with <strong>'Settings &gt; Set Assembler Path'</strong>. </p>
<p>Every time the assembler runs, the Message Log will display a note that 
contains the path to the assembler used and the version number.
If the assembler crashes, the Message Log will contain a note with the 
assembler's return value, and possibly an explanation of what happened.
If you are able to get the assembler to crash, please alert the 
developers!</p>
<hr />
<p><br />
<br /></p>
<h3 id="mipsym_run">Running Code</h3>
<p>You can step through your program one instruction at a time using the 
<strong>'Run &gt; Step <kbd>F10</kbd>'</strong> or <strong>'Run &gt; Step Over <kbd>F11</kbd>'</strong>
commands. <strong>'Run &gt; Step Over <kbd>F11</kbd>'</strong> functions like
<strong>'Run &gt; Step <kbd>F10</kbd>'</strong>, except that subroutines called with
<code>jal</code> and its variants will be executed at full speed.</p>
<p>You can run the program with <strong>'Run &gt; Run<kbd>F9</kbd>'</strong>; this will run 
your program until you hit a breakpoint, if any are set, or the program 
ends, or an exception occurs. This command will also save and build your 
program if you have unsaved changes. <strong>'Run &gt; Run Until Return <kbd><kbd>Shift</kbd>+<kbd>F8</kbd></kbd>'</strong>
functions similarly to <strong>'Run &gt; Run<kbd>F9</kbd>'</strong>, but will additionally
pause execution after the current subroutine exits.</p>
<p>You can pause the program at any time with <strong>'Run &gt; Step <kbd>F10</kbd>'</strong>.
This will be useful if your program uses spin locks or long/infinite loops;
your PC will otherwise waste lots of CPU cycles and power to emulate these.</p>
<p>Clicking on a line number in the Listing file will send you to the corresponding
line in your source code. You may find this useful if your program uses
many macros, or includes other source files.</p>
<p>If you run a program, and it finishes, either via exception, <code>syscall $exit</code>, or
by running off the end of the <code>.code</code> section, the simulator's PC and registers
will all be in the same state so that you can examine them. If you want to
re-run your program, use <strong>'Run &gt; Reset <kbd><kbd>Shift</kbd>-<kbd>F8</kbd></kbd>'</strong> 
first, otherwise your program may begin in the wrong state.</p>
<hr />
<p><br />
<br /></p>
<h3 id="mipsym_breakpoints">Breakpoints</h3>
<p>To set breakpoints, go to the listing tab, highlight a memory address 
in a <code>.code</code> section, and click 
<strong>'Breakpoint &gt; Add <kbd><kbd>Ctrl</kbd>-<kbd>B</kbd></kbd>'</strong>. 
This will pause your program at that address the next time you run it.</p>
<p>You can also add and remove breakpoints without highlighting memory addresses;
you will see a dialog box that allows you to set the addresses manually.</p>
<p>Be aware that breakpoints are cleared upon build or reset and will need to
be set again.</p>
<hr />
<p><br />
<br /></p>
<h3 id="mipsym_privacy">Privacy</h3>
<p>By default, MIPSym looks for updates at MIPSym.com every time it starts up. 
The Windows installation is capable of updating itself when MIPSym starts up,
if you consent to the download (typically 11 MB). The Linux version should be 
capable of this soon as well.</p>
<p>However, the MIPSym team values your privacy and desire not to be tracked.
You can turn off this feature in one of two ways:</p>
<ol>
<li>The <strong>'Settings &gt; Check for new version on launch'</strong> menu item. This item is 
    checked by default, but you can un-check it the first time it runs, and 
    MIPSym will stop contacting MIPSym.com in the future. This means that the 
    first time MIPSym runs, it will contact MIPSym.com. If your preferences 
    file is corrupted or deleted for some reason, it will also contact 
    MIPSym.com until you uncheck this box.</li>
<li>The <code>-p</code> or <code>--private</code> command line option. If you launch MIPSym from the 
    command line, or use a shortcut, you can add this option to your launch 
    command, and MIPSym will never access MIPSym.com for any reason.</li>
</ol>
<hr />
<p><br />
<br /></p>
<h2 id="mipsymcli">Using the MIPSymCLI Simulator</h2>
<hr />
<p><br />
<br /></p>
<h3 id="mipsymcli_win">Windows</h3>
<p>After installation, there will be two shortcuts in your Start Menu, under a
folder labelled MIPSym2. The MIPSym shortcut will run the GUI version of MIPSym;
the MIPSymCLI shortcut will launch a Windows terminal with an environment set up
to make it easier to run MIPSym from the command line.</p>
<p>This Windows terminal will start you out in your "home" directory.
This is meant to encourage you not to try to modify files in the
<code>C:\Program Files (x86)</code> directory.
If you prefer to start in some other directory, please modify
<code>C:\Program Files (x86)\MIPSym2\MipsymCliEnv.bat</code> accordingly.</p>
<p>If MIPSym is installed in the default location, there will be some example MIPS
assembly files at <code>C:\Program Files (x86)\MIPSym2\example_code</code>.
You may wish to copy these files to your home directory, using the <code>xcopy</code> command:</p>
<div class="codehilite"><pre><span></span><code>xcopy &quot;C:\Program Files (x86)\MIPSym2\example_code&quot; MIPS_workspace\
</code></pre></div>


<p>The <code>xcopy</code> command will copy the whole directory into your home directory, in
a new directory called <code>MIPS_workspace</code>.</p>
<p>You can move into the <code>MIPS_workspace</code> directory with the <code>cd</code> command:</p>
<div class="codehilite"><pre><span></span><code>cd MIPS_workspace
</code></pre></div>


<p>Use the <code>dir</code> command to print a list of all the files in the current directory.</p>
<h4 id="mipsymcli_win_assembly">Assembling Programs</h4>
<p>Within this terminal, you can assemble a MIPS program in the current directory
called <code>hello_world.asm</code> by entering:</p>
<div class="codehilite"><pre><span></span><code><span class="c">%ASM% hello_world.asm</span>
</code></pre></div>


<p>If the assembler runs properly, it should produce an object file, in the same
directory as the assembly file, with the <code>.obj</code> extension in place of the
<code>.asm</code> extension. </p>
<p>You can check the assembler's return code with this command:</p>
<div class="codehilite"><pre><span></span><code>echo %errorlevel%
</code></pre></div>


<p>The assembler referenced by <code>%ASM%</code> returns 0 when assembly succeeded and 1 when 
assembly failed. Any other return code means the assembler crashed.</p>
<p>If you are able to get the assembler to crash, please alert the developers!</p>
<p>The assembler should have produced a few files when it assembled <code>hello_world.asm</code>:</p>
<ol>
<li>A log file, <code>hello_world.log</code>.
    This file stores some basic data about what assembler was used to assemble
    the program and what arguments were passed to the assembler. After you run
    the program in MIPSymCLI, some runtime statistics will be appended to this file.</li>
<li>An object file, <code>hello_world.obj</code>.
    This file represents the machine code that corresponds to the program you
    assembled. It isn't an actual machine code binary; it is instead stored as
    ASCII text so that you can read it easily.</li>
<li>A listing file, <code>hello_world.lst</code>.
    This file shows a direct mapping between the lines of assembly code in the
    <code>hello_world.asm</code> and the machine code written to <code>hello_world.obj</code>.
    It is meant to help you figure out what the assembler produced, and why.</li>
</ol>
<p>You can print any of these files to the terminal, using the <code>type</code> command:</p>
<div class="codehilite"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nx">hello_world</span><span class="p">.</span><span class="nx">lst</span>
</code></pre></div>


<p>If you prefer, you can also open the files in Notepad.exe:</p>
<div class="codehilite"><pre><span></span><code>notepad hello_world.lst
</code></pre></div>


<p>There are two assemblers available in <code>C:\Program Files (x86)\MIPSym2\asm</code>. 
One is available via the <code>%ASM%</code> environment variable; this is the recommended
assembler. </p>
<p>You may decide that you prefer to use the older version of the
assembler, <code>C:\Program Files (x86)\MIPSym2\asm\assembler_builder.exe</code>. 
If you want to use this one, please note that you will need to use the <code>-W</code>
flag, and that every assembly source file must be preceded by a <code>\</code>, otherwise
the assembler will crash. 
For example, if you want to assemble <code>hello_world.asm</code> in the working directory, 
you would need to use this command:</p>
<div class="codehilite"><pre><span></span><code>&quot;C:\Program Files (x86)\MIPSym2\asm\assembler_builder.exe&quot; -W .\hello_world.asm
</code></pre></div>


<p>Also, you should know that <code>assembler_builder.exe</code> produces a <code>hello_world.sig</code>
file that contains no more than a few bytes. This file is used as a secondary
form of communication with the GUI version of MIPSym, and it won't be very
interesting to you. It is safe to delete this file. The newer <code>assembler.exe</code>
produces <code>.sig</code> files as well, but the <code>%ASM%</code> variable includes a command line
flag to suppress these files so that you will not see them.</p>
<h4 id="mipsymcli_win_run">Running Programs</h4>
<p>Within this terminal, you can run a MIPS program in the current directory
called <code>hello_world.obj</code> by typing:</p>
<div class="codehilite"><pre><span></span><code>MIPSymCLI hello_world.obj
</code></pre></div>


<p>A complete list of the command line flags that MIPSymCLI supports is available
by typing:</p>
<div class="codehilite"><pre><span></span><code>MIPSymCLI -h
</code></pre></div>


<p>If you need to quit running a program, but you don't want exit the terminal,
just press <kbd><kbd>Ctrl</kbd>-<kbd>C</kbd></kbd> to return to the command prompt.</p>
<hr />
<p><br />
<br /></p>
<h3 id="mipsymcli_linux">Linux</h3>
<p>The "MIPSym_x.xx.xxxx.tar.gz" archive includes the file "MIPSymCLI-x86_64.AppImage".
This is an AppImage that you may relocate to any directory you wish.
You will also find an assembler called "MIPSymAssembler" in the "asm" directory;
please keep it in the same directory as "Mips1.adf".
You may find it simplest to do something like this:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>tar<span class="w"> </span>-xvzf<span class="w"> </span>MIPSym_x.xx.xxxx.tar.gz<span class="w"> </span>-C<span class="w"> </span>~
</code></pre></div>


<p>This will extract the archive into your home directory, in a new directory
called MIPSym_x.xx.xxxx.</p>
<p>If you expect to use MIPSymCLI for any length of time, you will probably want
to add some aliases to your dotfiles to make MIPSymCLI easier to use.
The developers recommend that you add these lines to your <code>~/.bashrc</code> file
(or <code>~/.zshrc</code>, or <code>~/.config/fish</code> file, depending on your preferred shell):</p>
<div class="codehilite"><pre><span></span><code>alias assembler=&#39;/home/$USER/MIPSym_x.xx.xxxx/asm/MIPSymAssembler -s&#39;
alias MIPSymCLI=&#39;/home/$USER/MIPSym_x.xx.xxxx/MIPSymCLI-x86_64.AppImage&#39;
</code></pre></div>


<p>The next time you open a terminal, you will be able to type <code>assembler</code> to
run MIPSymAssembler with the <code>-s</code> flag, or <code>MIPSymCLI</code> to run the command-line
version of MIPSym. For instance, if you had the file <code>hello_world.asm</code> in the
working directory, you could run it like this:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>assembler<span class="w"> </span>hello_world.asm<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>MIPSymCLI<span class="w"> </span>hello_world.obj
</code></pre></div>


<p>If there are any errors in <code>hello_world.asm</code>, <code>assembler</code> emits a nonzero
return code that prevents <code>MIPSymCLI</code> from running.</p>
<p>To make this process automatic, you may wish to interact with MIPSymCLI using 
a file watcher like <a href="https://github.com/inotify-tools/inotify-tools/wiki"><code>inotify-wait</code></a>.
This tool can be used to cause the <code>assembler</code> and <code>MIPSymCLI</code> emulator to 
run again any time you save changes to the <code>hello_world.asm</code> source.</p>
<hr />
<p><br />
<br /></p>
<h3 id="mipsymcli_mac">Mac</h3>
<p>The <code>MIPSym.app</code> file in your <code>/Applications</code> directory is actually a directory 
that includes many files, including an assembler and the <code>MIPSymCLI</code> application.
You can access these programs from your terminal by adding the following lines
to your <code>~/.bashrc</code> file 
(or <code>~/.zshrc</code>, or <code>~/.config/fish</code> file, depending on your preferred shell):</p>
<div class="codehilite"><pre><span></span><code>alias assembler=&#39;/Applications/MIPSym.app/Contents/MacOS/asm/assembler -s&#39;
alias MIPSymCLI=&#39;/Applications/MIPSym.app/Contents/MacOS/MIPSymCLI&#39;
</code></pre></div>


<p>When you launch a new terminal session, you will be able to use the commands 
<code>assembler</code> and <code>MIPSymCLI</code> from any location, as long as <code>MIPSym.app</code> is in 
your <code>/Applications</code> directory. 
For instance, if you had the file <code>hello_world.asm</code> in the working 
directory, you could run it like this:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>assembler<span class="w"> </span>hello_world.asm<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>MIPSymCLI<span class="w"> </span>hello_world.obj
</code></pre></div>


<p>If there are any errors in <code>hello_world.asm</code>, <code>assembler</code> emits a nonzero 
return code that prevents <code>MIPSymCLI</code> from running.</p>
<hr />
<p><br />
<br /></p>
<h3 id="mipsymcli_debug">Debugging Programs in MIPSymCLI</h3>
<p>You can put MIPSymCLI in interactive debug mode with this command:</p>
<div class="codehilite"><pre><span></span><code>MIPSymCLI -i hello_world.obj
</code></pre></div>


<p>In debug mode, you can type <kbd>?</kbd> at any point to get a list of commands
you can use, or <kbd>x</kbd> to exit the current mode.</p>
<p>When you enter debug mode, you will see a cryptic series of numbers and letters
across the top of the screen. For example, you might see this:</p>
<div class="codehilite"><pre><span></span><code>Mem Addr  Contents Inst    Hex Args  Last Reg Diff
00400000  340a0021 ori   0a,00,0021  $ra = 004000f0 &gt;&gt;
</code></pre></div>


<p>The top line is meant to help you to understand the line below it.
There are five columns of data here, followed by a <code>&gt;&gt;</code> symbol.
The <code>&gt;&gt;</code> symbol is a prompt, meaning that MIPSymCLI expects you to type something.</p>
<p>The five columns of data are:</p>
<ol>
<li>The memory address that the Program Counter is currently pointed to. The
    <code>.code</code> section of MIPS programs usually begins at 0x400000, and that's where
    most MIPS programs start. If you wrote a MIPS program with a <code>main</code> label
    at some other location, and used the <code>.globl main</code> instruction to export that
    symbol, you would see some other memory address in this column.
    Note that all the numbers in this display are printed in hexadecimal;
    they are more compact and easier to read this way.</li>
<li>The 32-bit integer stored at this memory address. Since we are in the <code>.code</code>
    section, this integer is most likely machine code for a MIPS instruction.
    The MIPSym simulator will interpret this number as if it were a
    MIPS instruction. Hopefully, the author of this program kept all the
    program's data in the <code>.data</code> section, and out of the <code>.code</code> section, so
    the MIPSym simulator doesn't try to interpret data as MIPS instructions!</li>
<li>The assembly instruction that MIPSym will try to run when it sees the 32-bit
    integer at this address.</li>
<li>The arguments to the MIPS instruction at this address, written in hexadecimal.</li>
<li>The integer register that changed during the previous instruction. If no
    register has changed, this column will point to <code>$ra</code> by default.
    This column also shows you the value held in that register.</li>
</ol>
<p>You can step through the program one instruction at a time by pressing the
<kbd>i</kbd> or <kbd>F10</kbd> key.</p>
<p>At any point, you can set or clear breakpoints, view the contents of the
registers, or view and edit the contents of memory.
Press <kbd>?</kbd> to see a complete list of commands.</p>
<h4 id="mipsymcli_win_memory">The Memory Viewer/Editor</h4>
<p>From debug mode, you can enter the memory editor by pressing <kbd>m</kbd>.
In this mode, the prompt turns into a <code>&gt;&gt;&gt;</code> to denote that you are in the memory
editor, and not in debug mode. From this point, you can press <kbd>x</kbd> to get back
to debug mode.</p>
<p>In the memory editor, you can press <kbd>d</kbd> to display and edit memory.
Once you have pressed <kbd>d</kbd>, you will see something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="mh">0x10010000</span><span class="o">:</span><span class="w"> </span><span class="mi">20202020</span><span class="w"> </span><span class="o">&gt;</span>
</code></pre></div>


<p>The first number is the hex address of the current location in memory,
0x10010000, which happens to be the beginning of the <code>.data</code> section.
The second number is the value at that address: a series of 0x20's.
In this program, the beginning of the data section is filled by a string of
ASCII space characters.
The last thing on this line is the data-entry prompt, a <code>&gt;</code> symbol.</p>
<p>If you were to enter a 32-bit number here, the first four bytes at address
0x10010000 would be replaced by the number you entered.</p>
<p>If you were to press the up or down arrow keys, the memory address would
increment/decrement by 4, and the value at the new address would be displayed
in place of the previous value.</p>
<p>If you entered nothing at all, and just pressed the Enter key, the next memory
address and memory value would appear on the next line.
This is a good way to view a large block of memory at once: just press Enter
over and over again, and the whole block will print out four bytes at a time.</p>
<p>Press <kbd>x</kbd> to leave data-entry mode and go back to the memory editor.
Note that the prompt changes back to a <code>&gt;&gt;&gt;</code>.</p>
<p>There are three things you can change in the memory editor:</p>
<ol>
<li>The current memory address (press <kbd>a</kbd> to modify).
    It could take a long time to press the arrow keys to reach the address you
    want to display or modify; this will get you there directly.</li>
<li>Size mode (press <kbd>s</kbd> to modify). If you are modifying integers, you can
    choose between modifying 1 byte, 2 bytes, 4 bytes, or 8 bytes at a time.</li>
<li>Entry mode (press <kbd>e</kbd> to modify). This allows you to change the way that
    data is displayed and entered in data-entry mode. You can use this to
    display blocks of memory as floating-point data, string data, integers, or
    as disassembled MIPS machine code.</li>
</ol>
<p>You can press <kbd>?</kbd> at any time in the memory editor to see what address,
size mode, and entry mode are currently selected.</p>
<hr />
<p><br />
<br /></p>
<h2 id="differences">Differences between MIPSym's assembler and other MIPS assemblers (SPIM, GCC etc)</h2>
<hr />
<p><br />
<br /></p>
<h3 id="local_labels">Local labels</h3>
<p>MIPSym supports the use of "Local Labels." These were likely supported by the
original MIPS assembler as seen in Appendix C page 9 of "MIPS RISC Architecture" (Kane
and Heinrich, 1991) but are not supported by all assemblers.</p>
<p>Labels numbered 0 through 99 are reserved for use as local labels; these
labels can be reused to eliminate the need for unique, descriptive labels in
larger programs. Labels numbered 00 through 09 are used for assembler macros,
and must be avoided outside of <a href="#user_macros">custom macro definitions</a>.</p>
<p>When referring to local labels in expressions and instructions, the label
number must be appended with a 'b' or 'f' to indicate whether it points
backward or forward to the nearest instance of the label from the current line.</p>
<div class="codehilite"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">local</span><span class="w"> </span><span class="n">labels</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">code</span><span class="p">:</span>
<span class="w">    </span><span class="n">li</span><span class="w">      </span><span class="err">$</span><span class="n">t0</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">1</span><span class="err">:</span><span class="w">  </span><span class="n">addi</span><span class="w">    </span><span class="err">$</span><span class="n">t0</span><span class="p">,</span><span class="err">$</span><span class="n">t0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="n">bgtz</span><span class="w">    </span><span class="err">$</span><span class="n">t0</span><span class="p">,</span><span class="mi">1</span><span class="n">b</span><span class="w">          </span><span class="err">#</span><span class="w"> </span><span class="n">backward</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="n">reference</span>

<span class="err">#</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">local</span><span class="w"> </span><span class="n">labels</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">assembled</span><span class="w"> </span><span class="nl">macro</span><span class="p">:</span>
<span class="w">    </span><span class="nf">abs</span><span class="w">     </span><span class="err">$</span><span class="n">a0</span><span class="p">,</span><span class="err">$</span><span class="n">t1</span><span class="w">         </span><span class="err">#</span><span class="w"> </span><span class="n">macro</span>
<span class="w">    </span><span class="n">addu</span><span class="w">    </span><span class="err">$</span><span class="n">a0</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="p">,</span><span class="err">$</span><span class="n">t1</span>
<span class="w">    </span><span class="n">bgez</span><span class="w">    </span><span class="err">$</span><span class="n">t1</span><span class="p">,</span><span class="mi">09</span><span class="n">f</span><span class="w">         </span><span class="err">#</span><span class="w"> </span><span class="n">forward</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="n">reference</span>
<span class="w">    </span><span class="n">sub</span><span class="w">     </span><span class="err">$</span><span class="n">a0</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="p">,</span><span class="err">$</span><span class="n">t1</span>
<span class="mi">09</span><span class="err">:</span><span class="w">                         </span><span class="err">#</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="n">macro</span>

<span class="err">#</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="mi">4</span><span class="n">x4</span><span class="w"> </span><span class="n">matrix</span><span class="w"> </span><span class="n">multiplication</span><span class="p">,</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">nested</span><span class="w"> </span><span class="n">loops</span>
<span class="nl">MM</span><span class="p">:</span><span class="w"> </span><span class="n">addi</span><span class="w">    </span><span class="err">$</span><span class="n">t0</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span>
<span class="mi">1</span><span class="err">:</span><span class="w">  </span><span class="n">addi</span><span class="w">    </span><span class="err">$</span><span class="n">t1</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span>
<span class="mi">2</span><span class="err">:</span><span class="w">  </span><span class="k">add</span><span class="w">     </span><span class="err">$</span><span class="n">t3</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="w">       </span><span class="n">#sum</span><span class="o">=</span><span class="mi">0</span>
<span class="w">    </span><span class="n">addi</span><span class="w">    </span><span class="err">$</span><span class="n">t2</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span>
<span class="mi">3</span><span class="err">:</span><span class="w">  </span><span class="n">sll</span><span class="w">     </span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">t0</span><span class="p">,</span><span class="mi">4</span><span class="w">       </span><span class="n">#L</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span>
<span class="w">    </span><span class="n">sll</span><span class="w">     </span><span class="err">$</span><span class="n">t6</span><span class="p">,</span><span class="err">$</span><span class="n">t2</span><span class="p">,</span><span class="mi">2</span>
<span class="w">    </span><span class="k">add</span><span class="w">     </span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">t6</span>
<span class="w">    </span><span class="k">add</span><span class="w">     </span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">a1</span>
<span class="w">    </span><span class="n">lw</span><span class="w">      </span><span class="err">$</span><span class="n">t9</span><span class="p">,(</span><span class="err">$</span><span class="n">t5</span><span class="p">)</span>
<span class="w">    </span><span class="n">sll</span><span class="w">     </span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">t2</span><span class="p">,</span><span class="mi">4</span><span class="w">       </span><span class="n">#R</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
<span class="w">    </span><span class="n">sll</span><span class="w">     </span><span class="err">$</span><span class="n">t6</span><span class="p">,</span><span class="err">$</span><span class="n">t1</span><span class="p">,</span><span class="mi">2</span>
<span class="w">    </span><span class="k">add</span><span class="w">     </span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">t6</span>
<span class="w">    </span><span class="k">add</span><span class="w">     </span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">a2</span>
<span class="w">    </span><span class="n">lw</span><span class="w">      </span><span class="err">$</span><span class="n">t8</span><span class="p">,(</span><span class="err">$</span><span class="n">t5</span><span class="p">)</span>
<span class="w">    </span><span class="n">mul</span><span class="w">     </span><span class="err">$</span><span class="n">t7</span><span class="p">,</span><span class="err">$</span><span class="n">t8</span><span class="p">,</span><span class="err">$</span><span class="n">t9</span><span class="w">     </span><span class="err">#</span><span class="w"> </span><span class="o">*</span>
<span class="w">    </span><span class="k">add</span><span class="w">     </span><span class="err">$</span><span class="n">t3</span><span class="p">,</span><span class="err">$</span><span class="n">t3</span><span class="p">,</span><span class="err">$</span><span class="n">t7</span><span class="w">     </span><span class="n">#sum</span><span class="w"> </span><span class="o">+=</span>
<span class="w">    </span><span class="n">addi</span><span class="w">    </span><span class="err">$</span><span class="n">t2</span><span class="p">,</span><span class="err">$</span><span class="n">t2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="n">bgtz</span><span class="w">    </span><span class="err">$</span><span class="n">t2</span><span class="p">,</span><span class="mi">3</span><span class="n">b</span>
<span class="w">    </span><span class="n">sll</span><span class="w">     </span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">t0</span><span class="p">,</span><span class="mi">4</span><span class="w">       </span><span class="n">#P</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
<span class="w">    </span><span class="n">sll</span><span class="w">     </span><span class="err">$</span><span class="n">t6</span><span class="p">,</span><span class="err">$</span><span class="n">t1</span><span class="p">,</span><span class="mi">2</span>
<span class="w">    </span><span class="k">add</span><span class="w">     </span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">t6</span>
<span class="w">    </span><span class="k">add</span><span class="w">     </span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">t5</span><span class="p">,</span><span class="err">$</span><span class="n">a0</span>
<span class="w">    </span><span class="n">sw</span><span class="w">      </span><span class="err">$</span><span class="n">t3</span><span class="p">,(</span><span class="err">$</span><span class="n">t5</span><span class="p">)</span><span class="w">       </span><span class="err">#</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">sum</span>
<span class="w">    </span><span class="n">addi</span><span class="w">    </span><span class="err">$</span><span class="n">t1</span><span class="p">,</span><span class="err">$</span><span class="n">t1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="n">bgtz</span><span class="w">    </span><span class="err">$</span><span class="n">t1</span><span class="p">,</span><span class="mi">2</span><span class="n">b</span>
<span class="w">    </span><span class="n">addi</span><span class="w">    </span><span class="err">$</span><span class="n">t0</span><span class="p">,</span><span class="err">$</span><span class="n">t0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="n">bgtz</span><span class="w">    </span><span class="err">$</span><span class="n">t0</span><span class="p">,</span><span class="mi">1</span><span class="n">b</span>
<span class="w">    </span><span class="n">jr</span><span class="w">      </span><span class="err">$</span><span class="n">ra</span>
</code></pre></div>


<p>It is good practice to keep labels in numerical order within functions.
Local labels should not be referenced outside of the context they appear in.</p>
<hr />
<p><br />
<br /></p>
<h3 id="delay">Delay slot</h3>
<p>The MIPS R2000 processor executes every instruction placed directly
after a branch instruction before it executes the branch. This is
called the delay slot. By default, the MIPSym simulator disables this
behavior. The delay slot behavior may be restored by using the 
<code>.delay</code> assembler directive at the top of any program. Programs written
for SPIM must be modified by adding this assembler directive before all
other lines:</p>
<div class="codehilite"><pre><span></span><code>    .delay
</code></pre></div>


<p>The following blocks of code illustrate how the delay slot can alter the
behavior of your programs.</p>
<div class="codehilite"><pre><span></span><code><span class="gh">#</span> Default behavior: the &#39;.delay&#39; assembler directive is absent
    li      $a0,5           # put a 5 in $a0
    jal     some_function   # jump to some_function, with argument $a0 == 5
    addi    $a0,$a0,8       # when some_function returns, set $a0 = 5 + 8


<span class="gh">#</span> Delay slot mode: the &#39;.delay&#39; assembler directive appeared at the top of the program
    li      $a0,5           # put a 5 in $a0
    jal     some_function   # jump to some_function, with argument $a0 == 13
    addi    $a0,$a0,8       # delay slot: this instruction runs before some_function
</code></pre></div>


<p>Please do not attempt to use a macro in the delay slot: the first line of the 
macro will be executed before a branch, but subsequent instructions will not!   </p>
<hr />
<p><br />
<br /></p>
<h3 id="fields">Fields</h3>
<p>The MIPSym assembler reads each line of assembly code as a series of 
three fields, separated by whitespace:</p>
<ol>
<li>the label field</li>
<li>the opcode/pseudo-op field</li>
<li>the arguments field</li>
</ol>
<p>This has two very important consequences that are common pain 
points for new users of MIPSym:</p>
<ol>
<li>
<p>Lines of code without a label must be indented</p>
<div class="codehilite"><pre><span></span><code># Valid code:
    add     $t0,$t0,$t0
# Not valid:
add     $t0,$t0,$t0
</code></pre></div>


</li>
<li>
<p>Whitespace is not allowed between arguments or within 
mathematical expressions.</p>
<div class="codehilite"><pre><span></span><code># Not valid:
    add     $t0, $t0, $t0
# Valid code:
    addi    $t0,$t0,1+2+3      # adds 6 to $t0
# Valid, but not what you meant (Will throw a warning):
    addi    $t0,$t0,1 + 2 + 3  # adds 1 to $t0, not 6
</code></pre></div>


</li>
</ol>
<hr />
<p><br />
<br /></p>
<h3 id="expressions">Expressions</h3>
<p>Mathematical expressions are evaluated from left to right, with no
regard to operator precedence. Parentheses are not allowed.</p>
<div class="codehilite"><pre><span></span><code><span class="gh">#</span> Valid code:
    addi  $t0,$0,1+2*3     # stores (1+2)*3, or 9, in $t0
<span class="gh">#</span> Not valid:
    addi  $t0,$0,1+(2*3)   # does not assemble
</code></pre></div>


<p>If you need an expression that would normally use parentheses, use
<a href="#aliasing">aliasing</a> for the nested expressions.</p>
<div class="codehilite"><pre><span></span><code><span class="gh">#</span> Valid code:
i = 2*3
    addi $t0,$0,1+i        # evaluated as 1+(2*3)
</code></pre></div>


<p>Note that the MIPSym assembler evaluates each value in an expression as an 
integer, not as floating point data.</p>
<div class="codehilite"><pre><span></span><code># Not valid code:
    addi  $t0,$0,3.9+3.9   # does not assemble
</code></pre></div>


<hr />
<p><br />
<br /></p>
<h3 id="aliasing">Aliasing and Constant Values</h3>
<p>Like SPIM, you can use the assignment operator to assign a constant value to 
an identifier. This feature is meant to allow you to write readable code that
isn't full of magic numbers. For example:</p>
<div class="codehilite"><pre><span></span><code><span class="p">#</span><span class="w"> </span><span class="n">Valid</span><span class="w"> </span><span class="nl">code:</span>
<span class="n">num_days_in_year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">365</span>
<span class="n">num_days_in_leap_year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_days_in_year</span><span class="o">+</span><span class="mh">1</span>
<span class="w">    </span><span class="n">li</span><span class="w">    </span><span class="n">$t0</span><span class="p">,</span><span class="n">num_days_in_leap_year</span><span class="w">    </span><span class="p">#</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="mh">366</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">register</span><span class="w"> </span><span class="n">$t0</span>
</code></pre></div>


<p>Don't forget to use whitespace before and after the <code>=</code> operator:</p>
<div class="codehilite"><pre><span></span><code><span class="n">x</span><span class="o">=</span><span class="mi">7</span><span class="w">     </span><span class="c1"># fail; the `=` is interpreted as part of a label</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="mi">7</span><span class="w">    </span><span class="c1"># fail; the `=7` is interpreted as an undefined opcode</span>
<span class="n">x</span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="w">    </span><span class="c1"># fail; the `x=` is interpreted as part of a label</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="w">   </span><span class="c1"># OK: `7` is now assigned to `x`</span>
</code></pre></div>


<p>This feature is often used with labels as well:</p>
<div class="codehilite"><pre><span></span><code><span class="p">#</span><span class="w"> </span><span class="n">Valid</span><span class="w"> </span><span class="nl">code:</span>
<span class="nl">my_string:</span><span class="w">  </span><span class="p">.</span><span class="n">asciiz</span><span class="w">   </span><span class="s">&quot;I am the best programmer in my seat!&quot;</span>
<span class="nl">end_my_string:</span>

<span class="p">#</span><span class="w"> </span><span class="n">assigns</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">string</span><span class="p">,</span><span class="w"> </span><span class="n">plus</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">null</span><span class="w"> </span><span class="n">terminal</span>
<span class="n">my_string_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end_my_string</span><span class="o">-</span><span class="n">my_string</span>
</code></pre></div>


<p>You may also assign registers to identifiers:</p>
<div class="codehilite"><pre><span></span><code><span class="n">first_year_of_MIPS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1986</span>
<span class="n">year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">$</span><span class="n">t0</span>
<span class="w">    </span><span class="n">li</span><span class="w">    </span><span class="n">year</span><span class="p">,</span><span class="n">first_year_of_MIPS</span><span class="w">    </span><span class="c1"># load 1986 into $t0</span>
</code></pre></div>


<p>Assignment of a register to an identifier must be done before the identifier can
be used as a register; otherwise, the assembler will treat it as an immediate.</p>
<p>The value attached to the identifier is assigned during assembly, and cannot 
be reassigned during runtime. However, it can be reassigned multiple times in
the program source. The assembler will reference the most recent value assigned
to the identifier.</p>
<p>The MIPSym assembler stores these values as integers. If you attempt to assign 
a floating point value to an identifier, it will fail.</p>
<hr />
<p><br />
<br /></p>
<h3 id="repeats">Repeating Data</h3>
<p>The MIPSym assembler provides a means of repeating sections of data, using the 
':' operator. </p>
<p>Suppose you wanted to write a null-terminated string, consisting of 5 copies 
of the letter 'A'. You could (and probably should) use the <code>.asciiz</code> 
assembler directive, but let's see what happens when we use the <code>.byte</code> assembler directive.</p>
<div class="codehilite"><pre><span></span><code>five_As:    .byte   &#39;A:5      # write 5 &#39;A&#39;s
            .byte   0         # null-terminal
</code></pre></div>


<p>The result is a printable string that looks like: <code>"AAAAA\0"</code></p>
<p>Please note that the MIPSym assembler will repeat all of the data on the line, 
not just the value that precedes the ':' operator. If you didn't know that, 
you might be tempted to tack the 0 onto the end of the first line, like this:</p>
<div class="codehilite"><pre><span></span><code>five_A0:    .byte   &#39;A:5,0
</code></pre></div>


<p>This will not yield the same string; instead, it will result in 5 alternating
A's and 0's, like this: <code>"A\0A\0A\0A\0"</code></p>
<hr />
<p><br />
<br /></p>
<h3 id="char_literals">Character literals</h3>
<p>The MIPSym assembler does not currently support Unicode. It interprets all ASCII characters
as being on <a href="https://en.wikipedia.org/wiki/Code_page_437">IBM code page 437</a>.
Some ASCII characters have been overwritten in favor of more useful or convenient
characters: these are the hollow diamond and heart characters and the angle
character, replacing the solid diamond and heart and Peseta characters
respectively. The GUI will automatically convert between Unicode and ASCII on input/output,
so characters can be copy/pasted from Unicode sources without causing issues.
Not all control characters are supported in source code: 0x1a in
particular will prevent your program from being read properly by the assembler.
The use of ASCII over Unicode was done to make it easy for students to develop text-mode games, using
the box-drawing characters in the range 0xb0 to 0xdf. All characters on this
code page have a uniform width and height, which makes ASCII art simple to
draw. This property is not true of some unicode characters, no matter what
font you're using. Each character is exactly 8 bits, or 1 byte, which makes it easy to
reason about the positioning of each character in a buffer, as opposed to the
variable-length characters in <a href="https://en.wikipedia.org/wiki/UTF-8">utf-8</a>.</p>
<p>You may represent character literals in code, preceded by a single quote:</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="n">li</span><span class="w">      </span><span class="o">$</span><span class="n">a0</span><span class="p">,</span><span class="s1">&#39;A      # load 65, the ASCII value for &#39;</span><span class="n">A</span><span class="s1">&#39;, in register $a0</span>
<span class="w">    </span><span class="n">li</span><span class="w">      </span><span class="o">$</span><span class="n">a0</span><span class="p">,</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">     # load 10, the ASCII value for newline, in $a0</span>
<span class="w">    </span><span class="n">li</span><span class="w">      </span><span class="o">$</span><span class="n">a0</span><span class="p">,</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">     # load 39, the value for single quote, in $a0</span>
<span class="w">    </span><span class="n">li</span><span class="w">      </span><span class="o">$</span><span class="n">a0</span><span class="p">,</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">     # load 92, the value for backslash, in $a0</span>
</code></pre></div>


<p>You may find it useful to run the program 'page2ASCII.asm', included in the
'examples' directory. This program prints every character that MIPSym is
capable of printing, alongside the corresponding ASCII values.</p>
<p>The following escape codes are supported by the assembler:</p>
<div class="table-responsive">
  <table class="table">
  <tr>
    <th>Escape code</th>
    <th>ASCII value</th>
    <th>Name</th>
  </tr>
  <tr>
    <td>\a</td>
    <td>7</td>
    <td>Bell</td>
  </tr>
  <tr>
    <td>\b</td>
    <td>8</td>
    <td>Backspace</td>
  </tr>
  <tr>
    <td>\t</td>
    <td>9</td>
    <td>Horizontal Tab</td>
  </tr>
  <tr>
    <td>\n</td>
    <td>10</td>
    <td>Newline</td>
  </tr>
  <tr>
    <td>\v</td>
    <td>11</td>
    <td>Vertical tab</td>
  </tr>
  <tr>
    <td>\f</td>
    <td>12</td>
    <td>Form feed</td>
  </tr>
  <tr>
    <td>\r</td>
    <td>13</td>
    <td>Carriage return</td>
  </tr>
  <tr>
    <td>\xFF</td>
    <td>255</td>
    <td>Hex number: any number between 0 and 255</td>
  </tr>
  <tr>
    <td>\255</td>
    <td>255</td>
    <td>Decimal number: any number between 0 and 255</td>
  </tr>
  <tr>
    <td>\o377</td>
    <td>255</td>
    <td>Octal number: any number between 0 and 255</td>
  </tr>
  <tr>
    <td>\B11111111</td>
    <td>255</td>
    <td>Binary number: any number between 0 and 255</td>
  </tr>
  </table>
</div>

<p>If you need to print '&#8962;' in a string or character literal, you can use the 
escaped hex value:</p>
<div class="codehilite"><pre><span></span><code>    .data
    .ascii  &quot;\x7F&quot;
    .byte   &#39;\x7F
    .code
    li      $a0,&#39;\x7F
</code></pre></div>


<p>Please note that you cannot include raw control characters 
(ASCII values 7-14 and 26) in string literals or character literals.
The assembler will convert these characters to blank space characters, aka ASCII <code>0x20</code>.
Indiscriminate use of these characters can have unpredictable effects,
depending on which platform you are using.
For example, on Windows, the character <code>0x1a</code>, aka the 'substitute' 
character, causes a file IO error when a file is read in text mode. 
This is not a bug; it is a misuse of the text file format.</p>
<p>If you plan on using text editors other than MIPSym to edit assembly 
files, please only use characters within the range [32-126] inclusive. 
Most modern editors expect that text files are encoded in some form of 
Unicode, and characters outside this range will either cause IO errors or 
be interpreted as malformed UTF-8 text.</p>
<p>It is possible to use UTF-8 characters in MIPSym's CLI in ANSI Mode only.
you are encouraged to use escape sequences to form UTF-8 characters. 
For example, to write the UTF-8 form of the character '&#8962;', you would
need to write this sequence of bytes: <code>0xE2 0x8C 0x82</code>
To write this as an ASCII string, you could use:</p>
<div class="codehilite"><pre><span></span><code>house:  .asciiz   &quot;\xE2\x8C\x82&quot;
</code></pre></div>


<p>or:</p>
<div class="codehilite"><pre><span></span><code>house:  .byte     &#39;\xE2,&#39;\x8C,&#39;\x82,0
</code></pre></div>


<p>You can print this string as a UTF-8 character if you are using MIPSymCLI 
in ANSI Mode.  To do this, pass the <code>-a</code> flag to MIPSymCLI at the command line:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>MIPSymCLI<span class="w"> </span>-a<span class="w"> </span>your_utf8_program.obj
</code></pre></div>


<hr />
<p><br />
<br /></p>
<h3 id="keywords">Keywords/Reserved Words</h3>
<p>Unlike SPIM and GCC assembler, MIPSym does not consider assembler directives,
opcodes, or registers to be reserved words. This means that you may 
use labels with the same names as opcodes and assembler directives. 
The assembler can decide whether an identifier should be interpreted
as a label or an opcode/assembler directive based on which field it is in.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Valid code (antipattern):</span>

<span class="c1"># define a label (addi), and store part of the address of that label in $t0</span>
<span class="nl">addi:</span><span class="w">   </span><span class="nf">addi</span><span class="w">    </span><span class="no">$t0</span><span class="p">,</span><span class="no">$0</span><span class="p">,</span><span class="no">addi</span>

<span class="c1"># define a label (.data), and store the address of that label in $s0</span>
<span class="nl">.data:</span><span class="w">  </span><span class="nf">li</span><span class="w">      </span><span class="no">$s0</span><span class="p">,.</span><span class="no">data</span>

<span class="c1"># define a label (.byte), and write 3 copies of the low 8 bits of that label</span>
<span class="nl">.byte:</span><span class="w">  </span><span class="na">.byte</span><span class="w">   </span><span class="no">.byte</span><span class="p">,.</span><span class="no">byte</span><span class="p">,.</span><span class="no">byte</span>
</code></pre></div>


<p><strong>WARNING</strong>: Do not write code like this without a very good reason for
doing so! Redefining opcodes and assembler directives can be fun, but it makes 
your code very hard to read!</p>
<p>If you want to copy this code into MIPSym, make sure it isn't indented before 
you try to build it. Notice that the code highlighter can't figure out that
addi, .data, and .byte are being used as labels and not opcodes or assembler directives.
The highlighter is meant to run fast and to help make your code more readable, 
not to parse nonsense like this.</p>
<hr />
<p><br />
<br /></p>
<h3 id="user_macros">User-Defined Macros</h3>
<p>The MIPSym assembler supports user-defined macros through the use of the <code>.macro</code> and
<code>.end_macro</code> directives. The <code>.macro</code> directive accepts a macro name and a list of
comma or parentheses-separated parameters, separated from the macro name by whitespace.
Custom macro definitions may allow for up to three parameters. Macros should be defined
before their first usage in the source file, or else the assembler will not recognize them.</p>
<div class="codehilite"><pre><span></span><code><span class="p">#</span><span class="w"> </span><span class="n">To</span><span class="w"> </span><span class="n">define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nl">macro:</span>
<span class="w">    </span><span class="p">.</span><span class="n">macro</span><span class="w">    </span><span class="n">name</span><span class="w">  </span><span class="n">params</span>
<span class="w">    </span><span class="p">#</span><span class="w"> </span><span class="n">macro</span><span class="w"> </span><span class="n">body</span>
<span class="w">    </span><span class="p">.</span><span class="n">end_macro</span>

<span class="p">#</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">user</span><span class="o">-</span><span class="n">defined</span><span class="w"> </span><span class="nl">macro:</span>
<span class="w">    </span><span class="p">.</span><span class="n">macro</span><span class="w">    </span><span class="n">swap</span><span class="w">  </span><span class="n">rs</span><span class="p">,</span><span class="n">rt</span><span class="w">      </span><span class="p">#</span><span class="w"> </span><span class="n">swaps</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">integer</span><span class="w"> </span><span class="n">registers</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">rt</span>
<span class="w">    </span><span class="n">mov</span><span class="w">       </span><span class="n">$at</span><span class="p">,</span><span class="n">rs</span>
<span class="w">    </span><span class="n">mov</span><span class="w">       </span><span class="n">rs</span><span class="p">,</span><span class="n">rt</span>
<span class="w">    </span><span class="n">mov</span><span class="w">       </span><span class="n">rt</span><span class="p">,</span><span class="n">$at</span>
<span class="w">    </span><span class="p">.</span><span class="n">end_macro</span>
</code></pre></div>


<p>The first character of each parameter in a macro must match the first character of the
intended datatype of its argument. A list of datatypes supported by the MIPSym assembler
can be found in <a href="#table_explanation">Opcodes and Macros</a>. Macros are limited to 100 lines
maximum; an error will occur if they are any longer.</p>
<p>Users are free to use the assembler temporary register <code>$at</code> in their macros, as well
as assembler-reserved <a href="#local_labels">local labels</a>. However, it should be noted that
in this case, embedding other macros within user-defined macros may lead to side effects.
Users should read the assembler definition file in order to understand potential risks.</p>
<hr />
<p><br />
<br /></p>
<h3 id="include">Include Directive</h3>
<p>The MIPSym assembler supports a <code>.include</code> directive, which allows for
multiple source files to be combined into one. This replaces the need
for a linking loader or makefile. Namespaces are not supported, so care
should be taken to ensure duplicate labels are not created across source
files; it's recommended to use <a href="#local_labels">local labels</a> generously. This also means that files
which do not assemble independently due to missing labels can be assembled
when these labels are provided by another source file.</p>
<p>Both relative and absolute file paths are supported, so include directives can be
written as such:</p>
<div class="codehilite"><pre><span></span><code>#<span class="w"> </span><span class="nv">To</span><span class="w"> </span><span class="k">include</span><span class="w"> </span><span class="nv">files</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">same</span><span class="w"> </span><span class="nv">directory</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">main</span><span class="w"> </span><span class="nv">source</span>:
<span class="w">    </span>.<span class="k">include</span><span class="w">  </span><span class="s2">&quot;source-one.asm&quot;</span>
<span class="w">    </span>.<span class="k">include</span><span class="w">  </span><span class="s2">&quot;./source-two.asm&quot;</span>

#<span class="w"> </span><span class="nv">To</span><span class="w"> </span><span class="k">include</span><span class="w"> </span><span class="nv">files</span><span class="w"> </span><span class="nv">which</span><span class="w"> </span><span class="nv">are</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">different</span><span class="w"> </span><span class="nv">directories</span>:
<span class="w">    </span>.<span class="k">include</span><span class="w">  </span><span class="s2">&quot;../filepath/source-one.asm&quot;</span>
<span class="w">    </span>.<span class="k">include</span><span class="w">  </span><span class="s2">&quot;subdirectory/source-two.asm&quot;</span>
<span class="w">    </span>.<span class="k">include</span><span class="w">  </span><span class="s2">&quot;C:/Users/Name/Asm-Files/source-three.asm&quot;</span>
</code></pre></div>


<p>The assembler searches for files at their location relative to the including source
file, but the assembled .obj file will reference files relative to the main source.
This allows users to move their source files, as long as included files are in the same
relative locations as they were at assembly time.</p>
<p>It is best form to include a section directive at the beginning of any included
file; otherwise the <code>.include</code> directive will assume the same section as the including
file. For this reason, do not use section directives before <code>.include</code>; it will lead
to either redundant or unreliable code. There is no need to put section directives
at the end of included files either; the assembler will automatically return to the
including file's section afterwards.</p>
<hr />
<p><br />
<br /></p>
<h3 id="other">Syscalls, Register Names, Assembler Directives, and Macros</h3>
<p>MIPSym aims to provide good compatibility with SPIM, but some differences exist.
MIPSym adds several <a href="#mipsym_syscalls">syscalls that do not exist in SPIM</a>, 
a few <a href="#fp_math_opcodes">nonstandard floating-point instructions</a>, and many 
convenient <a href="#macros">macros</a> that do not exist in SPIM or GCC.
Specific differences are discussed in the appropriate section of the 
<a href="#reference">Quick Reference Guide</a>.</p>
<hr />
<p><br />
<br /></p>
<h1 id="reference">Quick Reference Guide</h1>
<p>This section presents a listing of all assembler directives,
syscalls, registers, opcodes, and macros. Please note that all the information
presented here is available within MIPSym's code editor, in the form of 
tooltips. Within the editor, just hover your mouse over a term that you
are interested in, and the documentation for that term will pop up.</p>
<hr />
<p><br />
<br /></p>
<h2 id="pseudos">Assembler Directives</h2>
<p>MIPSym handles a superset of the assembler directives that SPIM and the
GCC assembler support. A full listing of these is provided here.</p>
<div class="table-responsive">
  <table class="table">
    <thead>
      <tr>
          <th>Pseudo Name</th>
          <th>Arguments</th>
          <th>Comment</th>
      </tr>
    </thead>
    <tbody>
        <tr>
            <td>.align</td>
            <td>n</td>
            <td>Increment the location counter to make the n low order bits of the counter 0. <br> If n is zero, turns off auto alignment.</td>
        </tr>
        <tr>
            <td>.ascii</td>
            <td>string delimited by double quotes</td>
            <td>Writes a string without marking an endpoint</td>
        </tr>
        <tr>
            <td>.asciiz</td>
            <td>string delimited by double quotes</td>
            <td>Writes a null-terminated string</td>
        </tr>
        <tr>
            <td>.byte</td>
            <td>comma-separated ints or expressions</td>
            <td>Writes data in 8-bit chunks</td>
        </tr>
        <tr>
            <td>.code</td>
            <td>optional address</td>
            <td>Enters the section of the program that contains code. <br> Alias for '.text'</td>
        </tr>
        <tr>
            <td>.data</td>
            <td>optional address</td>
            <td>Enters the section of the program that contains data</td>
        </tr>
        <tr>
            <td>.delay</td>
            <td>no args</td>
            <td>Turns on branch-delay mode: the simulator will execute the first instruction following a branch instruction before taking the branch. <br> The assembler will use special versions of macros containing branches. <br> Should be the first line of a program.</td>
        </tr>
        <tr>
            <td>.double</td>
            <td>comma-separated doubles</td>
            <td>Writes 64-bit floating point datapoints</td>
        </tr>
        <tr>
            <td>.dword</td>
            <td>comma-separated ints</td>
            <td>Writes data in 64-bit chunks # Numbers only</td>
        </tr>
        <tr>
            <td>.end_macro</td>
            <td>no args</td>
            <td>Ends a macro defined using .macro</td>
        </tr>
        <tr>
            <td>.endr</td>
            <td>no args</td>
            <td>Not implemented! <br> Ends the repeated section begun by .repeat.</td>
        </tr>
        <tr>
            <td>.extern</td>
            <td>name of variable, size of variable</td>
            <td>Defines a global symbol offset from the $gp, whose size is n bytes.</td>
        </tr>
        <tr>
            <td>.external</td>
            <td>name of variable</td>
            <td>Declares that a symbol is externally visible so it can be referenced by other files via $gp</td>
        </tr>
        <tr>
            <td>.float</td>
            <td>comma-separated floats</td>
            <td>Writes 32-bit floating point datapoints</td>
        </tr>
        <tr>
            <td>.global</td>
            <td>name of variable, size of variable</td>
            <td>Defines a global symbol whose size is n bytes.</td>
        </tr>
        <tr>
            <td>.globl</td>
            <td>name of variable</td>
            <td>Declares that a symbol is externally visible so it can be referenced by other files via $gp</td>
        </tr>
        <tr>
            <td>.half</td>
            <td>comma-separated ints</td>
            <td>Writes data in 16-bit chunks</td>
        </tr>
        <tr>
            <td>.include</td>
            <td>filepath delimited by double quotes</td>
            <td>Includes a source file</td>
        </tr>
        <tr>
            <td>.kcode</td>
            <td>optional address</td>
            <td>Enters the section of the program that contains kernel code</td>
        </tr>
        <tr>
            <td>.kdata</td>
            <td>optional address</td>
            <td>Enters the section of the program that contains data, accessible by the kernel</td>
        </tr>
        <tr>
            <td>.ktext</td>
            <td>optional address</td>
            <td>Enters the section of the program that contains kernel code</td>
        </tr>
        <tr>
            <td>.macro</td>
            <td>name of macro, comma-separated parameters</td>
            <td>Defines a custom macro. <br> Parameters must begin with the character corresponding to their type (see Help > MIPSym Help > Documentation). <br> End with .end_macro</td>
        </tr>
        <tr>
            <td>.repeat</td>
            <td>number of repetitions</td>
            <td>Not implemented! <br> Repeats all instructions or data between the .repeat and .endr directives.</td>
        </tr>
        <tr>
            <td>.sdata</td>
            <td>optional address</td>
            <td>Enters the small data section; <br>  accessible via $gp using 16-bit addressing</td>
        </tr>
        <tr>
            <td>.space</td>
            <td>number of bytes</td>
            <td>Adds n bytes of empty space</td>
        </tr>
        <tr>
            <td>.struct</td>
            <td>optional argument: defines inheritance from another struct</td>
            <td>Defines a data structure type as the label. <br> The value of the label is the length of the structure in bytes. <br> Subsequent items are included in the structure until the next segment directive or another struct.</td>
        </tr>
        <tr>
            <td>.text</td>
            <td>optional address</td>
            <td>Enters the section of the program that contains code.</td>
        </tr>
        <tr>
            <td>.word</td>
            <td>comma-separated ints</td>
            <td>Writes data in 32-bit chunks</td>
        </tr>
    </tbody>
  </table>
</div>

<hr />
<p><br />
<br /></p>
<h2 id="syscalls">Syscalls</h2>
<p>Like SPIM, MIPSym employs syscalls to handle operations that would
otherwise be very tedious to write. MIPSym provides compatibility
with all of SPIM's syscalls and allows you to call them the same 
way. MIPSym also provides its own syntax for syscalls, which is smaller,
more concise and readable.</p>
<div class="codehilite"><pre><span></span><code><span class="gh">#</span> Valid code (SPIM syntax, deprecated in MIPSym):
    li      $v0,5     # 5 denotes the read_int syscall
    syscall           # runs the syscall in $v0
<span class="gh">#</span> Valid code (MIPSym syntax):
    syscall $read_int # runs the read_int syscall directly
</code></pre></div>


<p>MIPSym supports all of the syscalls that SPIM supports. A full 
listing of these syscalls is provided here.</p>
<p><br />
<br /></p>
<h3 id="spim_syscalls">SPIM-Compatible Syscalls</h3>
<div class="table-responsive">
  <table class="table">
    <thead>
      <tr>
          <th>Syscall Name</th>
          <th>Arguments</th>
          <th>Comment</th>
      </tr>
    </thead>
    <tbody>
        <tr>
            <td>$close</td>
            <td>$a0 holds file handle</td>
            <td>Closes file</td>
        </tr>
        <tr>
            <td>$exit</td>
            <td>no args</td>
            <td>ends program</td>
        </tr>
        <tr>
            <td>$exit2</td>
            <td>$a0 holds return value</td>
            <td>ends program, returning the value in $a0</td>
        </tr>
        <tr>
            <td>$malloc</td>
            <td>$a0 holds number of bytes requested.</td>
            <td>Returns address in $v0</td>
        </tr>
        <tr>
            <td>$open</td>
            <td>$a0 holds address of filename, <br> $a1 holds flags, <br> $a2 holds mode.</td>
            <td>Returns file handle in $v0</td>
        </tr>
        <tr>
            <td>$print_char</td>
            <td>$a0 holds char to print</td>
            <td>prints char in $a0</td>
        </tr>
        <tr>
            <td>$print_double</td>
            <td>$a0 holds double to print</td>
            <td>prints double in $f12</td>
        </tr>
        <tr>
            <td>$print_float</td>
            <td>$a0 holds float to print</td>
            <td>prints float in $f12</td>
        </tr>
        <tr>
            <td>$print_int</td>
            <td>$a0 holds int to print</td>
            <td>prints integer in $a0</td>
        </tr>
        <tr>
            <td>$print_string</td>
            <td>$a0 holds string to print</td>
            <td>prints string in memory at $a0</td>
        </tr>
        <tr>
            <td>$read</td>
            <td>$a0 holds file handle, <br> $a1 holds buffer address, <br> $a2 holds buffer length.</td>
            <td>Returns number of bytes read in $v0</td>
        </tr>
        <tr>
            <td>$read_char</td>
            <td>no args</td>
            <td>returns char from console input in $v0</td>
        </tr>
        <tr>
            <td>$read_double</td>
            <td>no args</td>
            <td>returns double from console input in $f0</td>
        </tr>
        <tr>
            <td>$read_float</td>
            <td>no args</td>
            <td>returns float from console input in $f0</td>
        </tr>
        <tr>
            <td>$read_int</td>
            <td>no args</td>
            <td>returns integer from console input in $v0</td>
        </tr>
        <tr>
            <td>$read_string</td>
            <td>$a0 holds address of buffer in memory, <br> $a1 holds buffer length.</td>
            <td>Returns string length in $v0</td>
        </tr>
        <tr>
            <td>$write</td>
            <td>$a0 holds file handle, <br> $a1 holds buffer address, <br> $a2 holds buffer length.</td>
            <td>Returns number of bytes written in $v0</td>
        </tr>
    </tbody>
  </table>
</div>

<p><br /></p>
<h3 id="mipsym_syscalls">MIPSym-Specific Syscalls</h3>
<div class="table-responsive">
  <table class="table">
    <thead>
      <tr>
          <th>Syscall Name</th>
          <th>Arguments</th>
          <th>Comment</th>
      </tr>
    </thead>
    <tbody>
        <tr>
            <td>$IO_read</td>
            <td>$a0 holds address, <br> $a1 holds number of bytes {1,2,4}.</td>
            <td>Returns data in $v0</td>
        </tr>
        <tr>
            <td>$IO_write</td>
            <td>$a0 holds address, <br> $a1 holds number of bytes {1,2,4}, <br> $a2 holds data to write</td>
            <td>writes data to hardware</td>
        </tr>
        <tr>
            <td>$callback</td>
            <td>$a0 holds address of interrupt callback routine, <br> $a1 holds interrupt number [2-7]</td>
            <td>assigns callback function</td>
        </tr>
        <tr>
            <td>$close_cons</td>
            <td>$a0 holds id of console to close</td>
            <td>Unimplemented</td>
        </tr>
        <tr>
            <td>$date_time</td>
            <td>no args</td>
            <td>Returns local datetime, spanned across $v0-$v1. <br> Bits from high($v1) to low($v0): 23 bits=year, 4=month, 5=day, 5=hour, 6=min, 6=sec, 10=mil, 5=local timezone offset from UTC</td>
        </tr>
        <tr>
            <td>$flush_print</td>
            <td>no args</td>
            <td>transfers the screen buffer to console, avoiding flicker.</td>
        </tr>
        <tr>
            <td>$free</td>
            <td>$a0 holds address of buffer to free</td>
            <td>Frees memory at address</td>
        </tr>
        <tr>
            <td>$open_cons</td>
            <td>$a0 is console height, <br> $a1 is console width</td>
            <td>Unimplemented</td>
        </tr>
        <tr>
            <td>$position</td>
            <td>$a0 holds file handle, <br> $a1 holds number of bytes from $a2, <br> $a2 = start / current / end of file: 0/1/2</td>
            <td>Returns absolute position in $v0</td>
        </tr>
        <tr>
            <td>$random</td>
            <td>no args</td>
            <td>Copies the RANDOM register to $v0. <br> RANDOM counts down with each instruction run since the program began. <br> Commonly used to seed an RNG algorithm after waiting for user input.</td>
        </tr>
        <tr>
            <td>$select_cons</td>
            <td>$a0 holds id of console to select</td>
            <td>Unimplemented</td>
        </tr>
        <tr>
            <td>$spool_print</td>
            <td>no args</td>
            <td>holds outputs to screen buffer until $flush_print</td>
        </tr>
        <tr>
            <td>$string2double</td>
            <td>$a0 holds address of input string</td>
            <td>Returns double in $f0 converted from string in memory at $a0</td>
        </tr>
        <tr>
            <td>$utc_date_time</td>
            <td>no args</td>
            <td>Returns datetime in Universal Coordinated Time, spanned across $v0-$v1. <br> Bits from high($v1) to low($v0): 23 bits=year, 4=month, 5=day, 5=hour, 6=min, 6=sec, 10=mil, 5=local timezone offset from UTC</td>
        </tr>
        <tr>
            <td>$utc_millis</td>
            <td>no args</td>
            <td>Returns the number of milliseconds since the Unix Epoch, in Universal Coordinated Time, spanned across $v0-$v1</td>
        </tr>
        <tr>
            <td>$xy</td>
            <td>$a0 holds cursor column [0-79], <br> $a1 holds cursor row [0-24].</td>
            <td>Positions Cursor on the console. <br> Returns character at ($a0,$a1) in $v0.</td>
        </tr>
    </tbody>
  </table>
</div>

<hr />
<p><br />
<br /></p>
<h2 id="registers">Register Names</h2>
<p>The GCC assembler refers to registers only by their numeric values,
$0-$31. By default MIPSym does not allow the use of $0-$31 as register names,
unless you define the symbols $0-$31 in your own code 
(see <a href="#aliasing">aliasing</a>) or add them to MIPSym/asm/mips1.adf.
For example, in your own code you could type the following (unindented):</p>
<div class="codehilite"><pre><span></span><code>$31 = $ra
</code></pre></div>


<p>MIPSym uses the register names enumerated below. SPIM allows the use of 
either type of register name. Code written for SPIM or GCC must be
adjusted accordingly before the MIPSym assembler will be able to 
assemble it. </p>
<p><br /></p>
<h3 id="int_registers">Integer Registers</h3>
<div class="table-responsive">
  <table class="table">
  <tr>
    <th>GCC name</th>
    <th>MIPSym name</th>
    <th>Purpose</th>
  </tr>
  <tr>
    <td>$0</td>
    <td>$zero $0</td>
    <td>Always 0</td>
  </tr>
  <tr>
    <td>$1</td>
    <td>$at</td>
    <td>Assembler Temporary</td>
  </tr>
  <tr>
    <td>$2-$3</td>
    <td>$v0-$v1</td>
    <td>Function return values/ syscall choice</td>
  </tr>
  <tr>
    <td>$4-$7</td>
    <td>$a0-$a3</td>
    <td>Function arguments</td>
  </tr>
  <tr>
    <td>$8-$15</td>
    <td>$t0-$t7</td>
    <td>Temporary storage, not saved</td>
  </tr>
  <tr>
    <td>$16-$23</td>
    <td>$s0-$s7</td>
    <td>Saved storage, not overwritten</td>
  </tr>
  <tr>
    <td>$24-$25</td>
    <td>$t8-$t9</td>
    <td>Temporary storage, not saved</td>
  </tr>
  <tr>
    <td>$26-$27</td>
    <td>$k0-$k1</td>
    <td>For kernel use only</td>
  </tr>
  <tr>
    <td>$28</td>
    <td>$gp</td>
    <td>Global pointer</td>
  </tr>
  <tr>
    <td>$29</td>
    <td>$sp</td>
    <td>Stack pointer</td>
  </tr>
  <tr>
    <td>$30</td>
    <td>$fp</td>
    <td>Frame pointer</td>
  </tr>
  <tr>
    <td>$31</td>
    <td>$ra</td>
    <td>Return address</td>
  </tr>
  </table>
</div>

<p><br /></p>
<h3 id="flt_registers">Floating Point Registers</h3>
<div class="table-responsive">
  <table class="table">
  <tr>
    <th>GCC name</th>
    <th>MIPSym name</th>
    <th>Purpose</th>
  </tr>
  <tr>
    <td>$0-$31</td>
    <td>$f0-$f31</td>
    <td>Floating point registers in coprocessor 1</td>
  </tr>
  </table>
</div>

<p><br /></p>
<h3 id="cp0_registers">Coprocessor 0 Control Registers</h3>
<div class="table-responsive">
  <table class="table">
    <thead>
      <tr>
          <th>GCC Name</th>
          <th>MIPSym Name</th>
          <th>Register Type</th>
      </tr>
    </thead>
    <tbody>
        <tr>
            <td>$0</td>
            <td>$INDEX</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$1</td>
            <td>$RANDOM</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$10</td>
            <td>$ENTRY_HI</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$11</td>
            <td>$COMPARE</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$12</td>
            <td>$STATUS</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$13</td>
            <td>$CAUSE</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$14</td>
            <td>$EPC</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$15</td>
            <td>$PRID</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$16</td>
            <td>$CONFIG</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$17</td>
            <td>$LLADDR</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$18</td>
            <td>$WATCH_LO</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$19</td>
            <td>$WATCH_HI</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$2</td>
            <td>$ENTRY_LO</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$26</td>
            <td>$ECC</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$27</td>
            <td>$CACHE_ERR</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$28</td>
            <td>$TAG_LO</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$29</td>
            <td>$TAG_HI</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$3</td>
            <td>$ENTRY_LO1</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$30</td>
            <td>$ERROR_EPC</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$4</td>
            <td>$CONTEXT</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$5</td>
            <td>$PAGEMASK</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$6</td>
            <td>$WIRED</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$7</td>
            <td>$ERROR</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$8</td>
            <td>$BAD_V_ADDR</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
        <tr>
            <td>$9</td>
            <td>$COUNT</td>
            <td>Coprocessor 0 Control Register</td>
        </tr>
    </tbody>
  </table>
</div>

<p><br /></p>
<h3 id="cp1_registers">Coprocessor 1 Control Registers</h3>
<div class="table-responsive">
  <table class="table">
    <thead>
      <tr>
          <th>GCC Name</th>
          <th>MIPSym Name</th>
          <th>Register Type</th>
      </tr>
    </thead>
    <tbody>
        <tr>
            <td>$0</td>
            <td>$FCR0</td>
            <td>Coprocessor 1 Control Register</td>
        </tr>
        <tr>
            <td>$31</td>
            <td>$FCR31</td>
            <td>Coprocessor 1 Control Register</td>
        </tr>
    </tbody>
  </table>
</div>

<hr />
<p><br />
<br /></p>
<h2 id="opcodes">Opcodes and Macros</h2>
<hr />
<p><br />
<br /></p>
<h3 id="table_explanation">How to read these tables</h3>
<p>These tables present each opcode or macro in the R2000 instruction set, along 
with its required arguments, and in most cases a brief comment to describe 
what the instruction does.</p>
<p>In general, the destination argument comes first in an argument list, and the 
source operand(s) come afterwards. However, five of instructions have this 
order backwards: mtc0, sb, sh, sw, swl, and swr. These instructions have 
comments marked in bold to warn you of this.</p>
<p>There are several kinds of arguments:</p>
<ul>
<li>Imm: This stands for 'immediate value'. This can be any signed or unsigned, 32-bit constant integer 
    value. It can be a number, an <a href="#aliasing">alias</a>, or a 
    <a href="#expressions">mathematical expression</a>. Note that whether or not Imm is treated as signed
    or unsigned will depend on the operation being performed.</li>
<li>imm: This stands for 'immediate value'. This is similar to 'Imm', but only occupies 16 bits.</li>
<li>uimm: This stands for 'unsigned immediate value'. This is similar to 'Uimm', but only occupies
    16 bits.</li>
<li>label: This is exactly the same as a 32-bit 'immediate value'. The assembler sees
    both as integers, and it doesn't care whether it's really a label, or just 
    some number you made up. The distinction is meant to show you how the 
    instructions are meant to be used, and to help other programmers to 
    understand your code.</li>
<li>sn: This stands for 'shift number'. It can hold any unsigned 5-bit constant integer value.</li>
<li>oimm: This stands for 'offset immediate'. It is exactly the same as a 16-bit 'imm' value.</li>
<li>rd/rs/rt: These symbols denote integer <a href="#int_registers">registers</a>. Usually, 
  the 'd' stands for 'destination' and the 's' stands for 'source.' 
  In the majority of the instructions (r-form instructions), the 't' 
    stands for 'second source' (t comes right after s in the alphabet). Most of 
  the remaining instructions (i-form instructions) use 'rt' as the destination 
  register instead, and rd is unused.</li>
<li>fd/fs/ft: These symbols denote single floating point registers ($f0-31). The 
    same general rule for d, s, and t that applies to the integer registers also 
    applies here.</li>
<li>
<p>dd/ds/dt: These symbols denote double floating point registers: floating 
    point registers with even numbers ($f0-30). The R2000 has 32-bit floating 
    point registers, so a single 64-bit value needs to be spanned across two 
    32-bit registers. For example:</p>
<div class="codehilite"><pre><span></span><code><span class="p">#</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">$f2</span><span class="o">-</span><span class="n">$f3</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">$f4</span><span class="o">-</span><span class="n">$f5</span><span class="p">,</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">$f0</span><span class="o">-</span><span class="n">$f1</span>
<span class="w">    </span><span class="n">add</span><span class="p">.</span><span class="n">d</span><span class="w">   </span><span class="n">$f0</span><span class="p">,</span><span class="n">$f2</span><span class="p">,</span><span class="n">$f4</span>
<span class="p">#</span><span class="w"> </span><span class="n">Attempt</span><span class="w"> </span><span class="n">addition</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="nl">registers:</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="n">behavior</span><span class="p">,</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">assemble</span><span class="o">!</span>
<span class="w">    </span><span class="n">add</span><span class="p">.</span><span class="n">d</span><span class="w">   </span><span class="n">$f6</span><span class="p">,</span><span class="n">$f8</span><span class="p">,</span><span class="n">$f9</span>
</code></pre></div>


</li>
<li>
<p>Cd/Cs/Ct: These symbols denote <a href="#cp0_registers">registers in Coprocessor 0</a>, 
    the System Control Processor.</p>
</li>
<li>Fd/Fs/Ft: These symbols denote control word registers in Coprocessor 1 
    ($FCR0 &amp; $FCR31).</li>
</ul>
<p>The assembler performs type checking for data types; attempting to pass incompatibly
signed or over/underflowed values to immediate fields will only generate a warning message,
but incorrect use of registers will produce an error. Expressions are treated as being the
type of the first operand. The assembler does not currently support under/overflow checking for
expressions or 32-bit immediates, however, so caution is advised.</p>
<p>Comments field: The comment field usually includes some pseudocode to describe 
what the instruction does. This pseudocode includes some abbreviations that 
may not be clear at first:</p>
<ul>
<li>RF[Rs]: The 'RF' stands for 'Register File', and the Rs denotes the source register.
    This notation makes more sense if you think of all 32 integer registers as an
    array of integers. If the source register is $t0 ($t0 is the 8th register), then
    Rf[Rs] evaluates to the value in register $t0.</li>
<li>FpRf[fs]: The 'FpRf' stands for 'Floating Point Register File,' and the 'fs'
    denotes the source register.</li>
<li>un(): This stands for the 'unordered' function. In this context, it means 
    'check to see if this value is NaN.' See <a href="https://en.wikipedia.org/wiki/NaN">Wikipedia NaN</a></li>
</ul>
<p>Memory offsets: Several instructions have the last argument in parentheses. For
example, the instruction 'lb' takes the arguments 'rt,oimm(rs)'. The comment 
includes the pseudocode 'RF[Rt] = Mem[RF[Rs] + Offset]'. 'Mem' stands for MIPSym's 
simulated memory. It is expected that Rs is an integer register that holds a 
pointer to a particular location in memory. 'Offset' is the 'oimm' in the second 
argument: here, it is used as an offset from the pointer in Rs. So, the 'lb' 
instruction finds the memory that Rs points to, looks 'oimm' bytes away from 
that address, and copies the byte at that location into Rt.</p>
<p>Note that any instruction that takes the arguments 'rt,oimm(rs)' will also take 
the arguments 'rt,(rs)'. The assembler will interpret the offset as 0 in this 
case.</p>
<hr />
<p><br />
<br /></p>
<h3 id="int_opcodes">Integer Instruction Set</h3>
<p>Most of these instructions are standard on the R2000/R3000. A few of these 
are from later processors; these are marked as 'Unimplemented.' </p>
<div class="table-responsive">
  <table class="table">
    <thead>
      <tr>
          <th>Opcode Name</th>
          <th>Arguments</th>
          <th>Comment</th>
          <th>Form</th>
      </tr>
    </thead>
    <tbody>
        <tr>
            <td>add</td>
            <td>rd,rs,rt</td>
            <td>Add <br> RF[Rd] = RF[Rs] + RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>add</td>
            <td>rt,rs,imm</td>
            <td>Add <br> alias for <strong>addi rt,rs,imm</strong> <br> RF[Rt] = RF[Rs] + Imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>addi</td>
            <td>rt,rs,imm</td>
            <td>Add Immediate <br> RF[Rt] = RF[Rs] + Imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>addiu</td>
            <td>rt,rs,imm</td>
            <td>Add Immediate Unsigned <br> RF[Rt] = RF[Rs] + Imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>addu</td>
            <td>rd,rs,rt</td>
            <td>Add Unsigned <br> RF[Rd] = RF[Rs] + RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>addu</td>
            <td>rt,rs,imm</td>
            <td>Add Unsigned <br> alias for <strong>addiu rt,rs,imm</strong> <br> RF[Rt] = RF[Rs] + imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>and</td>
            <td>rd,rs,rt</td>
            <td>Bitwise And <br> RF[Rd] = RF[Rs] & RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>andi</td>
            <td>rt,rs,uimm</td>
            <td>Bitwise And Immediate <br> RF[Rt] = RF[Rs] & Imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>b</td>
            <td>label</td>
            <td>Branch <br> alias for <strong>bgez $0,label</strong> <br> PC = label</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bc0f</td>
            <td>label</td>
            <td>Branch Coprocessor0 True <br> This is a do nothing.  It used to test a pin on the part.</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bc0t</td>
            <td>label</td>
            <td>Branch Coprocessor0 False <br> This is a do nothing.  It used to test a pin on the part.</td>
            <td>i</td>
        </tr>
        <tr>
            <td>beq</td>
            <td>rs,rt,label</td>
            <td>Branch Equal <br> If (RF[Rs] == RF[Rt] )then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>beqz</td>
            <td>rs,label</td>
            <td>Branch Equal to Zero <br> alias for <strong>beq rs,$0,label</strong> <br> If (RF[Rs] == 0) then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bgez</td>
            <td>rs,label</td>
            <td>Branch Greater than or Equal to Zero <br> If (RF[Rs] >= RF[0]) then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bgezal</td>
            <td>rs,label</td>
            <td>Branch Greater than or Equal to Zero And Link <br> If ( RF[Rs] >= RF[0] ) then {RF[$ra] = PC; PC = PC + Imm<< 2 }</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bgtz</td>
            <td>rs,label</td>
            <td>Branch Greater Than Zero <br> If (RF[Rs] > RF[0] ) then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>blez</td>
            <td>rs,label</td>
            <td>Branch Less than or Equal to Zero <br> If (RF[Rs] <= RF[0]) then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bltz</td>
            <td>rs,label</td>
            <td>Branch Less Than Zero <br> If RF[Rs] < RF[0] then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bltzal</td>
            <td>rs,label</td>
            <td>Branch Less Than Zero And Link <br> If ( RF[Rs] <  RF[0] ) then {RF[$ra] = PC; PC = PC + Imm<< 2 }</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bne</td>
            <td>rs,rt,label</td>
            <td>Branch Not Equal <br> If RF[Rs] != RF[Rt] then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bnez</td>
            <td>rs,label</td>
            <td>Branch Not Equal to Zero <br> alias for <strong>bne rs,$0,label</strong> <br> If RF[Rs] != 0 then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>break</td>
            <td>Bcode</td>
            <td>pause execution</td>
            <td>b</td>
        </tr>
        <tr>
            <td>break</td>
            <td>Icode</td>
            <td>pause execution</td>
            <td>b</td>
        </tr>
        <tr>
            <td>break</td>
            <td></td>
            <td>pause execution <br> alias for <strong>break 0</strong></td>
            <td>b</td>
        </tr>
        <tr>
            <td>div</td>
            <td>rs,rt</td>
            <td>Divide (signed) <br> Low = Quotient ( RF[Rs] / RF[Rt] ); <br> High = Remainder ( RF[Rs] / RF[Rt] )</td>
            <td>r</td>
        </tr>
        <tr>
            <td>divu</td>
            <td>rs,rt</td>
            <td>Divide Unsigned <br> Low = Quotient ( RF[Rs] / RF[Rt] ); <br> High = Remainder ( RF[Rs] / RF[Rt] )</td>
            <td>r</td>
        </tr>
        <tr>
            <td>j</td>
            <td>label</td>
            <td>Jump <br> PC = PC(31:28) | Imm<< 2</td>
            <td>j</td>
        </tr>
        <tr>
            <td>jal</td>
            <td>label</td>
            <td>Jump And Link <br> RF[$ra] = PC; <br> PC = PC(31:28) | Imm<< 2</td>
            <td>j</td>
        </tr>
        <tr>
            <td>jalr</td>
            <td>rd,rs</td>
            <td>Jump And Link Register <br> RF[Rd] = PC; <br> PC = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>jalr</td>
            <td>rs</td>
            <td>Jump And Link Register <br> alias for <strong>jalr $ra,rs</strong> <br> $ra = PC; <br> PC = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>jr</td>
            <td>rs</td>
            <td>Jump Register <br> PC = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>lb</td>
            <td>rt,oimm(rs)</td>
            <td>Load Byte <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lbu</td>
            <td>rt,oimm(rs)</td>
            <td>Load Byte Unsigned <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lh</td>
            <td>rt,oimm(rs)</td>
            <td>Load Half <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lhu</td>
            <td>rt,oimm(rs)</td>
            <td>Load Half Unsigned <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>ll</td>
            <td>rt,oimm(rs)</td>
            <td>Load Linked <br> Unimplemented</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lui</td>
            <td>rt,uimm</td>
            <td>Load Upper Immediate <br> RF[Rt] = Imm<<16</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lw</td>
            <td>rt,oimm(rs)</td>
            <td>Load Word <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lwl</td>
            <td>rt,oimm(rs)</td>
            <td>Load Word Left <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lwr</td>
            <td>rt,oimm(rs)</td>
            <td>Load Word Right <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>mfc0</td>
            <td>rt,Cd</td>
            <td>Move From Coprocessor0: <br> Rf[rt] = CP0Rf[cd]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mfhi</td>
            <td>rd</td>
            <td>Move From Hi <br> RF[Rd] = HIGH</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mflo</td>
            <td>rd</td>
            <td>Move From Low <br> RF[Rd] = LOW</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mov</td>
            <td>rd,rs</td>
            <td>Move <br> alias for <strong>addu rd,rs,$0</strong> <br> RF[Rd] = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>move</td>
            <td>rd,rs</td>
            <td>Move <br> alias for <strong>addu rd,rs,$0</strong> <br> RF[Rd] = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mtc0</td>
            <td><strong>rt,Cd</strong></td>
            <td>Move To Coprocessor0: <br> CP0Rf[cd] = Rf[rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>r</td>
        </tr>
        <tr>
            <td>mthi</td>
            <td>rs</td>
            <td>Move To Hi <br> HIGH = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mtlo</td>
            <td>rs</td>
            <td>Move To Low <br> LOW = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mult</td>
            <td>rs,rt</td>
            <td>Multiply (signed) <br> High |Low = RF[Rs] * RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>multu</td>
            <td>rs,rt</td>
            <td>Multiply Unsigned <br> High |Low = RF[Rs] * RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>neg</td>
            <td>rd,rt</td>
            <td>Negate <br> alias for <strong>sub rd,$0,rt</strong> <br> RF[Rd] = -RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>negu</td>
            <td>rd,rt</td>
            <td>Negate <br> alias for <strong>subu rd,$0,rt</strong> <br> RF[Rd] = -RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>nop</td>
            <td></td>
            <td>no operation <br> alias for <strong>sll $0,$0,0</strong></td>
            <td>r</td>
        </tr>
        <tr>
            <td>nor</td>
            <td>rd,rs,rt</td>
            <td>Bitwise Nor <br> RF[Rd] = !(RF[Rs] | RF[Rt])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>not</td>
            <td>rd,rs</td>
            <td>Boolean Not <br> alias for <strong>nor rd,rs,$0</strong> <br> RF[Rd] = !(RF[Rs] | 0)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>or</td>
            <td>rd,rs,rt</td>
            <td>Bitwise Or <br> RF[Rd] = RF[Rs] | RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ori</td>
            <td>rt,rs,uimm</td>
            <td>Bitwise Or Immediate <br> RF[Rt] = RF[Rs] | Imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>rfe</td>
            <td></td>
            <td>Restore From Exception <br>restores the status register to its value before the last exception occurred.</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sb</td>
            <td><strong>rt,oimm(rs)</strong></td>
            <td>Store Byte: <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>sgt</td>
            <td>rd,rt,rs</td>
            <td>Set Greater Than <br> alias for <strong>slt rd,rs,rt</strong> <br> if (RF[Rt] > RF[Rs] ) then RF[Rd] =1 else RF[Rd] = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sgtu</td>
            <td>rd,rt,rs</td>
            <td>Set Greater Than Unsigned <br> alias for <strong>sltu rd,rs,rt</strong> <br> if (RF[Rt] > RF[Rs] ) then RF[Rd] =1 else RF[Rd] = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sh</td>
            <td><strong>rt,oimm(rs)</strong></td>
            <td>Store Half: <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>sll</td>
            <td>rd,rt,sn</td>
            <td>Shift Left Logical (immediate) <br> RF[Rd] = RF[Rt] << n</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sll</td>
            <td>rd,rt,rs</td>
            <td>Shift Left Logical <br> alias for <strong>sllv rd,rt,rs</strong> <br> RF[Rd] = RF[Rt] << RF[Rs] amount</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sllv</td>
            <td>rd,rt,rs</td>
            <td>Shift Left Logical Variable <br> RF[Rd] = RF[Rt] << RF[Rs] amount</td>
            <td>r</td>
        </tr>
        <tr>
            <td>slt</td>
            <td>rd,rs,rt</td>
            <td>Set Less Than <br> if (RF[Rs] < RF[Rt] ) then RF[Rd] =1 else RF[Rd] = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>slti</td>
            <td>rt,rs,imm</td>
            <td>Set Less Than Immediate <br> if (RF[Rs] < Imm) then RF[Rt] = 1 else RF[Rt] = 0</td>
            <td>i</td>
        </tr>
        <tr>
            <td>sltiu</td>
            <td>rt,rs,imm</td>
            <td>Set Less Than Immediate Unsigned <br> if (RF[Rs] < Imm) then RF[Rt] = 1 else RF[Rt] = 0</td>
            <td>i</td>
        </tr>
        <tr>
            <td>sltu</td>
            <td>rd,rs,rt</td>
            <td>Set Less Than Unsigned <br> if (RF[Rs] < RF[Rt] ) then RF[Rd] =1 else RF[Rd] = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sra</td>
            <td>rd,rt,sn</td>
            <td>Shift Right Arithmetic (immediate) <br> RF[Rd] = RF[Rt] >> n (sign-extend)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sra</td>
            <td>rd,rt,rs</td>
            <td>Shift Right Arithmetic <br> alias for <strong>srav rd,rt,rs</strong> <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (sign-extend)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>srav</td>
            <td>rd,rt,rs</td>
            <td>Shift Right Arithmetic Variable <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (sign-extend)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>srl</td>
            <td>rd,rt,sn</td>
            <td>Shift Right Logical <br> RF[Rd] = RF[Rt] >> n (no sign extension)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>srl</td>
            <td>rd,rt,rs</td>
            <td>Shift Right Logical <br> alias for <strong>srlv rd,rt,rs</strong> <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (no sign extension)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>srlv</td>
            <td>rd,rt,rs</td>
            <td>Shift Right Logical Variable <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (no sign extension)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sub</td>
            <td>rd,rs,rt</td>
            <td>Subtract <br> RF[Rd] = RF[Rs] - RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>subu</td>
            <td>rd,rs,rt</td>
            <td>Subtract Unsigned <br> RF[Rd] = RF[Rs] - RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sw</td>
            <td><strong>rt,oimm(rs)</strong></td>
            <td>Store Word: <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>swl</td>
            <td><strong>rt,oimm(rs)</strong></td>
            <td>Store Word Left (1-4 bytes, depending on offset): <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>swr</td>
            <td><strong>rt,oimm(rs)</strong></td>
            <td>Store Word Right (1-4 bytes, depending on offset): <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>syscall</td>
            <td></td>
            <td>call syscall in $v0</td>
            <td>b</td>
        </tr>
        <tr>
            <td>syscall</td>
            <td>Scode</td>
            <td>call syscall in argument</td>
            <td>b</td>
        </tr>
        <tr>
            <td>syscall</td>
            <td>Icode</td>
            <td>call syscall in argument</td>
            <td>b</td>
        </tr>
        <tr>
            <td>tlbp</td>
            <td></td>
            <td>Probe TLB For Matching Entry <br> Unimplemented</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tlbr</td>
            <td></td>
            <td>Read Indexed TLB Entry <br> Unimplemented</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tlbwi</td>
            <td></td>
            <td>Write Indexed TLB Entry <br> Unimplemented</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tlbwr</td>
            <td></td>
            <td>Write Random TLB Entry <br> Unimplemented</td>
            <td>r</td>
        </tr>
        <tr>
            <td>xor</td>
            <td>rd,rs,rt</td>
            <td>Bitwise Xor <br> RF[Rd] = RF[Rs] ^ RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>xori</td>
            <td>rt,rs,uimm</td>
            <td>Bitwise Xor Immediate <br> RF[Rt] = RF[Rs] ^ Imm</td>
            <td>i</td>
        </tr>
    </tbody>
  </table>
</div>

<hr />
<p><br />
<br /></p>
<h3 id="fp_opcodes">Floating-Point Instruction Set</h3>
<p>Most of these instructions are standard on the R2000/R3000. A few of these 
are from later processors; these are marked as 'Unimplemented.' </p>
<div class="table-responsive">
  <table class="table">
    <thead>
      <tr>
          <th>Opcode Name</th>
          <th>Arguments</th>
          <th>Comment</th>
          <th>Form</th>
      </tr>
    </thead>
    <tbody>
        <tr>
            <td>abs.d</td>
            <td>dd,ds</td>
            <td>Absolute value double: <br> FpRf[dd] = |FpRf[ds]|</td>
            <td>r</td>
        </tr>
        <tr>
            <td>abs.s</td>
            <td>fd,fs</td>
            <td>Absolute value single: <br> FpRf[fd] = |FpRf[fs]|</td>
            <td>r</td>
        </tr>
        <tr>
            <td>add.d</td>
            <td>dd,ds,dt</td>
            <td>Add double: <br> FpRf[dd] = FpRf[ds] + FpRf[dt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>add.s</td>
            <td>fd,fs,ft</td>
            <td>Add single: <br> FpRf[fd] = FpRf[fs] + FpRf[ft]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>bc1f</td>
            <td>label</td>
            <td>branch if status flag is false</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bc1t</td>
            <td>label</td>
            <td>branch if status flag is true</td>
            <td>i</td>
        </tr>
        <tr>
            <td>c.eq.d</td>
            <td>ds,dt</td>
            <td>Compare Equal Doubles: <br> ControlRf[31].condition_bit = FpRf[dt] == FpRf[ds] && !(un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.eq.s</td>
            <td>fs,ft</td>
            <td>Compare Equal Singles: <br> ControlRf[31].condition_bit = FpRf[ft] == FpRf[fs] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.f.d</td>
            <td>ds,dt</td>
            <td>Compare False: <br> ControlRf[31].condition_bit = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.f.s</td>
            <td>fs,ft</td>
            <td>Compare False: <br> ControlRf[31].condition_bit = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.le.d</td>
            <td>ds,dt</td>
            <td>Compare Less Than or Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.le.s</td>
            <td>fs,ft</td>
            <td>Compare Less Than or Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.lt.d</td>
            <td>ds,dt</td>
            <td>Compare Less Than: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.lt.s</td>
            <td>fs,ft</td>
            <td>Compare Less Than: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.nge.d</td>
            <td>ds,dt</td>
            <td>Compare Not Greater or Equal, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] || (un(FpRf[ds]) || un(FpRf[dt]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.nge.s</td>
            <td>fs,ft</td>
            <td>Compare Not Greater or Equal, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] || (un(FpRf[fs]) || un(FpRf[ft]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ngl.d</td>
            <td>ds,dt</td>
            <td>Compare Not Greater or Less Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] == FpRf[dt] || (un(FpRf[ds]) || un(FpRf[dt]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ngl.s</td>
            <td>fs,ft</td>
            <td>Compare Not Greater or Less Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] == FpRf[ft] || (un(FpRf[fs]) || un(FpRf[ft]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ngle.d</td>
            <td>ds,dt</td>
            <td>Compare Not Greater, Less, or Equal (only true if unordered): <br> exception if unordered; <br> ControlRf[31].condition_bit = (un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ngle.s</td>
            <td>fs,ft</td>
            <td>Compare Not Greater, Less, or Equal (only true if unordered): <br> exception if unordered; <br> ControlRf[31].condition_bit = (un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ngt.d</td>
            <td>ds,dt</td>
            <td>Compare Not Greater Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] || (un(FpRf[fs]) || un(FpRf[ft]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ngt.s</td>
            <td>fs,ft</td>
            <td>Compare Not Greater Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] || (un(FpRf[fs]) || un(FpRf[ft]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ole.d</td>
            <td>ds,dt</td>
            <td>Compare Ordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ole.s</td>
            <td>fs,ft</td>
            <td>Compare Ordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.olt.d</td>
            <td>ds,dt</td>
            <td>Compare Ordered Less Than: <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.olt.s</td>
            <td>fs,ft</td>
            <td>Compare Ordered Less Than: <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.seq.d</td>
            <td>ds,dt</td>
            <td>Compare Signaling Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] == FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.seq.s</td>
            <td>fs,ft</td>
            <td>Compare Signaling Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] == FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.sf.d</td>
            <td>ds,dt</td>
            <td>Compare Signaling False: <br> exception if unordered; <br> ControlRf[31].condition_bit = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.sf.s</td>
            <td>fs,ft</td>
            <td>Compare Signaling False: <br> exception if unordered; <br> ControlRf[31].condition_bit = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ueq.d</td>
            <td>ds,dt</td>
            <td>Compare Unordered/Equal Doubles: <br> ControlRf[31].condition_bit = (FpRf[dt] == FpRf[ds]) || (un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ueq.s</td>
            <td>fs,ft</td>
            <td>Compare Unordered/Equal Singles: <br> ControlRf[31].condition_bit = (FpRf[ft] == FpRf[fs]) || (un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ule.d</td>
            <td>ds,dt</td>
            <td>Compare Unordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] || (un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ule.s</td>
            <td>fs,ft</td>
            <td>Compare Unordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] || (un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ult.d</td>
            <td>ds,dt</td>
            <td>Compare Unordered Less Than: <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] || (un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ult.s</td>
            <td>fs,ft</td>
            <td>Compare Unordered Less Than: <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] || (un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.un.d</td>
            <td>ds,dt</td>
            <td>Compare Unordered Doubles: <br> ControlRf[31].condition_bit = un(FpRf[dt]) || un(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.un.s</td>
            <td>fs,ft</td>
            <td>Compare Unordered Singles: <br> ControlRf[31].condition_bit = un(FpRf[ft]) || un(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cfc1</td>
            <td>rt,Fs</td>
            <td>move control word from cop1: <br> Rf[rt] = ControlRf[Cs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ctc1</td>
            <td><strong>rt,Fs</strong></td>
            <td>move control word to cop1: <br> ControlRf[Cs] = Rf[rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>r</td>
        </tr>
        <tr>
            <td>cvt.d.s</td>
            <td>dd,fs</td>
            <td>Convert single to double: <br> FpRf[dd] = (double) FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cvt.d.w</td>
            <td>dd,fs</td>
            <td>Convert integer to double: <br> FpRf[dd] = (double) FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cvt.s.d</td>
            <td>fd,ds</td>
            <td>Convert double to single: <br> FpRf[fd] = (float) FpRf[ds]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cvt.s.w</td>
            <td>fd,fs</td>
            <td>Convert integer to single: <br> FpRf[fd] = (float) FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cvt.w.d</td>
            <td>fd,ds</td>
            <td>Convert double to integer: <br> FpRf[fd] = (int) FpRf[ds]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cvt.w.s</td>
            <td>fd,fs</td>
            <td>Convert single to integer: <br> FpRf[fd] = (int) FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>div.d</td>
            <td>dd,ds,dt</td>
            <td>Divide double: <br> FpRf[dd] = FpRf[ds] / FpRf[dt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>div.s</td>
            <td>fd,fs,ft</td>
            <td>Divide single: <br> FpRf[fd] = FpRf[fs] / FpRf[ft]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>l.s</td>
            <td>ft,oimm(rs)</td>
            <td>load word to cop1: <br> FpRf[ft] = Mem[Rf[rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lwc1</td>
            <td>ft,oimm(rs)</td>
            <td>load word to cop1: <br> FpRf[ft] = Mem[Rf[rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lwc2</td>
            <td>rt,oimm(rs)</td>
            <td>load word to cop2: <br> Unimplemented</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lwc3</td>
            <td>rt,oimm(rs)</td>
            <td>load word to cop3: <br> Unimplemented</td>
            <td>i</td>
        </tr>
        <tr>
            <td>mfc1</td>
            <td>rt,fs</td>
            <td>move from cop1: <br> Rf[rt] = FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mov.d</td>
            <td>dd,ds</td>
            <td>Copy double value: <br> FpRf[dd] = FpRf[ds]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mov.s</td>
            <td>fd,fs</td>
            <td>Copy single value: <br> FpRf[fd] = FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mtc1</td>
            <td><strong>rt,fs</strong></td>
            <td>move to cop1: <br> FpRf[fs] = Rf[rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>r</td>
        </tr>
        <tr>
            <td>mul.d</td>
            <td>dd,ds,dt</td>
            <td>Multiply double: <br> FpRf[dd] = FpRf[ds] * FpRf[dt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mul.s</td>
            <td>fd,fs,ft</td>
            <td>Multiply single: <br> FpRf[fd] = FpRf[fs] * FpRf[ft]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>neg.d</td>
            <td>dd,ds</td>
            <td>Negate double value: <br> FpRf[dd] = -FpRf[ds]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>neg.s</td>
            <td>fd,fs</td>
            <td>Negate single value: <br> FpRf[fd] = -FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>s.s</td>
            <td><strong>ft,oimm(rs)</strong></td>
            <td>store word from cop1: <br> Mem[Rf[rs] + Offset] = FpRf[ft] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>sc</td>
            <td>rt,oimm(rs)</td>
            <td>Unimplemented</td>
            <td>i</td>
        </tr>
        <tr>
            <td>sub.d</td>
            <td>dd,ds,dt</td>
            <td>Subtract double: <br> FpRf[dd] = FpRf[ds] - FpRf[dt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sub.s</td>
            <td>fd,fs,ft</td>
            <td>Subtract single: <br> FpRf[fd] = FpRf[fs] - FpRf[ft]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>swc1</td>
            <td><strong>ft,oimm(rs)</strong></td>
            <td>store word from cop1: <br> Mem[Rf[rs] + Offset] = FpRf[ft] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>swc2</td>
            <td>rt,oimm(rs)</td>
            <td>store word from cop2: <br> Mem[Rf[rs] + Offset] = Unimplemented</td>
            <td>i</td>
        </tr>
        <tr>
            <td>swc3</td>
            <td>rt,oimm(rs)</td>
            <td>store word from cop3: <br> Mem[Rf[rs] + Offset] = Unimplemented</td>
            <td>i</td>
        </tr>
    </tbody>
  </table>
</div>

<hr />
<p><br />
<br /></p>
<h3 id="fp_math_opcodes">Floating-Point Math Opcodes, MIPSym-Specific</h3>
<p>These are nonstandard opcodes for various mathematic functions. They are not
native to the R2000/R3000, but they may be useful for your programs.
Some of these opcodes are standard in later versions of MIPS.</p>
<div class="table-responsive">
  <table class="table">
    <thead>
      <tr>
          <th>Opcode Name</th>
          <th>Arguments</th>
          <th>Comment</th>
          <th>Form</th>
      </tr>
    </thead>
    <tbody>
        <tr>
            <td>acos.d</td>
            <td>dd,ds</td>
            <td>arc cosine double: <br> FpRf[dd] = acos(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>acos.s</td>
            <td>fd,fs</td>
            <td>arc cosine single: <br> FpRf[fd] = acos(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>acosh.d</td>
            <td>dd,ds</td>
            <td>arc hyperbolic cosine double: <br> FpRf[dd] = acosh(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>acosh.s</td>
            <td>fd,fs</td>
            <td>arc hyperbolic cosine single: <br> FpRf[fd] = acosh(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>asin.d</td>
            <td>dd,ds</td>
            <td>arc sine double: <br> FpRf[dd] = asin(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>asin.s</td>
            <td>fd,fs</td>
            <td>arc sine single: <br> FpRf[fd] = asin(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>asinh.d</td>
            <td>dd,ds</td>
            <td>arc hyperbolic sine double: <br> FpRf[dd] = asinh(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>asinh.s</td>
            <td>fd,fs</td>
            <td>arc hyperbolic sine single: <br> FpRf[fd] = asinh(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>atan.d</td>
            <td>dd,ds</td>
            <td>arc tangent double: <br> FpRf[dd] = atan(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>atan.s</td>
            <td>fd,fs</td>
            <td>arc tangent single: <br> FpRf[fd] = atan(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>atan2.d</td>
            <td>dd,ds,dt</td>
            <td>arc tangent of y,x double: <br> FpRf[dd] = atan2(FpRf[ds],FpRf[dt])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>atan2.s</td>
            <td>fd,fs,ft</td>
            <td>arc tangent of y,x single: <br> FpRf[fd] = atan2(FpRf[fs],FpRf[ft])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>atanh.d</td>
            <td>dd,ds</td>
            <td>arc hyperbolic tangent double: <br> FpRf[dd] = atanh(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>atanh.s</td>
            <td>fd,fs</td>
            <td>arc hyperbolic tangent single: <br> FpRf[fd] = atanh(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ceil.d</td>
            <td>dd,ds</td>
            <td>ceiling double and convert to integer: <br> FpRf[dd] = (int) ceil(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ceil.s</td>
            <td>fd,fs</td>
            <td>ceiling single and convert to integer: <br> FpRf[fd] = (int) ceil(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ceil.w.d</td>
            <td>dd,ds</td>
            <td>ceiling double: <br> FpRf[dd] = ceil(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ceil.w.s</td>
            <td>fd,fs</td>
            <td>ceiling single: <br> FpRf[fd] = ceil(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cos.d</td>
            <td>dd,ds</td>
            <td>cosine double: <br> FpRf[dd] = cos(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cos.s</td>
            <td>fd,fs</td>
            <td>cosine single: <br> FpRf[fd] = cos(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cosh.d</td>
            <td>dd,ds</td>
            <td>hyperbolic cosine double: <br> FpRf[dd] = cosh(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cosh.s</td>
            <td>fd,fs</td>
            <td>hyperbolic cosine single: <br> FpRf[fd] = cosh(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>exp.d</td>
            <td>dd,ds</td>
            <td>e to the x power double: <br> FpRf[dd] = exp(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>exp.s</td>
            <td>fd,fs</td>
            <td>e to the x power single: <br> FpRf[fd] = exp(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>floor.d</td>
            <td>dd,ds</td>
            <td>floor double and convert to integer: <br> FpRf[dd] = (int) floor(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>floor.s</td>
            <td>fd,fs</td>
            <td>floor single and convert to integer: <br> FpRf[fd] = (int) floor(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>floor.w.d</td>
            <td>dd,ds</td>
            <td>floor double: <br> FpRf[dd] = floor(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>floor.w.s</td>
            <td>fd,fs</td>
            <td>floor single: <br> FpRf[fd] = floor(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ln.d</td>
            <td>dd,ds</td>
            <td>natural log double: <br> FpRf[dd] = ln(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ln.s</td>
            <td>fd,fs</td>
            <td>natural log single: <br> FpRf[fd] = ln(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>round.d</td>
            <td>dd,ds</td>
            <td>round double and convert to integer: <br> FpRf[dd] = (int) round(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>round.s</td>
            <td>fd,fs</td>
            <td>round single and convert to integer: <br> FpRf[fd] = (int) round(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>round.w.d</td>
            <td>dd,ds</td>
            <td>round double: <br> FpRf[dd] = round(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>round.w.s</td>
            <td>fd,fs</td>
            <td>round single: <br> FpRf[fd] = round(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sin.d</td>
            <td>dd,ds</td>
            <td>sine double: <br> FpRf[dd] = sin(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sin.s</td>
            <td>fd,fs</td>
            <td>sine single: <br> FpRf[fd] = sin(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sinh.d</td>
            <td>dd,ds</td>
            <td>hyperbolic sine double: <br> FpRf[dd] = sinh(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sinh.s</td>
            <td>fd,fs</td>
            <td>hyperbolic sine single: <br> FpRf[fd] = sinh(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sqrt.d</td>
            <td>dd,ds</td>
            <td>square root double: <br> FpRf[dd] = sqrt(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sqrt.s</td>
            <td>fd,fs</td>
            <td>square root single: <br> FpRf[fd] = sqrt(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tan.d</td>
            <td>dd,ds</td>
            <td>tangent double: <br> FpRf[dd] = tan(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tan.s</td>
            <td>fd,fs</td>
            <td>tangent single: <br> FpRf[fd] = tan(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tanh.d</td>
            <td>dd,ds</td>
            <td>hyperbolic tangent double: <br> FpRf[dd] = tanh(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tanh.s</td>
            <td>fd,fs</td>
            <td>hyperbolic tangent single: <br> FpRf[fd] = tanh(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>trunc.d</td>
            <td>dd,ds</td>
            <td>truncate double and convert to integer: <br> FpRf[dd] = (int) trunc(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>trunc.s</td>
            <td>fd,fs</td>
            <td>truncate single and convert to integer: <br> FpRf[fd] = (int) trunc(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>trunc.w.d</td>
            <td>dd,ds</td>
            <td>truncate double: <br> FpRf[dd] = trunc(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>trunc.w.s</td>
            <td>fd,fs</td>
            <td>truncate single: <br> FpRf[fd] = trunc(FpRf[fs])</td>
            <td>r</td>
        </tr>
    </tbody>
  </table>
</div>

<hr />
<p><br />
<br /></p>
<h3 id="macros">Macros</h3>
<p>In addition to the original instructions implemented in the 
R2000, MIPSym also supports the use of several macros to make the 
process of writing assembly code easier. </p>
<p>Unlike SPIM, macros can be defined in program code using the
<code>.macro</code> and <code>.end_macro</code> assembler directives. Predefined macros are 
defined in the file MIPSym/asm/Mips1.adf.</p>
<div class="table-responsive">
  <table class="table">
    <thead>
      <tr>
          <th>Macro Name</th>
          <th>Arguments</th>
          <th>Comment</th>
      </tr>
    </thead>
    <tbody>
        <tr>
            <td>abs</td>
            <td>rd,rs</td>
            <td>Absolute Value <br> Rf[rd] = abs(Rf[rs]) <br> Note that if Rf[rs] == 0x80000000, an arithmetic overflow will occur, because 'positive 0x80000000' cannot be represented as a 32-bit signed integer. <br> Use `absu` to prevent this.<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  addu  rd,$0,rs
  bgez  rs,09f
  sub   rd,$0,rs
09:</code></pre></td><td><pre><code>  bgez  rs,09f
  addu  rd,$0,rs
  sub   rd,$0,rs
09:</code></pre></td></tr></tbody>
</table>
</td>
        </tr>
        <tr>
            <td>absu</td>
            <td>rd,rs</td>
            <td>Absolute Value Unsigned <br> Rf[rd] = abs(Rf[rs]) <br> Stores an unsigned 32-bit integer in Rf[rd]. <br> Note that this can store 'positive 0x80000000' in Rf[rd], which is negative when interpreted as a signed integer. <br> Use `abs` to prevent this.<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  addu  rd,$0,rs
  bgez  rs,09f
  subu  rd,$0,rs
09:</code></pre></td><td><pre><code>  bgez  rs,09f
  addu  rd,$0,rs
  subu  rd,$0,rs
09:</code></pre></td></tr></tbody>
</table>
</td>
        </tr>
        <tr>
            <td>addi</td>
            <td>rt,imm</td>
            <td>Add immediate: <br> Rf[rt] = Rf[rt] + imm<br/><br/><pre><code>  addi  rt,rt,imm</code></pre></td>
        </tr>
        <tr>
            <td>addiu</td>
            <td>rt,imm</td>
            <td>Add immediate unsigned: <br> Rf[rt] = Rf[rt] + imm<br/><br/><pre><code>  addiu rt,rt,imm</code></pre></td>
        </tr>
        <tr>
            <td>andi</td>
            <td>rt,imm</td>
            <td>And immediate: <br> Rf[rt] = Rf[rt] & imm<br/><br/><pre><code>  andi  rt,rt,imm</code></pre></td>
        </tr>
        <tr>
            <td>beq</td>
            <td>rs,Imm,label</td>
            <td>Branch equal to <br> If (RF[Rs] == Imm) then branch to Label<br/><br/><pre><code>  li    $at,Imm
  beq   rs,$at,label</code></pre></td>
        </tr>
        <tr>
            <td>bge</td>
            <td>rs,rt,label</td>
            <td>Branch greater than or equal to <br> If (RF[Rs] >= Rf[Rt]) then branch to Label<br/><br/><pre><code>  slt   $at,rs,rt
  beq   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>bge</td>
            <td>rs,Imm,label</td>
            <td>Branch greater than or equal to <br> If (RF[Rs] >= Imm) then branch to Label<br/><br/><pre><code>  li    $at,Imm
  slt   $at,rs,$at
  beq   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>bgeu</td>
            <td>rs,rt,label</td>
            <td>Branch greater than or equal to (Unsigned) <br> If (RF[Rs] >= Rf[Rt]) then branch to Label<br/><br/><pre><code>  sltu  $at,rs,rt
  beq   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>bgeu</td>
            <td>rs,Uimm,label</td>
            <td>Branch greater than or equal to (Unsigned) <br> If (RF[Rs] >= Imm) then branch to Label<br/><br/><pre><code>  li    $at,Uimm
  sltu  $at,rs,$at
  beq   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>bgt</td>
            <td>rs,rt,label</td>
            <td>Branch greater than <br> If (RF[Rs] > Rf[Rt]) then branch to Label<br/><br/><pre><code>  slt   $at,rt,rs
  bne   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>bgt</td>
            <td>rs,Imm,label</td>
            <td>Branch greater than <br> If (RF[Rs] > Imm) then branch to Label<br/><br/><pre><code>  li    $at,Imm
  slt   $at,$at,rs
  bne   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>bgtu</td>
            <td>rs,rt,label</td>
            <td>Branch greater than (Unsigned) <br> If (RF[Rs] > Rf[Rt]) then branch to Label<br/><br/><pre><code>  sltu  $at,rt,rs
  bne   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>bgtu</td>
            <td>rs,Uimm,label</td>
            <td>Branch greater than (Unsigned) <br> If (RF[Rs] > Imm) then branch to Label<br/><br/><pre><code>  li    $at,Uimm
  sltu  $at,$at,rs
  bne   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>ble</td>
            <td>rs,rt,label</td>
            <td>Branch less than or equal to <br> If (RF[Rs] <= Rf[Rt]) then branch to Label<br/><br/><pre><code>  slt   $at,rt,rs
  beq   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>ble</td>
            <td>rs,Imm,label</td>
            <td>Branch less than or equal to <br> If (RF[Rs] <= Imm) then branch to Label<br/><br/><pre><code>  li    $at,Imm
  slt   $at,$at,rs
  beq   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>bleu</td>
            <td>rs,rt,label</td>
            <td>Branch less than or equal to (Unsigned) <br> If (RF[Rs] <= Rf[Rt]) then branch to Label<br/><br/><pre><code>  sltu  $at,rt,rs
  beq   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>bleu</td>
            <td>rs,Uimm,label</td>
            <td>Branch less than or equal to (Unsigned) <br> If (RF[Rs] <= Imm) then branch to Label<br/><br/><pre><code>  li    $at,Uimm
  sltu  $at,$at,rs
  beq   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>blt</td>
            <td>rs,rt,label</td>
            <td>Branch less than <br> If (RF[Rs] < Rf[Rt]) then branch to Label<br/><br/><pre><code>  slt   $at,rs,rt
  bne   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>blt</td>
            <td>rs,Imm,label</td>
            <td>Branch less than <br> If (RF[Rs] < Imm) then branch to Label<br/><br/><pre><code>  li    $at,Imm
  slt   $at,rs,$at
  bne   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>bltu</td>
            <td>rs,rt,label</td>
            <td>Branch less than (Unsigned) <br> If (RF[Rs] < Rf[Rt]) then branch to Label<br/><br/><pre><code>  sltu  $at,rs,rt
  bne   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>bltu</td>
            <td>rs,Uimm,label</td>
            <td>Branch less than (Unsigned) <br> If (RF[Rs] < Imm) then branch to Label<br/><br/><pre><code>  li    $at,Uimm
  sltu  $at,rs,$at
  bne   $at,$0,label</code></pre></td>
        </tr>
        <tr>
            <td>bne</td>
            <td>rs,Imm,label</td>
            <td>Branch not equal <br> If (RF[Rs] != Imm) then branch to Label<br/><br/><pre><code>  li    $at,Imm
  bne   rs,$at,label</code></pre></td>
        </tr>
        <tr>
            <td>div</td>
            <td>rd,rs,rt</td>
            <td>Divide: <br> Rf[rd] = Rf[rs]/Rf[rt] <br> (break on divide by zero)<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  div   rs,rt
  mflo  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  div   rs,rt
  mflo  rd</code></pre></td></tr></tbody>
</table>
</td>
        </tr>
        <tr>
            <td>div</td>
            <td>rd,rs,Imm</td>
            <td>Divide: <br> Rf[rd] = Rf[rs]/Imm<br/><br/><pre><code>  li    $at,Imm
  div   rs,$at
  mflo  rd</code></pre></td>
        </tr>
        <tr>
            <td>div</td>
            <td>rd,Imm</td>
            <td>Divide: <br> Rf[rd] = Rf[rd]/Imm<br/><br/><pre><code>  li    $at,Imm
  div   rd,$at
  mflo  rd</code></pre></td>
        </tr>
        <tr>
            <td>divnz</td>
            <td>rd,rs,rt</td>
            <td>Divide: <br> Rf[rd] = Rf[rs]/Rf[rt]<br/><br/><pre><code>  div   rs,rt
  mflo  rd</code></pre></td>
        </tr>
        <tr>
            <td>divu</td>
            <td>rd,rs,rt</td>
            <td>Divide unsigned: <br> Rf[rd] = Rf[rs] / Rf[rt] <br> (break on divide by zero)<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  divu  rs,rt
  mflo  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  divu  rs,rt
  mflo  rd</code></pre></td></tr></tbody>
</table>
</td>
        </tr>
        <tr>
            <td>divu</td>
            <td>rd,rs,Uimm</td>
            <td>Divide unsigned: <br> Rf[rd] = Rf[rs] / Imm<br/><br/><pre><code>  li    $at,Uimm
  divu  rs,$at
  mflo  rd</code></pre></td>
        </tr>
        <tr>
            <td>divu</td>
            <td>rd,Uimm</td>
            <td>Divide unsigned: <br> Rf[rd] = Rf[rd] / Imm<br/><br/><pre><code>  li    $at,Uimm
  divu  rd,$at
  mflo  rd</code></pre></td>
        </tr>
        <tr>
            <td>l.d</td>
            <td>dd,laddress</td>
            <td>Load double: <br> FpRf[dd] = laddress<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lwc1  dd,laddress&0xFFFF($at)
  lwc1  dd+1,laddress&0xFFFF+4($at)</code></pre></td>
        </tr>
        <tr>
            <td>l.d</td>
            <td>dd,imm(rs)</td>
            <td>Load double: <br> FpRf[dd] = Mem[RF[Rs] + Offset]<br/><br/><pre><code>  lwc1  dd,imm(rs)
  lwc1  dd+1,imm+4(rs)</code></pre></td>
        </tr>
        <tr>
            <td>l.s</td>
            <td>fd,laddress</td>
            <td>Load single: <br> FpRf[fd] = laddress<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lwc1  fd,laddress&0xFFFF($at)</code></pre></td>
        </tr>
        <tr>
            <td>la</td>
            <td>rd,laddress</td>
            <td>Load Address into Rf[rd]<br/><br/><pre><code>  lui   rd,laddress>>16
  ori   rd,rd,laddress&0xffff</code></pre></td>
        </tr>
        <tr>
            <td>lb</td>
            <td>rd,laddress</td>
            <td>Load byte (low 8 bits): <br> Rf[rd] = Mem[laddress]<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lb    rd,laddress&0xFFFF($at)</code></pre></td>
        </tr>
        <tr>
            <td>lbu</td>
            <td>rd,laddress</td>
            <td>Load byte unsigned (low 8 bits): <br> Rf[rd] = Mem[laddress]<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lbu   rd,laddress&0xFFFF($at)</code></pre></td>
        </tr>
        <tr>
            <td>lh</td>
            <td>rd,laddress</td>
            <td>Load half (low 16 bits): <br> Rf[rd] = Mem[laddress]<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lh    rd,laddress&0xFFFF($at)</code></pre></td>
        </tr>
        <tr>
            <td>lhu</td>
            <td>rd,laddress</td>
            <td>Load half unsigned (low 16 bits): <br> Rf[rd] = Mem[laddress]<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lhu   rd,laddress&0xFFFF($at)</code></pre></td>
        </tr>
        <tr>
            <td>li</td>
            <td>rd,imm</td>
            <td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when the high 16 bits of imm are zero.<br/><br/><pre><code>ori   rd,$0,imm</code></pre></td>
        </tr>
        <tr>
            <td>li</td>
            <td>rd,imm</td>
            <td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when the low 16 bits of imm are zero.<br/><br/><pre><code>lui   rd,imm</code></pre></td>
        </tr>
        <tr>
            <td>li</td>
            <td>rd,imm</td>
            <td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when the high 17 bits of imm are 1 (it's a small negative number).<br/><br/><pre><code>addi   rd,$0,imm</code></pre></td>
        </tr>
        <tr>
            <td>li</td>
            <td>rd,imm</td>
            <td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when none of the three other forms can be used.<br/><br/><pre><code>lui   rd,imm
ori   rd,$0,imm</code></pre></td>
        </tr>
        <tr>
            <td>lw</td>
            <td>rd,laddress</td>
            <td>Load word (full 32 bits): <br> Rf[rd] = Mem[laddress]<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lw    rd,laddress&0xFFFF($at)</code></pre></td>
        </tr>
        <tr>
            <td>mul</td>
            <td>rd,rs,rt</td>
            <td>Multiply: <br> Rf[rd] = Rf[rs] * Rf[rt]<br/><br/><pre><code>  mult  rs,rt
  mflo  rd</code></pre></td>
        </tr>
        <tr>
            <td>mul</td>
            <td>rd,rs,Imm</td>
            <td>Multiply: <br> Rf[rd] = Rf[rs]*Imm<br/><br/><pre><code>  li    $at,Imm
  mult  rs,$at
  mflo  rd</code></pre></td>
        </tr>
        <tr>
            <td>mul</td>
            <td>rd,Imm</td>
            <td>Multiply: <br> Rf[rd] = Rf[rd]*Imm<br/><br/><pre><code>  li    $at,Imm
  mult  rd,$at
  mflo  rd</code></pre></td>
        </tr>
        <tr>
            <td>mulo</td>
            <td>rd,rs,rt</td>
            <td>Multiply, break on overflow<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  mult  rs,rt
  mfhi  $at
  mflo  rd
  sra   rd,rd,31
  beq   $at,rd,08f
  break
08:
  mflo  rd</code></pre></td><td><pre><code>  mult  rs,rt
  mfhi  $at
  mflo  rd
  sra   rd,rd,31
  beq   $at,rd,08f
  mflo  rd
  break
08:</code></pre></td></tr></tbody>
</table>
</td>
        </tr>
        <tr>
            <td>mulou</td>
            <td>rd,rs,rt</td>
            <td>Multiply unsigned, break on overflow<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  multu rs,rt
  mfhi  $at
  beq   $at,$0,08f
  break
08:
  mflo  rd</code></pre></td><td><pre><code>  multu rs,rt
  mfhi  $at
  beq   $at,$0,08f
  mflo  rd
  break
08:</code></pre></td></tr></tbody>
</table>
</td>
        </tr>
        <tr>
            <td>mulu</td>
            <td>rd,rs,rt</td>
            <td>Multiply unsigned: <br> Rf[rd] = Rf[rs] * Rf[rt]<br/><br/><pre><code>  multu rs,rt
  mflo  rd</code></pre></td>
        </tr>
        <tr>
            <td>mulu</td>
            <td>rd,rs,Uimm</td>
            <td>Multiply unsigned: <br> Rf[rd] = Rf[rs] * Imm<br/><br/><pre><code>  li    $at,Uimm
  multu rs,$at
  mflo  rd</code></pre></td>
        </tr>
        <tr>
            <td>mulu</td>
            <td>rd,Uimm</td>
            <td>Multiply unsigned: <br> Rf[rd] = Rf[rd] * Imm<br/><br/><pre><code>  li    $at,Uimm
  multu rd,$at
  mflo  rd</code></pre></td>
        </tr>
        <tr>
            <td>ori</td>
            <td>rt,imm</td>
            <td>Or immediate: <br> Rf[rt] = Rf[rt] | imm<br/><br/><pre><code>  ori   rt,rt,imm</code></pre></td>
        </tr>
        <tr>
            <td>rem</td>
            <td>rd,rs,rt</td>
            <td>Remainder: <br> Rf[rd] = Rf[rs] % Rf[rt]<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  div   rs,rt
  mfhi  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  div   rs,rt
  mfhi  rd</code></pre></td></tr></tbody>
</table>
</td>
        </tr>
        <tr>
            <td>rem</td>
            <td>rd,rs,Imm</td>
            <td>Remainder: <br> Rf[rd] = Rf[rs] % Imm<br/><br/><pre><code>  li    $at,Imm
  div   rs,$at
  mfhi  rd</code></pre></td>
        </tr>
        <tr>
            <td>rem</td>
            <td>rd,Imm</td>
            <td>Remainder: <br> Rf[rd] = Rf[rd] % Imm<br/><br/><pre><code>  li    $at,Imm
  div   rd,$at
  mfhi  rd</code></pre></td>
        </tr>
        <tr>
            <td>remu</td>
            <td>rd,rs,rt</td>
            <td>Remainder unsigned: <br> Rf[rd] = Rf[rs] % Rf[rt]<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  divu  rs,rt
  mfhi  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  divu  rs,rt
  mfhi  rd</code></pre></td></tr></tbody>
</table>
</td>
        </tr>
        <tr>
            <td>remu</td>
            <td>rd,rs,Uimm</td>
            <td>Remainder unsigned: <br> Rf[rd] = Rf[rs] % Imm<br/><br/><pre><code>  li    $at,Uimm
  divu  rs,$at
  mfhi  rd</code></pre></td>
        </tr>
        <tr>
            <td>remu</td>
            <td>rd,Uimm</td>
            <td>Remainder unsigned: <br> Rf[rd] = Rf[rd] % Imm<br/><br/><pre><code>  li    $at,Uimm
  divu  rd,$at
  mfhi  rd</code></pre></td>
        </tr>
        <tr>
            <td>rol</td>
            <td>rd,rt,rs</td>
            <td>Rotate left<br/><br/><pre><code>  subu  $at,$0,rs
  srlv  $at,rt,$at
  sllv  rd,rt,rs
  or    rd,rd,$at</code></pre></td>
        </tr>
        <tr>
            <td>rol</td>
            <td>rd,rt,sn</td>
            <td>Rotate left<br/><br/><pre><code>  srl   $at,rt,-sn
  sll   rd,rt,sn
  or    rd,rd,$at</code></pre></td>
        </tr>
        <tr>
            <td>ror</td>
            <td>rd,rt,rs</td>
            <td>Rotate right<br/><br/><pre><code>  subu  $at,$0,rs
  sllv  $at,rt,$at
  srlv  rd,rt,rs
  or    rd,rd,$at</code></pre></td>
        </tr>
        <tr>
            <td>ror</td>
            <td>rd,rt,sn</td>
            <td>Rotate right<br/><br/><pre><code>  sll   $at,rt,-sn
  srl   rd,rt,sn
  or    rd,rd,$at</code></pre></td>
        </tr>
        <tr>
            <td>s.d</td>
            <td>dd,laddress</td>
            <td>Store double: <br>  Mem[laddress] = FpRf[dd] <br> <strong>Backwards Arguments!</strong><br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  swc1  dd,laddress&0xFFFF($at)
  swc1  dd+1,laddress&0xFFFF+4($at)</code></pre></td>
        </tr>
        <tr>
            <td>s.d</td>
            <td>dd,oimm(rs)</td>
            <td>Store double: <br>  Mem[RF[Rs] + Offset] = FpRf[dd] <br> <strong>Backwards Arguments!</strong><br/><br/><pre><code>  swc1  dd,oimm(rs)
  swc1  dd+1,oimm+4(rs)</code></pre></td>
        </tr>
        <tr>
            <td>s.s</td>
            <td>fd,laddress</td>
            <td>Store single: <br>  Mem[laddress] = FpRf[fd] <br> <strong>Backwards Arguments!</strong><br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  swc1  fd,laddress&0xFFFF($at)</code></pre></td>
        </tr>
        <tr>
            <td>sb</td>
            <td>rd,laddress</td>
            <td>Store byte (low 8 bits): <br> Mem[laddress] = Rf[rd] <br> <strong>Backwards Arguments!</strong><br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  sb    rd,laddress&0xFFFF($at)</code></pre></td>
        </tr>
        <tr>
            <td>seq</td>
            <td>rd,rs,rt</td>
            <td>Set if equal: <br> Rf[rd] = Rf[rs] == Rf[rt]<br/><br/><pre><code>  subu  $at,rs,rt
  sltiu rd,$at,1</code></pre></td>
        </tr>
        <tr>
            <td>sge</td>
            <td>rd,rs,rt</td>
            <td>Set greater than: <br> Rf[rd] = Rf[rs] > Rf[rt]<br/><br/><pre><code>  slt   rd,rs,rt
  slti  rd,rd,1</code></pre></td>
        </tr>
        <tr>
            <td>sgeu</td>
            <td>rd,rs,rt</td>
            <td>Set greater than unsigned: <br> Rf[rd] = Rf[rs] > Rf[rt]<br/><br/><pre><code>  sltu  rd,rs,rt
  slti  rd,rd,1</code></pre></td>
        </tr>
        <tr>
            <td>sh</td>
            <td>rd,laddress</td>
            <td>Store half (low 16 bits): <br> Mem[laddress] = Rf[rd] <br> <strong>Backwards Arguments!</strong><br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  sh    rd,laddress&0xFFFF($at)</code></pre></td>
        </tr>
        <tr>
            <td>sle</td>
            <td>rd,rs,rt</td>
            <td>Set less than or equal: <br> Rf[rd] = Rf[rs] <= Rf[rt]<br/><br/><pre><code>  slt   rd,rt,rs
  slti  rd,rd,1</code></pre></td>
        </tr>
        <tr>
            <td>sleu</td>
            <td>rd,rs,rt</td>
            <td>Set less than or equal unsigned: <br> Rf[rd] = Rf[rs] <= Rf[rt]<br/><br/><pre><code>  sltu  rd,rt,rs
  slti  rd,rd,1</code></pre></td>
        </tr>
        <tr>
            <td>sne</td>
            <td>rd,rs,rt</td>
            <td>Set if not equal: <br> Rf[rd] = Rf[rs] != Rf[rt]<br/><br/><pre><code>  subu  $at,rs,rt
  sltu  rd,$0,$at</code></pre></td>
        </tr>
        <tr>
            <td>sub</td>
            <td>rt,rs,imm</td>
            <td>Subtract: <br> Rf[rt] = Rf[rs] - imm<br/><br/><pre><code>  addi  rt,rs,-imm</code></pre></td>
        </tr>
        <tr>
            <td>sub</td>
            <td>rt,imm</td>
            <td>Subtract: <br> Rf[rt] = Rf[rt] - imm<br/><br/><pre><code>  addi  rt,rt,-imm</code></pre></td>
        </tr>
        <tr>
            <td>subu</td>
            <td>rt,imm</td>
            <td>Subtract unsigned: <br> Rf[rt] = Rf[rt] - imm<br/><br/><pre><code>  addiu rt,rt,-imm</code></pre></td>
        </tr>
        <tr>
            <td>subu</td>
            <td>rt,rs,imm</td>
            <td>Subtract unsigned: <br> Rf[rt] = Rf[rs] - imm<br/><br/><pre><code>  addiu rt,rs,-imm</code></pre></td>
        </tr>
        <tr>
            <td>sw</td>
            <td>rd,laddress</td>
            <td>Store word (full 32 bits): <br> Mem[laddress] = Rf[rd] <br> <strong>Backwards Arguments!</strong><br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  sw    rd,laddress&0xFFFF($at)</code></pre></td>
        </tr>
        <tr>
            <td>ulh</td>
            <td>rt,oimm(rs)</td>
            <td><br/><br/><pre><code>  lb    rt,oimm+1(rs)
  lbu   $at,oimm(rs)
  sll   rt,rt,8
  or    rt,rt,$at</code></pre></td>
        </tr>
        <tr>
            <td>ulhu</td>
            <td>rt,oimm(rs)</td>
            <td><br/><br/><pre><code>  lbu   rt,oimm+1(rs)
  lbu   $at,oimm(rs)
  sll   rt,rt,8
  or    rt,rt,$at</code></pre></td>
        </tr>
        <tr>
            <td>ulw</td>
            <td>rt,oimm(rs)</td>
            <td><br/><br/><pre><code>  lwl   rt,oimm+3(rs)
  lwr   rt,oimm(rs)</code></pre></td>
        </tr>
        <tr>
            <td>ush</td>
            <td>rt,oimm(rs)</td>
            <td><br/><br/><pre><code>  sb    rt,oimm(rs)
  srl   $at,rt,8
  sb    $at,oimm+1(rs)</code></pre></td>
        </tr>
        <tr>
            <td>usw</td>
            <td>rt,oimm(rs)</td>
            <td><br/><br/><pre><code>  swl   rt,oimm+3(rs)
  swr   rt,oimm(rs)</code></pre></td>
        </tr>
        <tr>
            <td>xori</td>
            <td>rt,imm</td>
            <td>Xor immediate: <br> Rf[rt] = Rf[rt] ^ imm<br/><br/><pre><code>  xori  rt,rt,imm</code></pre></td>
        </tr>
    </tbody>
  </table>
</div>

<hr />
<p><br />
<br /></p>
<h3 id="full_list_opcodes_macros">Full Listing of All Opcodes and Macros</h3>
<p>For your convenience, all of the opcodes and macros are repeated here, 
alphabetized. Many of the opcodes have overloaded macro definitions, which 
will be invoked based on the arguments you provide. This view is intended to 
help you to see what those overloads are.</p>
<div class="table-responsive">
  <table class="table">
    <thead>
      <tr>
          <th>Opcode/Macro Name</th>
          <th>Arguments</th>
          <th>Comment</th>
          <th>Form</th>
      </tr>
    </thead>
    <tbody>
        <tr>
            <td>abs</td>
            <td>rd,rs</td>
            <td>Absolute Value <br> Rf[rd] = abs(Rf[rs]) <br> Note that if Rf[rs] == 0x80000000, an arithmetic overflow will occur, because 'positive 0x80000000' cannot be represented as a 32-bit signed integer. <br> Use `absu` to prevent this.<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  addu  rd,$0,rs
  bgez  rs,09f
  sub   rd,$0,rs
09:</code></pre></td><td><pre><code>  bgez  rs,09f
  addu  rd,$0,rs
  sub   rd,$0,rs
09:</code></pre></td></tr></tbody>
</table>
</td>
            <td></td>
        </tr>
        <tr>
            <td>abs.d</td>
            <td>dd,ds</td>
            <td>Absolute value double: <br> FpRf[dd] = |FpRf[ds]|</td>
            <td>r</td>
        </tr>
        <tr>
            <td>abs.s</td>
            <td>fd,fs</td>
            <td>Absolute value single: <br> FpRf[fd] = |FpRf[fs]|</td>
            <td>r</td>
        </tr>
        <tr>
            <td>absu</td>
            <td>rd,rs</td>
            <td>Absolute Value Unsigned <br> Rf[rd] = abs(Rf[rs]) <br> Stores an unsigned 32-bit integer in Rf[rd]. <br> Note that this can store 'positive 0x80000000' in Rf[rd], which is negative when interpreted as a signed integer. <br> Use `abs` to prevent this.<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  addu  rd,$0,rs
  bgez  rs,09f
  subu  rd,$0,rs
09:</code></pre></td><td><pre><code>  bgez  rs,09f
  addu  rd,$0,rs
  subu  rd,$0,rs
09:</code></pre></td></tr></tbody>
</table>
</td>
            <td></td>
        </tr>
        <tr>
            <td>acos.d</td>
            <td>dd,ds</td>
            <td>arc cosine double: <br> FpRf[dd] = acos(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>acos.s</td>
            <td>fd,fs</td>
            <td>arc cosine single: <br> FpRf[fd] = acos(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>acosh.d</td>
            <td>dd,ds</td>
            <td>arc hyperbolic cosine double: <br> FpRf[dd] = acosh(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>acosh.s</td>
            <td>fd,fs</td>
            <td>arc hyperbolic cosine single: <br> FpRf[fd] = acosh(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>add</td>
            <td>rd,rs,rt</td>
            <td>Add <br> RF[Rd] = RF[Rs] + RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>add</td>
            <td>rt,rs,imm</td>
            <td>Add <br> alias for <strong>addi rt,rs,imm</strong> <br> RF[Rt] = RF[Rs] + Imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>add.d</td>
            <td>dd,ds,dt</td>
            <td>Add double: <br> FpRf[dd] = FpRf[ds] + FpRf[dt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>add.s</td>
            <td>fd,fs,ft</td>
            <td>Add single: <br> FpRf[fd] = FpRf[fs] + FpRf[ft]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>addi</td>
            <td>rt,rs,imm</td>
            <td>Add Immediate <br> RF[Rt] = RF[Rs] + Imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>addi</td>
            <td>rt,imm</td>
            <td>Add immediate: <br> Rf[rt] = Rf[rt] + imm<br/><br/><pre><code>  addi  rt,rt,imm</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>addiu</td>
            <td>rt,rs,imm</td>
            <td>Add Immediate Unsigned <br> RF[Rt] = RF[Rs] + Imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>addiu</td>
            <td>rt,imm</td>
            <td>Add immediate unsigned: <br> Rf[rt] = Rf[rt] + imm<br/><br/><pre><code>  addiu rt,rt,imm</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>addu</td>
            <td>rd,rs,rt</td>
            <td>Add Unsigned <br> RF[Rd] = RF[Rs] + RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>addu</td>
            <td>rt,rs,imm</td>
            <td>Add Unsigned <br> alias for <strong>addiu rt,rs,imm</strong> <br> RF[Rt] = RF[Rs] + imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>and</td>
            <td>rd,rs,rt</td>
            <td>Bitwise And <br> RF[Rd] = RF[Rs] & RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>andi</td>
            <td>rt,rs,uimm</td>
            <td>Bitwise And Immediate <br> RF[Rt] = RF[Rs] & Imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>andi</td>
            <td>rt,imm</td>
            <td>And immediate: <br> Rf[rt] = Rf[rt] & imm<br/><br/><pre><code>  andi  rt,rt,imm</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>asin.d</td>
            <td>dd,ds</td>
            <td>arc sine double: <br> FpRf[dd] = asin(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>asin.s</td>
            <td>fd,fs</td>
            <td>arc sine single: <br> FpRf[fd] = asin(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>asinh.d</td>
            <td>dd,ds</td>
            <td>arc hyperbolic sine double: <br> FpRf[dd] = asinh(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>asinh.s</td>
            <td>fd,fs</td>
            <td>arc hyperbolic sine single: <br> FpRf[fd] = asinh(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>atan.d</td>
            <td>dd,ds</td>
            <td>arc tangent double: <br> FpRf[dd] = atan(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>atan.s</td>
            <td>fd,fs</td>
            <td>arc tangent single: <br> FpRf[fd] = atan(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>atan2.d</td>
            <td>dd,ds,dt</td>
            <td>arc tangent of y,x double: <br> FpRf[dd] = atan2(FpRf[ds],FpRf[dt])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>atan2.s</td>
            <td>fd,fs,ft</td>
            <td>arc tangent of y,x single: <br> FpRf[fd] = atan2(FpRf[fs],FpRf[ft])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>atanh.d</td>
            <td>dd,ds</td>
            <td>arc hyperbolic tangent double: <br> FpRf[dd] = atanh(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>atanh.s</td>
            <td>fd,fs</td>
            <td>arc hyperbolic tangent single: <br> FpRf[fd] = atanh(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>b</td>
            <td>label</td>
            <td>Branch <br> alias for <strong>bgez $0,label</strong> <br> PC = label</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bc0f</td>
            <td>label</td>
            <td>Branch Coprocessor0 True <br> This is a do nothing.  It used to test a pin on the part.</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bc0t</td>
            <td>label</td>
            <td>Branch Coprocessor0 False <br> This is a do nothing.  It used to test a pin on the part.</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bc1f</td>
            <td>label</td>
            <td>branch if status flag is false</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bc1t</td>
            <td>label</td>
            <td>branch if status flag is true</td>
            <td>i</td>
        </tr>
        <tr>
            <td>beq</td>
            <td>rs,rt,label</td>
            <td>Branch Equal <br> If (RF[Rs] == RF[Rt] )then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>beq</td>
            <td>rs,Imm,label</td>
            <td>Branch equal to <br> If (RF[Rs] == Imm) then branch to Label<br/><br/><pre><code>  li    $at,Imm
  beq   rs,$at,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>beqz</td>
            <td>rs,label</td>
            <td>Branch Equal to Zero <br> alias for <strong>beq rs,$0,label</strong> <br> If (RF[Rs] == 0) then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bge</td>
            <td>rs,rt,label</td>
            <td>Branch greater than or equal to <br> If (RF[Rs] >= Rf[Rt]) then branch to Label<br/><br/><pre><code>  slt   $at,rs,rt
  beq   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bge</td>
            <td>rs,Imm,label</td>
            <td>Branch greater than or equal to <br> If (RF[Rs] >= Imm) then branch to Label<br/><br/><pre><code>  li    $at,Imm
  slt   $at,rs,$at
  beq   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bgeu</td>
            <td>rs,rt,label</td>
            <td>Branch greater than or equal to (Unsigned) <br> If (RF[Rs] >= Rf[Rt]) then branch to Label<br/><br/><pre><code>  sltu  $at,rs,rt
  beq   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bgeu</td>
            <td>rs,Uimm,label</td>
            <td>Branch greater than or equal to (Unsigned) <br> If (RF[Rs] >= Imm) then branch to Label<br/><br/><pre><code>  li    $at,Uimm
  sltu  $at,rs,$at
  beq   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bgez</td>
            <td>rs,label</td>
            <td>Branch Greater than or Equal to Zero <br> If (RF[Rs] >= RF[0]) then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bgezal</td>
            <td>rs,label</td>
            <td>Branch Greater than or Equal to Zero And Link <br> If ( RF[Rs] >= RF[0] ) then {RF[$ra] = PC; PC = PC + Imm<< 2 }</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bgt</td>
            <td>rs,rt,label</td>
            <td>Branch greater than <br> If (RF[Rs] > Rf[Rt]) then branch to Label<br/><br/><pre><code>  slt   $at,rt,rs
  bne   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bgt</td>
            <td>rs,Imm,label</td>
            <td>Branch greater than <br> If (RF[Rs] > Imm) then branch to Label<br/><br/><pre><code>  li    $at,Imm
  slt   $at,$at,rs
  bne   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bgtu</td>
            <td>rs,rt,label</td>
            <td>Branch greater than (Unsigned) <br> If (RF[Rs] > Rf[Rt]) then branch to Label<br/><br/><pre><code>  sltu  $at,rt,rs
  bne   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bgtu</td>
            <td>rs,Uimm,label</td>
            <td>Branch greater than (Unsigned) <br> If (RF[Rs] > Imm) then branch to Label<br/><br/><pre><code>  li    $at,Uimm
  sltu  $at,$at,rs
  bne   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bgtz</td>
            <td>rs,label</td>
            <td>Branch Greater Than Zero <br> If (RF[Rs] > RF[0] ) then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>ble</td>
            <td>rs,rt,label</td>
            <td>Branch less than or equal to <br> If (RF[Rs] <= Rf[Rt]) then branch to Label<br/><br/><pre><code>  slt   $at,rt,rs
  beq   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>ble</td>
            <td>rs,Imm,label</td>
            <td>Branch less than or equal to <br> If (RF[Rs] <= Imm) then branch to Label<br/><br/><pre><code>  li    $at,Imm
  slt   $at,$at,rs
  beq   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bleu</td>
            <td>rs,rt,label</td>
            <td>Branch less than or equal to (Unsigned) <br> If (RF[Rs] <= Rf[Rt]) then branch to Label<br/><br/><pre><code>  sltu  $at,rt,rs
  beq   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bleu</td>
            <td>rs,Uimm,label</td>
            <td>Branch less than or equal to (Unsigned) <br> If (RF[Rs] <= Imm) then branch to Label<br/><br/><pre><code>  li    $at,Uimm
  sltu  $at,$at,rs
  beq   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>blez</td>
            <td>rs,label</td>
            <td>Branch Less than or Equal to Zero <br> If (RF[Rs] <= RF[0]) then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>blt</td>
            <td>rs,rt,label</td>
            <td>Branch less than <br> If (RF[Rs] < Rf[Rt]) then branch to Label<br/><br/><pre><code>  slt   $at,rs,rt
  bne   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>blt</td>
            <td>rs,Imm,label</td>
            <td>Branch less than <br> If (RF[Rs] < Imm) then branch to Label<br/><br/><pre><code>  li    $at,Imm
  slt   $at,rs,$at
  bne   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bltu</td>
            <td>rs,rt,label</td>
            <td>Branch less than (Unsigned) <br> If (RF[Rs] < Rf[Rt]) then branch to Label<br/><br/><pre><code>  sltu  $at,rs,rt
  bne   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bltu</td>
            <td>rs,Uimm,label</td>
            <td>Branch less than (Unsigned) <br> If (RF[Rs] < Imm) then branch to Label<br/><br/><pre><code>  li    $at,Uimm
  sltu  $at,rs,$at
  bne   $at,$0,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bltz</td>
            <td>rs,label</td>
            <td>Branch Less Than Zero <br> If RF[Rs] < RF[0] then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bltzal</td>
            <td>rs,label</td>
            <td>Branch Less Than Zero And Link <br> If ( RF[Rs] <  RF[0] ) then {RF[$ra] = PC; PC = PC + Imm<< 2 }</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bne</td>
            <td>rs,rt,label</td>
            <td>Branch Not Equal <br> If RF[Rs] != RF[Rt] then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>bne</td>
            <td>rs,Imm,label</td>
            <td>Branch not equal <br> If (RF[Rs] != Imm) then branch to Label<br/><br/><pre><code>  li    $at,Imm
  bne   rs,$at,label</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>bnez</td>
            <td>rs,label</td>
            <td>Branch Not Equal to Zero <br> alias for <strong>bne rs,$0,label</strong> <br> If RF[Rs] != 0 then PC = PC + Imm<< 2</td>
            <td>i</td>
        </tr>
        <tr>
            <td>break</td>
            <td>Bcode</td>
            <td>pause execution</td>
            <td>b</td>
        </tr>
        <tr>
            <td>break</td>
            <td>Icode</td>
            <td>pause execution</td>
            <td>b</td>
        </tr>
        <tr>
            <td>break</td>
            <td></td>
            <td>pause execution <br> alias for <strong>break 0</strong></td>
            <td>b</td>
        </tr>
        <tr>
            <td>c.eq.d</td>
            <td>ds,dt</td>
            <td>Compare Equal Doubles: <br> ControlRf[31].condition_bit = FpRf[dt] == FpRf[ds] && !(un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.eq.s</td>
            <td>fs,ft</td>
            <td>Compare Equal Singles: <br> ControlRf[31].condition_bit = FpRf[ft] == FpRf[fs] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.f.d</td>
            <td>ds,dt</td>
            <td>Compare False: <br> ControlRf[31].condition_bit = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.f.s</td>
            <td>fs,ft</td>
            <td>Compare False: <br> ControlRf[31].condition_bit = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.le.d</td>
            <td>ds,dt</td>
            <td>Compare Less Than or Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.le.s</td>
            <td>fs,ft</td>
            <td>Compare Less Than or Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.lt.d</td>
            <td>ds,dt</td>
            <td>Compare Less Than: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.lt.s</td>
            <td>fs,ft</td>
            <td>Compare Less Than: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.nge.d</td>
            <td>ds,dt</td>
            <td>Compare Not Greater or Equal, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] || (un(FpRf[ds]) || un(FpRf[dt]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.nge.s</td>
            <td>fs,ft</td>
            <td>Compare Not Greater or Equal, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] || (un(FpRf[fs]) || un(FpRf[ft]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ngl.d</td>
            <td>ds,dt</td>
            <td>Compare Not Greater or Less Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] == FpRf[dt] || (un(FpRf[ds]) || un(FpRf[dt]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ngl.s</td>
            <td>fs,ft</td>
            <td>Compare Not Greater or Less Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] == FpRf[ft] || (un(FpRf[fs]) || un(FpRf[ft]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ngle.d</td>
            <td>ds,dt</td>
            <td>Compare Not Greater, Less, or Equal (only true if unordered): <br> exception if unordered; <br> ControlRf[31].condition_bit = (un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ngle.s</td>
            <td>fs,ft</td>
            <td>Compare Not Greater, Less, or Equal (only true if unordered): <br> exception if unordered; <br> ControlRf[31].condition_bit = (un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ngt.d</td>
            <td>ds,dt</td>
            <td>Compare Not Greater Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] || (un(FpRf[fs]) || un(FpRf[ft]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ngt.s</td>
            <td>fs,ft</td>
            <td>Compare Not Greater Than, or unordered: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] || (un(FpRf[fs]) || un(FpRf[ft]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ole.d</td>
            <td>ds,dt</td>
            <td>Compare Ordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ole.s</td>
            <td>fs,ft</td>
            <td>Compare Ordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.olt.d</td>
            <td>ds,dt</td>
            <td>Compare Ordered Less Than: <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.olt.s</td>
            <td>fs,ft</td>
            <td>Compare Ordered Less Than: <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.seq.d</td>
            <td>ds,dt</td>
            <td>Compare Signaling Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[ds] == FpRf[dt] && !(un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.seq.s</td>
            <td>fs,ft</td>
            <td>Compare Signaling Equal: <br> exception if unordered; <br> ControlRf[31].condition_bit = FpRf[fs] == FpRf[ft] && !(un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.sf.d</td>
            <td>ds,dt</td>
            <td>Compare Signaling False: <br> exception if unordered; <br> ControlRf[31].condition_bit = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.sf.s</td>
            <td>fs,ft</td>
            <td>Compare Signaling False: <br> exception if unordered; <br> ControlRf[31].condition_bit = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ueq.d</td>
            <td>ds,dt</td>
            <td>Compare Unordered/Equal Doubles: <br> ControlRf[31].condition_bit = (FpRf[dt] == FpRf[ds]) || (un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ueq.s</td>
            <td>fs,ft</td>
            <td>Compare Unordered/Equal Singles: <br> ControlRf[31].condition_bit = (FpRf[ft] == FpRf[fs]) || (un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ule.d</td>
            <td>ds,dt</td>
            <td>Compare Unordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[ds] <= FpRf[dt] || (un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ule.s</td>
            <td>fs,ft</td>
            <td>Compare Unordered Less Than Or Equal: <br> ControlRf[31].condition_bit = FpRf[fs] <= FpRf[ft] || (un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ult.d</td>
            <td>ds,dt</td>
            <td>Compare Unordered Less Than: <br> ControlRf[31].condition_bit = FpRf[ds] < FpRf[dt] || (un(FpRf[dt]) || un(FpRf[ds]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.ult.s</td>
            <td>fs,ft</td>
            <td>Compare Unordered Less Than: <br> ControlRf[31].condition_bit = FpRf[fs] < FpRf[ft] || (un(FpRf[ft]) || un(FpRf[fs]))</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.un.d</td>
            <td>ds,dt</td>
            <td>Compare Unordered Doubles: <br> ControlRf[31].condition_bit = un(FpRf[dt]) || un(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>c.un.s</td>
            <td>fs,ft</td>
            <td>Compare Unordered Singles: <br> ControlRf[31].condition_bit = un(FpRf[ft]) || un(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ceil.d</td>
            <td>dd,ds</td>
            <td>ceiling double and convert to integer: <br> FpRf[dd] = (int) ceil(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ceil.s</td>
            <td>fd,fs</td>
            <td>ceiling single and convert to integer: <br> FpRf[fd] = (int) ceil(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ceil.w.d</td>
            <td>dd,ds</td>
            <td>ceiling double: <br> FpRf[dd] = ceil(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ceil.w.s</td>
            <td>fd,fs</td>
            <td>ceiling single: <br> FpRf[fd] = ceil(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cfc1</td>
            <td>rt,Fs</td>
            <td>move control word from cop1: <br> Rf[rt] = ControlRf[Cs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cos.d</td>
            <td>dd,ds</td>
            <td>cosine double: <br> FpRf[dd] = cos(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cos.s</td>
            <td>fd,fs</td>
            <td>cosine single: <br> FpRf[fd] = cos(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cosh.d</td>
            <td>dd,ds</td>
            <td>hyperbolic cosine double: <br> FpRf[dd] = cosh(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cosh.s</td>
            <td>fd,fs</td>
            <td>hyperbolic cosine single: <br> FpRf[fd] = cosh(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ctc1</td>
            <td><strong>rt,Fs</strong></td>
            <td>move control word to cop1: <br> ControlRf[Cs] = Rf[rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>r</td>
        </tr>
        <tr>
            <td>cvt.d.s</td>
            <td>dd,fs</td>
            <td>Convert single to double: <br> FpRf[dd] = (double) FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cvt.d.w</td>
            <td>dd,fs</td>
            <td>Convert integer to double: <br> FpRf[dd] = (double) FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cvt.s.d</td>
            <td>fd,ds</td>
            <td>Convert double to single: <br> FpRf[fd] = (float) FpRf[ds]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cvt.s.w</td>
            <td>fd,fs</td>
            <td>Convert integer to single: <br> FpRf[fd] = (float) FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cvt.w.d</td>
            <td>fd,ds</td>
            <td>Convert double to integer: <br> FpRf[fd] = (int) FpRf[ds]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>cvt.w.s</td>
            <td>fd,fs</td>
            <td>Convert single to integer: <br> FpRf[fd] = (int) FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>div</td>
            <td>rs,rt</td>
            <td>Divide (signed) <br> Low = Quotient ( RF[Rs] / RF[Rt] ); <br> High = Remainder ( RF[Rs] / RF[Rt] )</td>
            <td>r</td>
        </tr>
        <tr>
            <td>div</td>
            <td>rd,rs,rt</td>
            <td>Divide: <br> Rf[rd] = Rf[rs]/Rf[rt] <br> (break on divide by zero)<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  div   rs,rt
  mflo  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  div   rs,rt
  mflo  rd</code></pre></td></tr></tbody>
</table>
</td>
            <td></td>
        </tr>
        <tr>
            <td>div</td>
            <td>rd,rs,Imm</td>
            <td>Divide: <br> Rf[rd] = Rf[rs]/Imm<br/><br/><pre><code>  li    $at,Imm
  div   rs,$at
  mflo  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>div</td>
            <td>rd,Imm</td>
            <td>Divide: <br> Rf[rd] = Rf[rd]/Imm<br/><br/><pre><code>  li    $at,Imm
  div   rd,$at
  mflo  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>div.d</td>
            <td>dd,ds,dt</td>
            <td>Divide double: <br> FpRf[dd] = FpRf[ds] / FpRf[dt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>div.s</td>
            <td>fd,fs,ft</td>
            <td>Divide single: <br> FpRf[fd] = FpRf[fs] / FpRf[ft]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>divnz</td>
            <td>rd,rs,rt</td>
            <td>Divide: <br> Rf[rd] = Rf[rs]/Rf[rt]<br/><br/><pre><code>  div   rs,rt
  mflo  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>divu</td>
            <td>rs,rt</td>
            <td>Divide Unsigned <br> Low = Quotient ( RF[Rs] / RF[Rt] ); <br> High = Remainder ( RF[Rs] / RF[Rt] )</td>
            <td>r</td>
        </tr>
        <tr>
            <td>divu</td>
            <td>rd,rs,rt</td>
            <td>Divide unsigned: <br> Rf[rd] = Rf[rs] / Rf[rt] <br> (break on divide by zero)<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  divu  rs,rt
  mflo  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  divu  rs,rt
  mflo  rd</code></pre></td></tr></tbody>
</table>
</td>
            <td></td>
        </tr>
        <tr>
            <td>divu</td>
            <td>rd,rs,Uimm</td>
            <td>Divide unsigned: <br> Rf[rd] = Rf[rs] / Imm<br/><br/><pre><code>  li    $at,Uimm
  divu  rs,$at
  mflo  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>divu</td>
            <td>rd,Uimm</td>
            <td>Divide unsigned: <br> Rf[rd] = Rf[rd] / Imm<br/><br/><pre><code>  li    $at,Uimm
  divu  rd,$at
  mflo  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>exp.d</td>
            <td>dd,ds</td>
            <td>e to the x power double: <br> FpRf[dd] = exp(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>exp.s</td>
            <td>fd,fs</td>
            <td>e to the x power single: <br> FpRf[fd] = exp(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>floor.d</td>
            <td>dd,ds</td>
            <td>floor double and convert to integer: <br> FpRf[dd] = (int) floor(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>floor.s</td>
            <td>fd,fs</td>
            <td>floor single and convert to integer: <br> FpRf[fd] = (int) floor(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>floor.w.d</td>
            <td>dd,ds</td>
            <td>floor double: <br> FpRf[dd] = floor(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>floor.w.s</td>
            <td>fd,fs</td>
            <td>floor single: <br> FpRf[fd] = floor(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>j</td>
            <td>label</td>
            <td>Jump <br> PC = PC(31:28) | Imm<< 2</td>
            <td>j</td>
        </tr>
        <tr>
            <td>jal</td>
            <td>label</td>
            <td>Jump And Link <br> RF[$ra] = PC; <br> PC = PC(31:28) | Imm<< 2</td>
            <td>j</td>
        </tr>
        <tr>
            <td>jalr</td>
            <td>rd,rs</td>
            <td>Jump And Link Register <br> RF[Rd] = PC; <br> PC = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>jalr</td>
            <td>rs</td>
            <td>Jump And Link Register <br> alias for <strong>jalr $ra,rs</strong> <br> $ra = PC; <br> PC = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>jr</td>
            <td>rs</td>
            <td>Jump Register <br> PC = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>l.d</td>
            <td>dd,laddress</td>
            <td>Load double: <br> FpRf[dd] = laddress<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lwc1  dd,laddress&0xFFFF($at)
  lwc1  dd+1,laddress&0xFFFF+4($at)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>l.d</td>
            <td>dd,imm(rs)</td>
            <td>Load double: <br> FpRf[dd] = Mem[RF[Rs] + Offset]<br/><br/><pre><code>  lwc1  dd,imm(rs)
  lwc1  dd+1,imm+4(rs)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>l.s</td>
            <td>ft,oimm(rs)</td>
            <td>load word to cop1: <br> FpRf[ft] = Mem[Rf[rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>l.s</td>
            <td>fd,laddress</td>
            <td>Load single: <br> FpRf[fd] = laddress<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lwc1  fd,laddress&0xFFFF($at)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>la</td>
            <td>rd,laddress</td>
            <td>Load Address into Rf[rd]<br/><br/><pre><code>  lui   rd,laddress>>16
  ori   rd,rd,laddress&0xffff</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>lb</td>
            <td>rt,oimm(rs)</td>
            <td>Load Byte <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lb</td>
            <td>rd,laddress</td>
            <td>Load byte (low 8 bits): <br> Rf[rd] = Mem[laddress]<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lb    rd,laddress&0xFFFF($at)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>lbu</td>
            <td>rt,oimm(rs)</td>
            <td>Load Byte Unsigned <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lbu</td>
            <td>rd,laddress</td>
            <td>Load byte unsigned (low 8 bits): <br> Rf[rd] = Mem[laddress]<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lbu   rd,laddress&0xFFFF($at)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>lh</td>
            <td>rt,oimm(rs)</td>
            <td>Load Half <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lh</td>
            <td>rd,laddress</td>
            <td>Load half (low 16 bits): <br> Rf[rd] = Mem[laddress]<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lh    rd,laddress&0xFFFF($at)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>lhu</td>
            <td>rt,oimm(rs)</td>
            <td>Load Half Unsigned <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lhu</td>
            <td>rd,laddress</td>
            <td>Load half unsigned (low 16 bits): <br> Rf[rd] = Mem[laddress]<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lhu   rd,laddress&0xFFFF($at)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>li</td>
            <td>rd,imm</td>
            <td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when the high 16 bits of imm are zero.<br/><br/><pre><code>ori   rd,$0,imm</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>li</td>
            <td>rd,imm</td>
            <td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when the low 16 bits of imm are zero.<br/><br/><pre><code>lui   rd,imm</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>li</td>
            <td>rd,imm</td>
            <td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when the high 17 bits of imm are 1 (it's a small negative number).<br/><br/><pre><code>addi   rd,$0,imm</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>li</td>
            <td>rd,imm</td>
            <td>Load Immediate into Rf[rd] variable size, no forward reference.<br>This macro is used when none of the three other forms can be used.<br/><br/><pre><code>lui   rd,imm
ori   rd,$0,imm</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>ll</td>
            <td>rt,oimm(rs)</td>
            <td>Load Linked <br> Unimplemented</td>
            <td>i</td>
        </tr>
        <tr>
            <td>ln.d</td>
            <td>dd,ds</td>
            <td>natural log double: <br> FpRf[dd] = ln(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ln.s</td>
            <td>fd,fs</td>
            <td>natural log single: <br> FpRf[fd] = ln(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>lui</td>
            <td>rt,uimm</td>
            <td>Load Upper Immediate <br> RF[Rt] = Imm<<16</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lw</td>
            <td>rt,oimm(rs)</td>
            <td>Load Word <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lw</td>
            <td>rd,laddress</td>
            <td>Load word (full 32 bits): <br> Rf[rd] = Mem[laddress]<br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  lw    rd,laddress&0xFFFF($at)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>lwc1</td>
            <td>ft,oimm(rs)</td>
            <td>load word to cop1: <br> FpRf[ft] = Mem[Rf[rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lwc2</td>
            <td>rt,oimm(rs)</td>
            <td>load word to cop2: <br> Unimplemented</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lwc3</td>
            <td>rt,oimm(rs)</td>
            <td>load word to cop3: <br> Unimplemented</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lwl</td>
            <td>rt,oimm(rs)</td>
            <td>Load Word Left <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>lwr</td>
            <td>rt,oimm(rs)</td>
            <td>Load Word Right <br> RF[Rt] = Mem[RF[Rs] + Offset]</td>
            <td>i</td>
        </tr>
        <tr>
            <td>mfc0</td>
            <td>rt,Cd</td>
            <td>Move From Coprocessor0: <br> Rf[rt] = CP0Rf[cd]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mfc1</td>
            <td>rt,fs</td>
            <td>move from cop1: <br> Rf[rt] = FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mfhi</td>
            <td>rd</td>
            <td>Move From Hi <br> RF[Rd] = HIGH</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mflo</td>
            <td>rd</td>
            <td>Move From Low <br> RF[Rd] = LOW</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mov</td>
            <td>rd,rs</td>
            <td>Move <br> alias for <strong>addu rd,rs,$0</strong> <br> RF[Rd] = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mov.d</td>
            <td>dd,ds</td>
            <td>Copy double value: <br> FpRf[dd] = FpRf[ds]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mov.s</td>
            <td>fd,fs</td>
            <td>Copy single value: <br> FpRf[fd] = FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>move</td>
            <td>rd,rs</td>
            <td>Move <br> alias for <strong>addu rd,rs,$0</strong> <br> RF[Rd] = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mtc0</td>
            <td><strong>rt,Cd</strong></td>
            <td>Move To Coprocessor0: <br> CP0Rf[cd] = Rf[rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>r</td>
        </tr>
        <tr>
            <td>mtc1</td>
            <td><strong>rt,fs</strong></td>
            <td>move to cop1: <br> FpRf[fs] = Rf[rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>r</td>
        </tr>
        <tr>
            <td>mthi</td>
            <td>rs</td>
            <td>Move To Hi <br> HIGH = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mtlo</td>
            <td>rs</td>
            <td>Move To Low <br> LOW = RF[Rs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mul</td>
            <td>rd,rs,rt</td>
            <td>Multiply: <br> Rf[rd] = Rf[rs] * Rf[rt]<br/><br/><pre><code>  mult  rs,rt
  mflo  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>mul</td>
            <td>rd,rs,Imm</td>
            <td>Multiply: <br> Rf[rd] = Rf[rs]*Imm<br/><br/><pre><code>  li    $at,Imm
  mult  rs,$at
  mflo  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>mul</td>
            <td>rd,Imm</td>
            <td>Multiply: <br> Rf[rd] = Rf[rd]*Imm<br/><br/><pre><code>  li    $at,Imm
  mult  rd,$at
  mflo  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>mul.d</td>
            <td>dd,ds,dt</td>
            <td>Multiply double: <br> FpRf[dd] = FpRf[ds] * FpRf[dt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mul.s</td>
            <td>fd,fs,ft</td>
            <td>Multiply single: <br> FpRf[fd] = FpRf[fs] * FpRf[ft]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mulo</td>
            <td>rd,rs,rt</td>
            <td>Multiply, break on overflow<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  mult  rs,rt
  mfhi  $at
  mflo  rd
  sra   rd,rd,31
  beq   $at,rd,08f
  break
08:
  mflo  rd</code></pre></td><td><pre><code>  mult  rs,rt
  mfhi  $at
  mflo  rd
  sra   rd,rd,31
  beq   $at,rd,08f
  mflo  rd
  break
08:</code></pre></td></tr></tbody>
</table>
</td>
            <td></td>
        </tr>
        <tr>
            <td>mulou</td>
            <td>rd,rs,rt</td>
            <td>Multiply unsigned, break on overflow<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  multu rs,rt
  mfhi  $at
  beq   $at,$0,08f
  break
08:
  mflo  rd</code></pre></td><td><pre><code>  multu rs,rt
  mfhi  $at
  beq   $at,$0,08f
  mflo  rd
  break
08:</code></pre></td></tr></tbody>
</table>
</td>
            <td></td>
        </tr>
        <tr>
            <td>mult</td>
            <td>rs,rt</td>
            <td>Multiply (signed) <br> High |Low = RF[Rs] * RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>multu</td>
            <td>rs,rt</td>
            <td>Multiply Unsigned <br> High |Low = RF[Rs] * RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>mulu</td>
            <td>rd,rs,rt</td>
            <td>Multiply unsigned: <br> Rf[rd] = Rf[rs] * Rf[rt]<br/><br/><pre><code>  multu rs,rt
  mflo  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>mulu</td>
            <td>rd,rs,Uimm</td>
            <td>Multiply unsigned: <br> Rf[rd] = Rf[rs] * Imm<br/><br/><pre><code>  li    $at,Uimm
  multu rs,$at
  mflo  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>mulu</td>
            <td>rd,Uimm</td>
            <td>Multiply unsigned: <br> Rf[rd] = Rf[rd] * Imm<br/><br/><pre><code>  li    $at,Uimm
  multu rd,$at
  mflo  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>neg</td>
            <td>rd,rt</td>
            <td>Negate <br> alias for <strong>sub rd,$0,rt</strong> <br> RF[Rd] = -RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>neg.d</td>
            <td>dd,ds</td>
            <td>Negate double value: <br> FpRf[dd] = -FpRf[ds]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>neg.s</td>
            <td>fd,fs</td>
            <td>Negate single value: <br> FpRf[fd] = -FpRf[fs]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>negu</td>
            <td>rd,rt</td>
            <td>Negate <br> alias for <strong>subu rd,$0,rt</strong> <br> RF[Rd] = -RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>nop</td>
            <td></td>
            <td>no operation <br> alias for <strong>sll $0,$0,0</strong></td>
            <td>r</td>
        </tr>
        <tr>
            <td>nor</td>
            <td>rd,rs,rt</td>
            <td>Bitwise Nor <br> RF[Rd] = !(RF[Rs] | RF[Rt])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>not</td>
            <td>rd,rs</td>
            <td>Boolean Not <br> alias for <strong>nor rd,rs,$0</strong> <br> RF[Rd] = !(RF[Rs] | 0)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>or</td>
            <td>rd,rs,rt</td>
            <td>Bitwise Or <br> RF[Rd] = RF[Rs] | RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ori</td>
            <td>rt,rs,uimm</td>
            <td>Bitwise Or Immediate <br> RF[Rt] = RF[Rs] | Imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>ori</td>
            <td>rt,imm</td>
            <td>Or immediate: <br> Rf[rt] = Rf[rt] | imm<br/><br/><pre><code>  ori   rt,rt,imm</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>rem</td>
            <td>rd,rs,rt</td>
            <td>Remainder: <br> Rf[rd] = Rf[rs] % Rf[rt]<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  div   rs,rt
  mfhi  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  div   rs,rt
  mfhi  rd</code></pre></td></tr></tbody>
</table>
</td>
            <td></td>
        </tr>
        <tr>
            <td>rem</td>
            <td>rd,rs,Imm</td>
            <td>Remainder: <br> Rf[rd] = Rf[rs] % Imm<br/><br/><pre><code>  li    $at,Imm
  div   rs,$at
  mfhi  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>rem</td>
            <td>rd,Imm</td>
            <td>Remainder: <br> Rf[rd] = Rf[rd] % Imm<br/><br/><pre><code>  li    $at,Imm
  div   rd,$at
  mfhi  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>remu</td>
            <td>rd,rs,rt</td>
            <td>Remainder unsigned: <br> Rf[rd] = Rf[rs] % Rf[rt]<br/><br/><table class="table">
<thead><tr><th>Delay Slot Off</th><th>Delay Slot On</th></tr></thead>
<tbody><tr><td><pre><code>  bne   rt,$0,08f
  break
08:
  divu  rs,rt
  mfhi  rd</code></pre></td><td><pre><code>  bne   rt,$0,08f
  nop
  break
08:
  divu  rs,rt
  mfhi  rd</code></pre></td></tr></tbody>
</table>
</td>
            <td></td>
        </tr>
        <tr>
            <td>remu</td>
            <td>rd,rs,Uimm</td>
            <td>Remainder unsigned: <br> Rf[rd] = Rf[rs] % Imm<br/><br/><pre><code>  li    $at,Uimm
  divu  rs,$at
  mfhi  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>remu</td>
            <td>rd,Uimm</td>
            <td>Remainder unsigned: <br> Rf[rd] = Rf[rd] % Imm<br/><br/><pre><code>  li    $at,Uimm
  divu  rd,$at
  mfhi  rd</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>rfe</td>
            <td></td>
            <td>Restore From Exception <br>restores the status register to its value before the last exception occurred.</td>
            <td>r</td>
        </tr>
        <tr>
            <td>rol</td>
            <td>rd,rt,rs</td>
            <td>Rotate left<br/><br/><pre><code>  subu  $at,$0,rs
  srlv  $at,rt,$at
  sllv  rd,rt,rs
  or    rd,rd,$at</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>rol</td>
            <td>rd,rt,sn</td>
            <td>Rotate left<br/><br/><pre><code>  srl   $at,rt,-sn
  sll   rd,rt,sn
  or    rd,rd,$at</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>ror</td>
            <td>rd,rt,rs</td>
            <td>Rotate right<br/><br/><pre><code>  subu  $at,$0,rs
  sllv  $at,rt,$at
  srlv  rd,rt,rs
  or    rd,rd,$at</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>ror</td>
            <td>rd,rt,sn</td>
            <td>Rotate right<br/><br/><pre><code>  sll   $at,rt,-sn
  srl   rd,rt,sn
  or    rd,rd,$at</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>round.d</td>
            <td>dd,ds</td>
            <td>round double and convert to integer: <br> FpRf[dd] = (int) round(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>round.s</td>
            <td>fd,fs</td>
            <td>round single and convert to integer: <br> FpRf[fd] = (int) round(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>round.w.d</td>
            <td>dd,ds</td>
            <td>round double: <br> FpRf[dd] = round(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>round.w.s</td>
            <td>fd,fs</td>
            <td>round single: <br> FpRf[fd] = round(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>s.d</td>
            <td>dd,laddress</td>
            <td>Store double: <br>  Mem[laddress] = FpRf[dd] <br> <strong>Backwards Arguments!</strong><br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  swc1  dd,laddress&0xFFFF($at)
  swc1  dd+1,laddress&0xFFFF+4($at)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>s.d</td>
            <td>dd,oimm(rs)</td>
            <td>Store double: <br>  Mem[RF[Rs] + Offset] = FpRf[dd] <br> <strong>Backwards Arguments!</strong><br/><br/><pre><code>  swc1  dd,oimm(rs)
  swc1  dd+1,oimm+4(rs)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>s.s</td>
            <td><strong>ft,oimm(rs)</strong></td>
            <td>store word from cop1: <br> Mem[Rf[rs] + Offset] = FpRf[ft] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>s.s</td>
            <td>fd,laddress</td>
            <td>Store single: <br>  Mem[laddress] = FpRf[fd] <br> <strong>Backwards Arguments!</strong><br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  swc1  fd,laddress&0xFFFF($at)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>sb</td>
            <td><strong>rt,oimm(rs)</strong></td>
            <td>Store Byte: <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>sb</td>
            <td>rd,laddress</td>
            <td>Store byte (low 8 bits): <br> Mem[laddress] = Rf[rd] <br> <strong>Backwards Arguments!</strong><br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  sb    rd,laddress&0xFFFF($at)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>sc</td>
            <td>rt,oimm(rs)</td>
            <td>Unimplemented</td>
            <td>i</td>
        </tr>
        <tr>
            <td>seq</td>
            <td>rd,rs,rt</td>
            <td>Set if equal: <br> Rf[rd] = Rf[rs] == Rf[rt]<br/><br/><pre><code>  subu  $at,rs,rt
  sltiu rd,$at,1</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>sge</td>
            <td>rd,rs,rt</td>
            <td>Set greater than: <br> Rf[rd] = Rf[rs] > Rf[rt]<br/><br/><pre><code>  slt   rd,rs,rt
  slti  rd,rd,1</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>sgeu</td>
            <td>rd,rs,rt</td>
            <td>Set greater than unsigned: <br> Rf[rd] = Rf[rs] > Rf[rt]<br/><br/><pre><code>  sltu  rd,rs,rt
  slti  rd,rd,1</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>sgt</td>
            <td>rd,rt,rs</td>
            <td>Set Greater Than <br> alias for <strong>slt rd,rs,rt</strong> <br> if (RF[Rt] > RF[Rs] ) then RF[Rd] =1 else RF[Rd] = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sgtu</td>
            <td>rd,rt,rs</td>
            <td>Set Greater Than Unsigned <br> alias for <strong>sltu rd,rs,rt</strong> <br> if (RF[Rt] > RF[Rs] ) then RF[Rd] =1 else RF[Rd] = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sh</td>
            <td><strong>rt,oimm(rs)</strong></td>
            <td>Store Half: <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>sh</td>
            <td>rd,laddress</td>
            <td>Store half (low 16 bits): <br> Mem[laddress] = Rf[rd] <br> <strong>Backwards Arguments!</strong><br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  sh    rd,laddress&0xFFFF($at)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>sin.d</td>
            <td>dd,ds</td>
            <td>sine double: <br> FpRf[dd] = sin(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sin.s</td>
            <td>fd,fs</td>
            <td>sine single: <br> FpRf[fd] = sin(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sinh.d</td>
            <td>dd,ds</td>
            <td>hyperbolic sine double: <br> FpRf[dd] = sinh(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sinh.s</td>
            <td>fd,fs</td>
            <td>hyperbolic sine single: <br> FpRf[fd] = sinh(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sle</td>
            <td>rd,rs,rt</td>
            <td>Set less than or equal: <br> Rf[rd] = Rf[rs] <= Rf[rt]<br/><br/><pre><code>  slt   rd,rt,rs
  slti  rd,rd,1</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>sleu</td>
            <td>rd,rs,rt</td>
            <td>Set less than or equal unsigned: <br> Rf[rd] = Rf[rs] <= Rf[rt]<br/><br/><pre><code>  sltu  rd,rt,rs
  slti  rd,rd,1</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>sll</td>
            <td>rd,rt,sn</td>
            <td>Shift Left Logical (immediate) <br> RF[Rd] = RF[Rt] << n</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sll</td>
            <td>rd,rt,rs</td>
            <td>Shift Left Logical <br> alias for <strong>sllv rd,rt,rs</strong> <br> RF[Rd] = RF[Rt] << RF[Rs] amount</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sllv</td>
            <td>rd,rt,rs</td>
            <td>Shift Left Logical Variable <br> RF[Rd] = RF[Rt] << RF[Rs] amount</td>
            <td>r</td>
        </tr>
        <tr>
            <td>slt</td>
            <td>rd,rs,rt</td>
            <td>Set Less Than <br> if (RF[Rs] < RF[Rt] ) then RF[Rd] =1 else RF[Rd] = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>slti</td>
            <td>rt,rs,imm</td>
            <td>Set Less Than Immediate <br> if (RF[Rs] < Imm) then RF[Rt] = 1 else RF[Rt] = 0</td>
            <td>i</td>
        </tr>
        <tr>
            <td>sltiu</td>
            <td>rt,rs,imm</td>
            <td>Set Less Than Immediate Unsigned <br> if (RF[Rs] < Imm) then RF[Rt] = 1 else RF[Rt] = 0</td>
            <td>i</td>
        </tr>
        <tr>
            <td>sltu</td>
            <td>rd,rs,rt</td>
            <td>Set Less Than Unsigned <br> if (RF[Rs] < RF[Rt] ) then RF[Rd] =1 else RF[Rd] = 0</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sne</td>
            <td>rd,rs,rt</td>
            <td>Set if not equal: <br> Rf[rd] = Rf[rs] != Rf[rt]<br/><br/><pre><code>  subu  $at,rs,rt
  sltu  rd,$0,$at</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>sqrt.d</td>
            <td>dd,ds</td>
            <td>square root double: <br> FpRf[dd] = sqrt(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sqrt.s</td>
            <td>fd,fs</td>
            <td>square root single: <br> FpRf[fd] = sqrt(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sra</td>
            <td>rd,rt,sn</td>
            <td>Shift Right Arithmetic (immediate) <br> RF[Rd] = RF[Rt] >> n (sign-extend)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sra</td>
            <td>rd,rt,rs</td>
            <td>Shift Right Arithmetic <br> alias for <strong>srav rd,rt,rs</strong> <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (sign-extend)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>srav</td>
            <td>rd,rt,rs</td>
            <td>Shift Right Arithmetic Variable <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (sign-extend)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>srl</td>
            <td>rd,rt,sn</td>
            <td>Shift Right Logical <br> RF[Rd] = RF[Rt] >> n (no sign extension)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>srl</td>
            <td>rd,rt,rs</td>
            <td>Shift Right Logical <br> alias for <strong>srlv rd,rt,rs</strong> <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (no sign extension)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>srlv</td>
            <td>rd,rt,rs</td>
            <td>Shift Right Logical Variable <br> RF[Rd] = RF[Rt] >> RF[Rs] amount (no sign extension)</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sub</td>
            <td>rd,rs,rt</td>
            <td>Subtract <br> RF[Rd] = RF[Rs] - RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sub</td>
            <td>rt,rs,imm</td>
            <td>Subtract: <br> Rf[rt] = Rf[rs] - imm<br/><br/><pre><code>  addi  rt,rs,-imm</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>sub</td>
            <td>rt,imm</td>
            <td>Subtract: <br> Rf[rt] = Rf[rt] - imm<br/><br/><pre><code>  addi  rt,rt,-imm</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>sub.d</td>
            <td>dd,ds,dt</td>
            <td>Subtract double: <br> FpRf[dd] = FpRf[ds] - FpRf[dt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>sub.s</td>
            <td>fd,fs,ft</td>
            <td>Subtract single: <br> FpRf[fd] = FpRf[fs] - FpRf[ft]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>subu</td>
            <td>rd,rs,rt</td>
            <td>Subtract Unsigned <br> RF[Rd] = RF[Rs] - RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>subu</td>
            <td>rt,imm</td>
            <td>Subtract unsigned: <br> Rf[rt] = Rf[rt] - imm<br/><br/><pre><code>  addiu rt,rt,-imm</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>subu</td>
            <td>rt,rs,imm</td>
            <td>Subtract unsigned: <br> Rf[rt] = Rf[rs] - imm<br/><br/><pre><code>  addiu rt,rs,-imm</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>sw</td>
            <td><strong>rt,oimm(rs)</strong></td>
            <td>Store Word: <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>sw</td>
            <td>rd,laddress</td>
            <td>Store word (full 32 bits): <br> Mem[laddress] = Rf[rd] <br> <strong>Backwards Arguments!</strong><br/><br/><pre><code>  lui   $at,laddress&0x8000<<1+laddress>>16
  sw    rd,laddress&0xFFFF($at)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>swc1</td>
            <td><strong>ft,oimm(rs)</strong></td>
            <td>store word from cop1: <br> Mem[Rf[rs] + Offset] = FpRf[ft] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>swc2</td>
            <td>rt,oimm(rs)</td>
            <td>store word from cop2: <br> Mem[Rf[rs] + Offset] = Unimplemented</td>
            <td>i</td>
        </tr>
        <tr>
            <td>swc3</td>
            <td>rt,oimm(rs)</td>
            <td>store word from cop3: <br> Mem[Rf[rs] + Offset] = Unimplemented</td>
            <td>i</td>
        </tr>
        <tr>
            <td>swl</td>
            <td><strong>rt,oimm(rs)</strong></td>
            <td>Store Word Left (1-4 bytes, depending on offset): <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>swr</td>
            <td><strong>rt,oimm(rs)</strong></td>
            <td>Store Word Right (1-4 bytes, depending on offset): <br> Mem[RF[Rs] + Offset] = RF[Rt] <br> <strong>Backwards Arguments!</strong></td>
            <td>i</td>
        </tr>
        <tr>
            <td>syscall</td>
            <td></td>
            <td>call syscall in $v0</td>
            <td>b</td>
        </tr>
        <tr>
            <td>syscall</td>
            <td>Scode</td>
            <td>call syscall in argument</td>
            <td>b</td>
        </tr>
        <tr>
            <td>syscall</td>
            <td>Icode</td>
            <td>call syscall in argument</td>
            <td>b</td>
        </tr>
        <tr>
            <td>tan.d</td>
            <td>dd,ds</td>
            <td>tangent double: <br> FpRf[dd] = tan(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tan.s</td>
            <td>fd,fs</td>
            <td>tangent single: <br> FpRf[fd] = tan(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tanh.d</td>
            <td>dd,ds</td>
            <td>hyperbolic tangent double: <br> FpRf[dd] = tanh(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tanh.s</td>
            <td>fd,fs</td>
            <td>hyperbolic tangent single: <br> FpRf[fd] = tanh(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tlbp</td>
            <td></td>
            <td>Probe TLB For Matching Entry <br> Unimplemented</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tlbr</td>
            <td></td>
            <td>Read Indexed TLB Entry <br> Unimplemented</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tlbwi</td>
            <td></td>
            <td>Write Indexed TLB Entry <br> Unimplemented</td>
            <td>r</td>
        </tr>
        <tr>
            <td>tlbwr</td>
            <td></td>
            <td>Write Random TLB Entry <br> Unimplemented</td>
            <td>r</td>
        </tr>
        <tr>
            <td>trunc.d</td>
            <td>dd,ds</td>
            <td>truncate double and convert to integer: <br> FpRf[dd] = (int) trunc(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>trunc.s</td>
            <td>fd,fs</td>
            <td>truncate single and convert to integer: <br> FpRf[fd] = (int) trunc(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>trunc.w.d</td>
            <td>dd,ds</td>
            <td>truncate double: <br> FpRf[dd] = trunc(FpRf[ds])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>trunc.w.s</td>
            <td>fd,fs</td>
            <td>truncate single: <br> FpRf[fd] = trunc(FpRf[fs])</td>
            <td>r</td>
        </tr>
        <tr>
            <td>ulh</td>
            <td>rt,oimm(rs)</td>
            <td><br/><br/><pre><code>  lb    rt,oimm+1(rs)
  lbu   $at,oimm(rs)
  sll   rt,rt,8
  or    rt,rt,$at</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>ulhu</td>
            <td>rt,oimm(rs)</td>
            <td><br/><br/><pre><code>  lbu   rt,oimm+1(rs)
  lbu   $at,oimm(rs)
  sll   rt,rt,8
  or    rt,rt,$at</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>ulw</td>
            <td>rt,oimm(rs)</td>
            <td><br/><br/><pre><code>  lwl   rt,oimm+3(rs)
  lwr   rt,oimm(rs)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>ush</td>
            <td>rt,oimm(rs)</td>
            <td><br/><br/><pre><code>  sb    rt,oimm(rs)
  srl   $at,rt,8
  sb    $at,oimm+1(rs)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>usw</td>
            <td>rt,oimm(rs)</td>
            <td><br/><br/><pre><code>  swl   rt,oimm+3(rs)
  swr   rt,oimm(rs)</code></pre></td>
            <td></td>
        </tr>
        <tr>
            <td>xor</td>
            <td>rd,rs,rt</td>
            <td>Bitwise Xor <br> RF[Rd] = RF[Rs] ^ RF[Rt]</td>
            <td>r</td>
        </tr>
        <tr>
            <td>xori</td>
            <td>rt,rs,uimm</td>
            <td>Bitwise Xor Immediate <br> RF[Rt] = RF[Rs] ^ Imm</td>
            <td>i</td>
        </tr>
        <tr>
            <td>xori</td>
            <td>rt,imm</td>
            <td>Xor immediate: <br> Rf[rt] = Rf[rt] ^ imm<br/><br/><pre><code>  xori  rt,rt,imm</code></pre></td>
            <td></td>
        </tr>
    </tbody>
  </table>
</div>
            </div>
            <div class="container footer mw-100">
              <span>Last update: 2025 August 14</span>
            </div>
        </div><!-- col-md-12 -->
      </div><!-- row -->
    </div><!-- container-fluid -->
    
      
</body>
</html>